#ifndef __EVENT_DISPATCHER_H__
#define __EVENT_DISPATCHER_H__

#include <stdint.h>
#include <stddef.h>
#include <network_addr_lookup.h>
#include "network_tile_member_getsetter.h"
#include "network_memcommit_factory.h"
#include "network_producer_consumer.h"

#ifndef __NETWORK_TILEOPS_H__
#define __NETWORK_TILEOPS_H__

#include "network_tileops.h"
// #include "network_tileops_16_32.h"
// #include "network_tileops_32_16.h"
// #include "network_tileops_32_32.h"
// #include "network_memregion_lock.h"
#include "network_memory_utility.h"
#include "network_function_concurrent_buffer.h"
#include "network_tileops_poly.h"
#include "network_tile_member_getsetter.h" 
#include "network_memops_uma.h"
#include "network_vmamap.h"

namespace dg::network_memcommit_resolutor{

    struct UnifiedMemoryIPRetrieverInterface{
        virtual ~UnifiedMemoryIPRetrieverInterface() noexcept = default;
        virtual auto ip(uma_ptr_t) noexcept -> std::expected<Address, exception_t> = 0;
    };

    struct HostIPRetrieverInterface{
        virtual ~HostIPRetrieverInterface() noexcept = default;
        virtual auto ip() noexcept -> Address = 0;
    };

    struct ForeignTileAliasGetterInterface{
        virtual ~ForeignTileAliasGetterInterface() noexcept = default;
        virtual auto alias(uma_ptr_t) noexcept -> std::expected<std::optional<uma_ptr_t>, exception_t> = 0; //reduce lock_collisions by using distributed hash_map
    };

    template <class T>
    struct Request{
        Address requestee;
        T content;
        uint8_t retry_count;
        std::unique_ptr<dg::network_exception::ExceptionHandlerInterface> exception_handler;
    };

    struct EndUserPacket{
        eu_packet_header_t serialization_header;
        dg::string content;
        Address dst;
        uint8_t retry_count;
        eu_packet_urgency_t urgency;
        eu_packet_comm_t comm;
        std::unique_ptr<dg::network_exception::ExceptionHandlerInterface> exception_handler;
    };

    //we'll be getting this done + probably the access + getter done within 3 days
    //I dont know why we are running but we have 3 days sharp to complete this
    //1 month sharp to translate the logic of dicing -> gradient descend
    //1 month sharp to build a cuda instruction optimizer (compiler)

    //half a month to figure out the way to do interruptable asynchronous device (we are doing the kernel processes), this is optional, we prefer the kernel process or virtual machine containerization spawn
    //client pointed out that we did not do the asynchronous unit dispatch correctly, it needs to be reasonably partitioned to reach the maximum core efficiency

    //100 years to figure out the IP Man, IP Man is the most mysterious figure in the world, LeetCode problem 93
    //we need to store the IP Man in a 4 bytes format (convert to string -> to kernel addr), we dont even know how to do this for the 16 bytes format, people went from 4 bytes -> 16 bytes, like we are living in a trillion trillion planet

    //LeetCode problem 69
    //LeetCode problem 1, 15, 18
    //LeetCode problem 91
    //LeetCode problem 62, 63
    //LeetCode problem 29
    //LeetCode problem 12

    //OK, sounds like I would want to override my brother kernel, but it does not sound like that
    //our forward + backward machine has to be designed like this
    //it looks very dumb but I think this is for the best (maintainability wise + lock_tracking wise)
    
    //we operate mostly on SSD filesystem, we dedicate our RAM to the mailbox + socket + request + external book trackings
    //we have to operate on SSD filesystem because our temporal mapping is super very cheap and the memory loading overhead is not a significant cost compared to our searching + linear operations

    //this forward is probably one of the most complicated fling I have ever written

    //as I already explained, we need to able to thru the forward in every scenerio, every tile state is correct, even if the forwarded value is not a number
    //this is achieved via static addressing + static typing + static dispatch + etc.

    //we provided the fences of forward + backward to ensure: (1): stillness of the operating tree (which we run induction on)
    //                                                        (2): ticket access of the memevent

    //(3): vectorization + maintainability of the forward + backward operation by doing a "peek visit" before actual forward + forfeit the signal if there is not a match (signal is only guaranteed to be thru if it is before any other operations)) 

    class ForwardPingLeafSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_leaf_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    class ForwardPingBlkrSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingBlkrSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                           size_t delivery_capacity,
                                           size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                              delivery_capacity(delivery_capacity),
                                                                              vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_blkr_ptr_access(event.dst);
                
                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR = 1u;
                size_t max_possible_event_sz    = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_cap     = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost       = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_cap);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle            = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_cap, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_blkr_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id; 
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_blkr_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_blkr_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_blkr_signal_smph_addr_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t descendant = dg::network_tile_member_getsetter::get_blkr_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    virtual_memory_event_t event    = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(event));
                                } else{
                                    virtual_signal_memory_event_t sigagg    = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(),
                                                                                                                                                                                                   descendant, ptr, expected_ops_id,
                                                                                                                                                                                                   signal_smph_addr));
                                    virtual_memory_event_t event            = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(event));
                                }

                                dg::network_tile_member_getsetter::set_blkr_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED); 
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    //resistor
    class ForwardPingRstrSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{
        
        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;
        
        public:

            ForwardPingRstrSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                           size_t delivery_capacity,
                                           size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                              delivery_capacity(delivery_capacity),
                                                                              vectorization_sz(vectorization_sz){}
            
            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_meber_getsetter::safecthrow_rstr_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR = 1u;
                size_t max_possible_event_sz    = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_cap     = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost       = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_cap);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle            = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_cap, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz, std::integral_constant<size_t, 1u>{});
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, std::integral_constant<size_t, 1u>{}, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_rstr_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_rstr_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_rstr_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_rstr_signal_smph_addr_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t descendant            = dg::network_tile_member_getsetter::get_rstr_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    virtual_memory_event_t event    = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(event));    
                                } else{
                                    virtual_signal_memory_event_t sigagg    = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), descendant, ptr,
                                                                                                                                                                                                   expected_ops_id, signal_smph_addr));
                                    virtual_memory_event_t event            = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(event));
                                }

                                dg::network_tile_member_getsetter::set_rstr_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingMonoSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingMonoSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                           size_t delivery_capacity,
                                           size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                              delivery_capacity(delivery_capacity),
                                                                              vectorization_sz(vectorization_sz){}
            
            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_mono_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR = 1u;
                size_t max_possible_event_sz    = sz * EVENT_SCALE_FACTOR; 
                size_t trimmed_delivery_cap     = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost       = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_cap);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle            = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_cap, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz); 
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_mono_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_mono_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_mono_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_mono_signal_smph_addr_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t descendant    = dg::network_tile_member_getsetter::get_mono_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));    
                                } else{
                                    
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), descendant, ptr, 
                                                                                                                                                                                   expected_ops_id, signal_smph_addr));
 
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_sigagg_request(signal_smph_addr.value(), descendant, ptr, 
                                                                                                                                                                       dg::network_memcommit_factory::event_kind_forward_pingpong_request, 
                                                                                                                                                                       expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_mono_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPairSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPairSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                           size_t delivery_capacity,
                                           size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                              delivery_capacity(delivery_capacity),
                                                                              vectorization_sz(vectorization_sz){}
            
            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pair_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            } 

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 2u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR; 
                size_t trimmed_delivery_cap         = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_cap);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_cap, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr      = dg::network_tile_member_getsetter::get_pair_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_region    = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_region, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_pair_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_pair_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_pair_signal_smph_addr_nothrow()ptr;

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t left_descendant   = dg::network_tile_member_getsetter::get_pair_left_descendant_nothrow(ptr);
                                uma_ptr_t right_descendant  = dg::network_tile_member_getsetter::get_pair_right_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(left_descendant, ptr, expected_ops_id, signal_smph_addr));
                                    auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(right_descendant, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));    
                                } else{

                                    auto sigagg_1               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), left_descendant, ptr,
                                                                                                                                                                                       expected_ops_id, signal_smph_addr));
                                    auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_1));

                                    auto sigagg_2               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), right_descendant, ptr,
                                                                                                                                                                                       expected_ops_id, signal_smph_addr)); 
                                    auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_2));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));
                                }

                                dg::network_tile_member_getsetter::set_pair_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort(); 
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingUACMSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingUACMSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                           size_t delivery_capacity,
                                           size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                              delivery_capacity(delivery_capacity),
                                                                              vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_uacm_ptr_access(event.dst);

                if (!ptrchk.has_value())[
                    return ptrchk.error();
                ]

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = UACM_ACM_SZ;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);                
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_uacm_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_uacm_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_uacm_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_uacm_signal_smph_addr_nothrow(ptr); 

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> descendant_arr(UACM_ACM_SZ);
                                dg::network_tile_member_getsetter::get_uacm_descendant_nothrow(ptr, descendant_arr.get());

                                for (size_t i = 0u; i < UACM_ACM_SZ; ++i){
                                    if (!signal_smph_addr.has_value()){
                                        auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant_arr[i], ptr, expected_ops_id, signal_smph_addr));
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                    } else{
                                        auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), descendant_arr[i], ptr,
                                                                                                                                                                                       expected_ops_id, signal_smph_addr));
                                        auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                    }
                                }

                                dg::network_tile_member_getsetter::set_uacm_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPACMSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPACMSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                           size_t delivery_capacity,
                                           size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                              delivery_capacity(delivery_capacity),
                                                                              vectorization_sz(vectorization_sz){}
            
            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pacm_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{
                
                const size_t EVENT_SCALE_FACTOR     = PACM_ACM_SZ * 2;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_pacm_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_pacm_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_pacm_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_pacm_signal_smph_addr_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> left_descendant_arr(PACM_ACM_SZ);
                                dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> right_descendant_arr(PACM_ACM_SZ);
                                dg::network_tile_member_getsetter::get_pacm_left_descendant_nothrow(ptr, left_descendant_arr.get());
                                dg::network_tile_member_getsetter::get_pacm_right_descendant_nothrow(ptr, right_descendant_arr.get());

                                for (size_t i = 0u; i < PACM_ACM_SZ; ++i){
                                    if (!signal_smph_addr.has_value()){
                                        auto decay_signal_event_1 = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(left_descendant_arr[i], ptr, expected_ops_id, signal_smph_addr));
                                        auto decay_signal_event_2 = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(right_descendant_arr[i], ptr, expected_ops_id, signal_smph_addr));
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));    
                                    } else{
                                        auto sigagg_1               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), left_descendant_arr[i], ptr,
                                                                                                                                                                                           expected_ops_id, signal_smph_addr));
                                        auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(sigagg_1);

                                        auto sigagg_2               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), right_descendant_arr[i], ptr,
                                                                                                                                                                                           expected_ops_id, signal_smph_addr));
                                        auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(sigagg_2);

                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));
                                    }
                                }

                                dg::network_tile_member_getsetter::set_pacm_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }    
                    }
                }
            };
    };

    class ForwardPingCritSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingCritSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                           size_t delivery_capacity,
                                           size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                              delivery_capacity(delivery_capacity),
                                                                              vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_crit_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity); 
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz); 
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_crit_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_crit_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_crit_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_crit_signal_smph_addr_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t descendant    = dg::network_tile_member_getsetter::get_crit_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg_1           = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), descendant, ptr,
                                                                                                                                                                                   expected_ops_id, signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_1));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_crit_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingImmuSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_immu_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    class ForwardPingPolySignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{ //this is the punchline
                                                                                                                                   //the complications of the different implementations + virtues of programming must be resoluted at this component
                                                                                                                                   //this is like the X of X-Man
        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;
        
        public:

            ForwardPingPolySignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                           size_t delivery_capacity,
                                           size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                              delivery_capacity(delivery_capacity),
                                                                              vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_poly_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR = 2u;
                size_t max_possible_event_sz    = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_cap     = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost       = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_cap);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle            = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_cap, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));
                    
                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_poly_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }
        
        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_poly_init_status_nothrow(ptr);
                        operatable_id_set_t current_ops_id          = dg::network_tile_member_getsetter::get_poly_operatable_memevent_id_set_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_poly_signal_smph_addr_nothrow(ptr); 

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (!is_subset_id(expected_ops_id, current_ops_id)){
                                    break;
                                }

                                if constexpr(DEBUG_MODE_FLAG){
                                    poly_tile_t poly_type = dg::network_tile_member_getsetter::get_poly_poly_type_nothrow(ptr);

                                    if (poly_type != POLY_TILE_PAIR){
                                        dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                        std::abort();
                                    }
                                }

                                uma_ptr_t lhs_poly  = dg::network_tile_member_getsetter::get_poly_left_descendant_nothrow(ptr);
                                uma_ptr_t rhs_poly  = dg::network_tile_member_getsetter::get_poly_right_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(lhs_poly, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), lhs_poly, ptr, expected_ops_id, signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                if (rhs_poly != lhs_poly){
                                    if (!signal_smph_addr.has_value()){
                                        auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(rhs_poly, ptr, expected_ops_id, signal_smph_addr));
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                    } else{
                                        auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), rhs_poly, ptr, expected_ops_id, signal_smph_addr));
                                        auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));
    
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                    }
                                }

                                dg::network_tile_member_getsetter::set_poly_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingExtnSrcSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingExtnSrcSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                              size_t delivery_capacity,
                                              size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                 delivery_capacity(delivery_capacity),
                                                                                 vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrc_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz); 
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz); 
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz); 
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_extnsrc_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_extnsrc_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_extnsrc_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_extnsrc_signal_smph_addr_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t descendant    = dg::network_tile_member_getsetter::get_extnsrc_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));    
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), descendant, ptr,
                                                                                                                                                                                   expected_ops_id, signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_extnsrc_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingExtnSrxSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrx_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    class ForwardPingExtnDstSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<UnifiedMemoryIPRetrieverInterface> uma_ip_retriever;
            const std::shared_ptr<HostIPRetrieverInterface> host_ip_retriever;
            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<Request<external_virtual_memory_event_t>>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingExtnDstSignalResolutor(std::shared_ptr<UnifiedMemoryIPRetrieverInterface> uma_ip_retriever,
                                              std::shared_ptr<HostIPRetrieverInterface> host_ip_retriever,
                                              std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<Request<external_virtual_memory_event_t>>> request_box,
                                              size_t delivery_capacity,
                                              size_t vectorization_sz) noexcept: uma_ip_retriever(std::move(uma_ip_retriever)),
                                                                                 host_ip_retriever(std::move(host_ip_retriever)),
                                                                                 request_box(std::move(request_box)),
                                                                                 delivery_capacity(delivery_capacity),
                                                                                 vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndst_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor            = {};
                    internal_resolutor.uma_ip_retriever             = this->uma_ip_retriever->get();
                    internal_resolutor.host_ip_retriever            = this->host_ip_retriever->get();
                    internal_resolutor.request_delivery_handle      = delivery_handle.get();

                    size_t trimmed_vectorization_sz                 = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                      = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz); 
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle                 = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get())); //we are risking 0s - we will fix this later

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_extndst_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                UnifiedMemoryIPRetrieverInterface * uma_ip_retriever;
                HostIPRetrieverInterface * host_ip_retriever;
                dg::network_producer_consumer::DeliveryHandle<Request<external_virtual_memory_event_t>> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                       = event_arr[i].dst;
                        operatable_id_t expected_ops_id     = event_arr[i].operatable_id;
                        init_status_t init_status           = dg::network_tile_member_getsetter::get_extndst_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id      = dg::network_tile_member_getsetter::get_extndst_operatable_memevent_id_nothrow(ptr);
                        user_id_t user_id                   = dg::network_tile_member_getsetter::get_extndst_user_id_nothrow(ptr);
                        uint8_t retry_count                 = dg::network_tile_member_getsetter::get_extndst_ping_retry_count_nothrow(ptr); 

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t counterpart       = dg::network_tile_member_getsetter::get_extndst_counterpart_nothrow(ptr);
                                auto request                = Request<external_virtual_memory_event_t>{};
                                request.requestee           = this->uma_ip_retriever->ip(counterpart);
                                request.requestor           = this->host_ip_retriever->ip();
                                request.content             = dg::network_external_memcommit_factory::virtualize_event(dg::network_external_memcommit_factory::make_event_forward_ping_signal(counterpart, expected_ops_id));
                                request.retry_count         = retry_count;
                                request.exception_handler   = dg::network_exception::make_exception_handler_from_lambda([user_id, ptr](exception_t err) noexcept{
                                    if (dg::network_exception::is_failed(err)){
                                        dg::network_log::log_user_tile_error(user_id, ptr, dg::network_exception::verbose(err));
                                    }
                                });

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(request));
                                dg::network_tile_member_getsetter::set_extndst_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingExtnDsxSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndsx_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    class ForwardPingMsgrFwdSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingMsgrFwdSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                              size_t delivery_capacity,
                                              size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                 delivery_capacity(delivery_capacity),
                                                                                 vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrfwd_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{
                
                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_msgrfwd_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_msgrfwd_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_msgrfwd_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_msgrfwd_signal_smph_addr_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t descendant    = dg::network_tile_member_getsetter::get_msgrfwd_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), descendant, ptr,
                                                                                                                                                                                   expected_ops_id, signal_smph_addr)); 
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_msgrfwd_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingMsgrBwdSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingMsgrBwdSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                              size_t delivery_capacity,
                                              size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                 delivery_capacity(delivery_capacity),
                                                                                 vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{
                
                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrbwd_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz); 
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_msgrbwd_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                               = event_arr[i].dst;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_msgrbwd_init_status_nothrow(ptr);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_msgrbwd_operatable_memevent_id_nothrow(ptr);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_msgrbwd_signal_smph_addr_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t descendant    = dg::network_tile_member_getsetter::get_msgrbwd_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));                                        
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), descendant, ptr,
                                                                                                                                                                                   expected_ops_id, signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_msgrbwd_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent>{

        private:

            const std::unique_ptr<ForwardPingLeafSignalResolutor> leaf_resolutor;
            const std::unique_ptr<ForwardPingBlkrSignalResolutor> blkr_resolutor;
            const std::unique_ptr<ForwardPingRstrSignalResolutor> rstr_resolutor;
            const std::unique_ptr<ForwardPingMonoSignalResolutor> mono_resolutor;
            const std::unique_ptr<ForwardPingPairSignalResolutor> pair_resolutor;
            const std::unique_ptr<ForwardPingUACMSignalResolutor> uacm_resolutor;
            const std::unique_ptr<ForwardPingPACMSignalResolutor> pacm_resolutor;
            const std::unique_ptr<ForwardPingCritSignalResolutor> crit_resolutor;
            const std::unique_ptr<ForwardPingImmuSignalResolutor> immu_resolutor;
            const std::unique_ptr<ForwardPingPolySignalResolutor> poly_resolutor;
            const std::unique_ptr<ForwardPingExtnSrcSignalResolutor> extnsrc_resolutor;
            const std::unique_ptr<ForwardPingExtnSrxSignalResolutor> extnsrx_resolutor;
            const std::unique_ptr<ForwardPingExtnDstSignalResolutor> extndst_resolutor;
            const std::unique_ptr<ForwardPingExtnDsxSignalResolutor> extndsx_resolutor;
            const std::unique_ptr<ForwardPingMsgrFwdSignalResolutor> msgrfwd_resolutor;
            const std::unique_ptr<ForwardPingMsgrBwdSignalResolutor> msgrbwd_resolutor;
            const size_t kvfeed_vectorization_sz; 

        public:

            ForwardPingSignalResolutor(std::unique_ptr<ForwardPingLeafSignalResolutor> leaf_resolutor,
                                       std::unique_ptr<ForwardPingBlkrSignalResolutor> blkr_resolutor,
                                       std::unique_ptr<ForwardPingRstrSignalResolutor> rstr_resolutor,
                                       std::unique_ptr<ForwardPingMonoSignalResolutor> mono_resolutor,
                                       std::unique_ptr<ForwardPingPairSignalResolutor> pair_resolutor,
                                       std::unique_ptr<ForwardPingUACMSignalResolutor> uacm_resolutor,
                                       std::unique_ptr<ForwardPingPACMSignalResolutor> pacm_resolutor,
                                       std::unique_ptr<ForwardPingCritSignalResolutor> crit_resolutor,
                                       std::unique_ptr<ForwardPingImmuSignalResolutor> immu_resolutor,
                                       std::unique_ptr<ForwardPingPolySignalResolutor> poly_resolutor,
                                       std::unique_ptr<ForwardPingExtnSrcSignalResolutor> extnsrc_resolutor,
                                       std::unique_ptr<ForwardPingExtnSrxSignalResolutor> extnsrx_resolutor,
                                       std::unique_ptr<ForwardPingExtnDstSignalResolutor> extndst_resolutor,
                                       std::unique_ptr<ForwardPingExtnDsxSignalResolutor> extndsx_resolutor,
                                       std::unique_ptr<ForwardPingMsgrFwdSignalResolutor> msgrfwd_resolutor,
                                       std::unique_ptr<ForwardPingMsgrBwdSignalResolutor> msgrbwd_resolutor,
                                       size_t kvfeed_vectorization_sz) noexcept: leaf_resolutor(std::move(leaf_resolutor)),
                                                                                 blkr_resolutor(std::move(blkr_resolutor)),
                                                                                 rstr_resolutor(std::move(rstr_resolutor)),
                                                                                 mono_resolutor(std::move(mono_resolutor)),
                                                                                 pair_resolutor(std::move(pair_resolutor)),
                                                                                 uacm_resolutor(std::move(uacm_resolutor)),
                                                                                 pacm_resolutor(std::move(pacm_resolutor)),
                                                                                 crit_resolutor(std::move(crit_resolutor)),
                                                                                 immu_resolutor(std::move(immu_resolutor)),
                                                                                 poly_resolutor(std::move(poly_resolutor)),
                                                                                 extnsrc_resolutor(std::move(extnsrc_resolutor)),
                                                                                 extnsrx_resolutor(std::move(extnsrx_resolutor)),
                                                                                 extndst_resolutor(std::move(extndst_resolutor)),
                                                                                 extndsx_resolutor(std::move(extndsx_resolutor)),
                                                                                 msgrfwd_resolutor(std::move(msgrfwd_resolutor)),
                                                                                 msgrbwd_resolutor(std::move(msgrbwd_resolutor)),
                                                                                 kvfeed_vectorization_sz(kvfeed_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingSignalEvent& event) const noexcept -> exception_t{

                std::expected<tile_kind_t, exception_t> tile_kind = dg::network_tile_member_getsetter::get_tile_kind(event.dst);

                if (!tile_kind.has_value()){
                    return tile_kind.error();
                }

                switch (tile_kind.value()){
                    case TILE_KIND_LEAF: [[fallthrough]]
                    case TILE_KIND_BLKR: [[fallthrough]]
                    case TILE_KIND_RSTR: [[fallthrough]]
                    case TILE_KIND_MONO: [[fallthrough]]
                    case TILE_KIND_PAIR: [[fallthrough]]
                    case TILE_KIND_UACM: [[fallthrough]]
                    case TILE_KIND_PACM: [[fallthrough]]
                    case TILE_KIND_CRIT: [[fallthrough]]
                    case TILE_KIND_IMMU: [[fallthrough]]
                    case TILE_KIND_POLY: [[fallthrough]]
                    case TILE_KIND_EXTNSRC: [[fallthrough]]
                    case TILE_KIND_EXTNSRX: [[fallthrough]]
                    case TILE_KIND_EXTNDST: [[fallthrough]] 
                    case TILE_KIND_EXTNDSX: [[fallthrough]]
                    case TILE_KIND_MSGRFWD: [[fallthrough]]
                    case TILE_KIND_MSGRBWD:
                    {
                        return dg::network_exception::SUCCESS;
                    }
                    default:
                    {
                        return dg::network_exception::BAD_TILE_ACCESS;
                    }
                }
            }

            void push(ForwardPingSignalEvent * event_arr, size_t sz) noexcept{

                auto internal_resolutor                 = InternalResolutor{};

                internal_resolutor.leaf_resolutor       = this->leaf_resolutor.get();
                internal_resolutor.blkr_resolutor       = this->blkr_resolutor.get();
                internal_resolutor.rstr_resolutor       = this->rstr_resolutor.get();
                internal_resolutor.mono_resolutor       = this->mono_resolutor.get();
                internal_resolutor.pair_resolutor       = this->pair_resolutor.get();
                internal_resolutor.uacm_resolutor       = this->uacm_resolutor.get();
                internal_resolutor.pacm_resolutor       = this->pacm_resolutor.get();
                internal_resolutor.crit_resolutor       = this->crit_resolutor.get();
                internal_resolutor.immu_resolutor       = this->immu_resolutor.get();
                internal_resolutor.poly_resolutor       = this->poly_resolutor.get();
                internal_resolutor.extnsrc_resolutor    = this->extnsrc_resolutor.get();
                internal_resolutor.extnsrx_resolutor    = this->extnsrx_resolutor.get();
                internal_resolutor.extndst_resolutor    = this->extndst_resolutor.get();
                internal_resolutor.extndsx_resolutor    = this->extndsx_resolutor.get();
                internal_resolutor.msgrfwd_resolutor    = this->msgrfwd_resolutor.get();
                internal_resolutor.msgrbwd_resolutor    = this->msgrbwd_resolutor.get();

                size_t trimmed_kvfeed_vectorization_sz  = std::min(this->kvfeed_vectorization_sz, sz);
                size_t kvfeed_allocation_cost           = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&internal_resolutor, trimmed_kvfeed_vectorization_sz);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> kvfeed_mem(kvfeed_allocation_cost);
                auto feeder                             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_kv_open_preallocated_raiihandle(&internal_resolutor, trimmed_kvfeed_vectorization_sz, kvfeed_mem.get()));

                for (size_t i = 0u; i < sz; ++i){
                    if constexpr(DEBUG_MODE_FLAG){
                        if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                            std::abort();
                        }
                    }

                    tile_kind_t tile_kind = dg::network_tile_member_getsetter::get_tile_kind_nothrow(event_arr[i].dst);
                    dg::network_producer_consumer::delvrsrv_kv_deliver(feeder.get(), tile_kind, event_arr[i]);
                }
            }

        private:
            
            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<tile_kind_t, ForwardPingSignalEvent>{

                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * leaf_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * blkr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * rstr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * mono_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * pair_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * uacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * pacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * crit_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * immu_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * poly_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * extnsrc_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * extnsrx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * extndst_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * extndsx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * msgrfwd_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingSignalEvent> * msgrbwd_resolutor;

                void push(const tile_kind_t& tile_kind, std::move_iterator<ForwardPingSignalEvent *> event_arr, size_t sz){

                    switch (tile_kind){
                        case TILE_KIND_LEAF:
                        {
                            this->leaf_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_BLKR:
                        {
                            this->blkr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_RSTR:
                        {
                            this->rstr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MONO:
                        {
                            this->mono_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PAIR:
                        {
                            this->pair_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_UACM:
                        {
                            this->uacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PACM:
                        {
                            this->pacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_CRIT:
                        {
                            this->crit_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_IMMU:
                        {
                            this->immu_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_POLY:
                        {
                            this->poly_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRC:
                        {
                            this->extnsrc_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRX:
                        {
                            this->extnsrx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDST:
                        {
                            this->extndst_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDSX:
                        {
                            this->extndsx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRFWD:
                        {
                            this->msgrfwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRBWD:
                        {
                            this->msgrbwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        default:
                        {
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                            } else{
                                std::unreachable();
                            }
                        }
                    }
                }
            };
    };

    //---

    class ForwardPongLeafRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongLeafRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::networK_tile_member_access::safecthrow_leaf_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_leaf_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_leaf_init_status_nothrow(requestee);
                        set_operatable_id_t current_ops_id          = dg::network_tile_member_getsetter::get_leaf_operatable_memevent_id_set_nothrow(requestee);
                        // std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_leaf_signal_smph_addr_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (!is_subset_id(expected_ops_id, current_ops_id)){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    //the problem is here ...
                                    //this is a very hard task, I'm not even kidding

                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        } 
                    }
                }
            };
    };

    class ForwardPongBlkrRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongBlkrRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_blkr_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_blkr_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_blkr_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_blkr_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_blkr_push_observer_nothrow(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongRstrRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongRstrRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_rstr_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_rstr_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }
        
        private:

            struct  InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_rstr_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_rstr_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_push_observer_nothrow(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongMonoRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongMonoRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_mono_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz); 
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_mono_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_mono_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_mono_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_mono_push_observer_nothrow(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongPairRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz; 

        public:

            ForwardPongPairRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pair_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR; 
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz); 
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz); 
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_pair_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr; 
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_pair_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_pair_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_pair_push_observer(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));                                     
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongUACMRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz; 

        public:

            ForwardPongUACMRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_uacm_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz); 
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get())); 

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_uacm_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_uacm_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_uacm_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_uacm_push_observer(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongPACMRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongPACMRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pacm_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz); 
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_pacm_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_pacm_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_pacm_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_pacm_push_observer(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongCritRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongCritRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_crit_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity); 
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_crit_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_crit_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_crit_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_crit_push_observer(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::devlrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongImmuRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongImmuRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_immu_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get())); //

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_immu_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_immu_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_immu_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongPolyRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongPolyRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            size_t delivery_capacity,
                                            size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                               delivery_capacity(delivery_capacity),
                                                                               vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_poly_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_poly_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }
        
        private:
            
            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(const uma_ptr_t& rcu_addr, std::move_iterator<ForwardPongRequestEvent *> org_event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    ForwardPongRequestEvent * event_arr = org_event_arr.base();

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_poly_init_status_nothrow(requestee);
                        operatable_id_set_t current_ops_id          = dg::network_tile_member_getsetter::get_poly_operatable_memevent_id_set_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (!is_subset_id(expected_ops_id, current_ops_id)){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_poly_push_observer(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (!is_subset_id(expected_ops_id, current_ops_id)){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongExtnSrcRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongExtnSrcRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                               size_t delivery_capacity,
                                               size_t vectorization_sz) noexcept request_box(std::move(request_box)),
                                                                                 delivery_capacity(delivery_capacity),
                                                                                 vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrc_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();
                    
                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));
                    
                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_extnsrc_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }
        
        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(const uma_ptr_t& rcu_addr, std::move_iterator<ForwardPongRequestEvent *> org_event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    ForwardPongRequestEvent * event_arr = org_event_arr.base();

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_extnsrc_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_extnsrc_operatable_memevent_id_nothrow(requestee);
                    
                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_extnsrc_push_observer(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg)); 

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongExtnSrxRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrx_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    class ForwardPongExtnDstRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongExtnDstRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                               size_t delivery_capacity,
                                               size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                  delivery_capacity(delivery_capacity),
                                                                                  vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndst_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz); 
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_extndst_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr; 
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_extndst_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_extndst_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                   break;
                                }

                                dg::network_tile_member_getsetter::controller_extndst_push_observer(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongExtnDsxRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndsx_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    class ForwardPongMsgrFwdRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongMsgrFwdRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                               size_t delivery_capacity,
                                               size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                  delivery_capacity(delivery_capacity),
                                                                                  vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrfwd_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz); 
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity); 
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz); 
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_msgrfwd_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_msgrfwd_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_msgrfwd_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_msgrfwd_push_observer(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongMsgrBwdRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPongMsgrBwdRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                               size_t delivery_capacity,
                                               size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                  delivery_capacity(delivery_capacity),
                                                                                  vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrbwd_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz); 
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz); 
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_msgrbwd_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr; 
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_msgrbwd_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_msgrbwd_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_msgrbwd_push_observer(requestee, requestor, signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPongRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent>{

        private:

            const std::unique_ptr<ForwardPongLeafRequestResolutor> leaf_resolutor;
            const std::unique_ptr<ForwardPongBlkrRequestResolutor> blkr_resolutor;
            const std::unique_ptr<ForwardPongRstrRequestResolutor> rstr_resolutor;
            const std::unique_ptr<ForwardPongMonoRequestResolutor> mono_resolutor;
            const std::unique_ptr<ForwardPongPairRequestResolutor> pair_resolutor;
            const std::unique_ptr<ForwardPongUACMRequestResolutor> uacm_resolutor;
            const std::unique_ptr<ForwardPongPACMRequestResolutor> pacm_resolutor;
            const std::unique_ptr<ForwardPongCritRequestResolutor> crit_resolutor;
            const std::unique_ptr<ForwardPongImmuRequestResolutor> immu_resolutor;
            const std::unique_ptr<ForwardPongPolyRequestResolutor> poly_resolutor;
            const std::unique_ptr<ForwardPongExtnSrcRequestResolutor> extnsrc_resolutor;
            const std::unique_ptr<ForwardPongExtnSrxRequestResolutor> extnsrx_resolutor;
            const std::unique_ptr<ForwardPongExtnDstRequestResolutor> extndst_resolutor;
            const std::unique_ptr<ForwardPongExtnDsxRequestResolutor> extndsx_resolutor;
            const std::unique_ptr<ForwardPongMsgrFwdRequestResolutor> msgrfwd_resolutor;
            const std::unique_ptr<ForwardPongMsgrBwdRequestResolutor> msgrbwd_resolutor;
            const size_t kvfeed_vectorization_sz;

        public:

            ForwardPongRequestResolutor(std::unique_ptr<ForwardPongLeafRequestResolutor> leaf_resolutor,
                                        std::unique_ptr<ForwardPongBlkrRequestResolutor> blkr_resolutor,
                                        std::unique_ptr<ForwardPongRstrRequestResolutor> rstr_resolutor,
                                        std::unique_ptr<ForwardPongMonoRequestResolutor> mono_resolutor,
                                        std::unique_ptr<ForwardPongPairRequestResolutor> pair_resolutor,
                                        std::unique_ptr<ForwardPongUACMRequestResolutor> uacm_resolutor,
                                        std::unique_ptr<ForwardPongPACMRequestResolutor> pacm_resolutor,
                                        std::unique_ptr<ForwardPongCritRequestResolutor> crit_resolutor,
                                        std::unique_ptr<ForwardPongImmuRequestResolutor> immu_resolutor,
                                        std::unique_ptr<ForwardPongPolyRequestResolutor> poly_resolutor,
                                        std::unique_ptr<ForwardPongExtnSrcRequestResolutor> extnsrc_resolutor,
                                        std::unique_ptr<ForwardPongExtnSrxRequestResolutor> extnsrx_resolutor,
                                        std::unique_ptr<ForwardPongExtnDstRequestResolutor> extndst_resolutor,
                                        std::unique_ptr<ForwardPongExtnDsxRequestResolutor> extndsx_resolutor,
                                        std::unique_ptr<ForwardPongMsgrFwdRequestResolutor> msgrfwd_resolutor,
                                        std::unique_ptr<ForwardPongMsgrBwdRequestResolutor> msgrbwd_resolutor,
                                        size_t kvfeed_vectorization_sz) noexcept: leaf_resolutor(std::move(leaf_resolutor)),
                                                                                  blkr_resolutor(std::move(blkr_resolutor)),
                                                                                  rstr_resolutor(std::move(rstr_resolutor)),
                                                                                  mono_resolutor(std::move(mono_resolutor)),
                                                                                  pair_resolutor(std::move(pair_resolutor)),
                                                                                  uacm_resolutor(std::move(uacm_resolutor)),
                                                                                  pacm_resolutor(std::move(pacm_resolutor)),
                                                                                  crit_resolutor(std::move(crit_resolutor)),
                                                                                  immu_resolutor(std::move(immu_resolutor)),
                                                                                  poly_resolutor(std::move(poly_resolutor)),
                                                                                  extnsrc_resolutor(std::move(extnsrc_resolutor)),
                                                                                  extnsrx_resolutor(std::move(extnsrx_resolutor)),
                                                                                  extndst_resolutor(std::move(extndst_resolutor)),
                                                                                  extndst_resolutor(std::move(extndst_resolutor)),
                                                                                  extndsx_resolutor(std::move(extndsx_resolutor)),
                                                                                  msgrfwd_resolutor(std::move(msgrfwd_resolutor)),
                                                                                  msgrbwd_resolutor(std::move(msgrbwd_resolutor)),
                                                                                  kvfeed_vectorization_sz(kvfeed_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<tile_kind_t, exception_t> tile_kind = dg::network_tile_member_getsetter::get_tile_kind(event.requestee);

                if (!tile_kind.has_value()){
                    return tile_kind.error();
                }

                switch (tile_kind.value()){
                    case TILE_KIND_LEAF: [[fallthrough]]
                    case TILE_KIND_BLKR: [[fallthrough]]
                    case TILE_KIND_RSTR: [[fallthrough]]
                    case TILE_KIND_MONO: [[fallthrough]]
                    case TILE_KIND_PAIR: [[fallthrough]]
                    case TILE_KIND_UACM: [[fallthrough]]
                    case TILE_KIND_PACM: [[fallthrough]]
                    case TILE_KIND_CRIT: [[fallthrough]]
                    case TILE_KIND_IMMU: [[fallthrough]]
                    case TILE_KIND_POLY: [[fallthrough]]
                    case TILE_KIND_EXTNSRC: [[fallthrough]]
                    case TILE_KIND_EXTNSRX: [[fallthrough]]
                    case TILE_KIND_EXTNDST: [[fallthrough]]
                    case TILE_KIND_EXTNDSX: [[fallthrough]]
                    case TILE_KIND_MSGRFWD: [[fallthrough]]
                    case TILE_KIND_MSGRBWD:
                    {
                        return dg::network_exception::SUCCESS;
                    }
                    default:
                    {
                        return dg::network_exception::BAD_TILE_ACCESS;
                    }
                }
            }

            void push(ForwardPongRequestEvent * event_arr, size_t sz) noexcept{

                auto internal_resolutor                 = InternalResolutor{};

                internal_resolutor.leaf_resolutor       = this->leaf_resolutor.get();
                internal_resolutor.blkr_resolutor       = this->blkr_resolutor.get();
                internal_resolutor.rstr_resolutor       = this->rstr_resolutor.get();
                internal_resolutor.mono_resolutor       = this->mono_resolutor.get();
                internal_resolutor.pair_resolutor       = this->pair_resolutor.get();
                internal_resolutor.uacm_resolutor       = this->uacm_resolutor.get();
                internal_resolutor.pacm_resolutor       = this->pacm_resolutor.get();
                internal_resolutor.crit_resolutor       = this->crit_resolutor.get();
                internal_resolutor.immu_resolutor       = this->immu_resolutor.get();
                internal_resolutor.poly_resolutor       = this->poly_resolutor.get();
                internal_resolutor.extnsrc_resolutor    = this->extnsrc_resolutor.get();
                internal_resolutor.extnsrx_resolutor    = this->extnsrx_resolutor.get();
                internal_resolutor.extndst_resolutor    = this->extndst_resolutor.get();
                internal_resolutor.extndsx_resolutor    = this->extndsx_resolutor.get();
                internal_resolutor.msgrfwd_resolutor    = this->msgrfwd_resolutor.get();
                internal_resolutor.msgrbwd_resolutor    = this->msgrbwd_resolutor.get();

                size_t trimmed_kvfeed_vectorization_sz  = std::min(this->kvfeed_vectorization_sz, sz);
                size_t kvfeed_allocation_cost           = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&internal_resolutor, trimmed_kvfeed_vectorization_sz);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> kvfeed_mem(kvfeed_allocation_cost);
                auto feeder                             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_kv_open_preallocated_raiihandle(&internal_resolutor, trimmed_kvfeed_vectorization_sz, kvfeed_mem.get()));

                for (size_t i = 0u; i < sz; ++i){
                    if constexpr(DEBUG_MODE_FLAG){
                        if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                            std::abort();
                        }
                    }

                    tile_kind_t tile_kind = dg::network_tile_member_getsetter::get_tile_kind_nothrow(event_arr[i].requestee);
                    dg::network_producer_consumer::delvrsrv_kv_deliver(feeder.get(), tile_kind, event_arr[i]);
                }
            }
        
        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<tile_kind_t, ForwardPongRequestEvent>{

                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * leaf_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * blkr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * rstr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * mono_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * pair_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * uacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * pacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * crit_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * immu_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * poly_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * extnsrc_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * extnsrx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * extndst_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * extndsx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * msgrfwd_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPongRequestEvent> * msgrbwd_resolutor;

                void push(const tile_kind_t& tile_kind, std::move_iterator<ForwardPongRequestEvent *> event_arr, size_t sz){

                    switch (tile_kind){
                        case TILE_KIND_LEAF:
                        {
                            this->leaf_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_BLKR:
                        {
                            this->blkr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_RSTR:
                        {
                            this->rstr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MONO:
                        {
                            this->mono_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PAIR:
                        {
                            this->pair_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_UACM:
                        {
                            this->uacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PACM:
                        {
                            this->pacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_CRIT:
                        {
                            this->crit_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_IMMU:
                        {
                            this->immu_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_POLY:
                        {
                            this->poly_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRC:
                        {
                            this->extnsrc_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRX:
                        {
                            this->extnsrx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDST:
                        {
                            this->extndst_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDSX:
                        {
                            this->extndsx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRFWD:
                        {
                            this->msgrfwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRBWD:
                        {
                            this->msgrbwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        default:
                        {
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                            } else{
                                std::unreachable();
                            }
                        }
                    }
                }
            };
    };

    //

    class ForwardPingPongLeafRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz; 

        public:

            ForwardPingPongLeafRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_leaf_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                size_t EVENT_SCALE_FACTOR           = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_leaf_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_leaf_init_status_nothrow(requestee);
                        set_operatable_id_t current_ops_id          = dg::network_tile_member_getsetter::get_leaf_operatable_memevent_id_set_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (!is_subset_id(expected_ops_id, current_ops_id)){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongBlkrRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;
        
        public:

            ForwardPingPongBlkrRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_blkr_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_blkr_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr;

                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_blkr_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_blkr_operatable_memevent_id_nothrow(requestee);
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_blkr_signal_smph_addr_nothrow(requestee);
                        uma_ptr_t descendant                            = dg::network_tile_member_getsetter::get_blkr_descendant_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_blkr_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!ping_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, requestee, expected_ops_id, ping_signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), descendant, requestee,
                                                                                                                                                                                   expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_blkr_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongRstrRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;
        
        public:

            ForwardPingPongRstrRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_rstr_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR         = 1u;
                size_t max_possible_event_sz            = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity        = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost               = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                    = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_rstr_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }
        
        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr;
                        
                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_rstr_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_rstr_operatable_memevent_id_nothrow(requestee);
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_rstr_signal_smph_addr_nothrow(requestee);
                        uma_ptr_t descendant                            = dg::network_tile_member_getsetter::get_rstr_descendant_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_rstr_push_observer_nothrow(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!ping_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, requestee, expected_ops_id, ping_signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), descendant, requestee,
                                                                                                                                                                                   expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_tile_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongMonoRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongMonoRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_mono_ptr_access(event.requestee);
                
                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR         = 1u;
                size_t max_possible_event_sz            = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity        = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost               = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);   
                auto delivery_handle                    = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_mono_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr;
                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_mono_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_mono_operatable_memevent_id_nothrow(requestee);
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_mono_signal_smph_addr_nothrow(requestee); 
                        uma_ptr_t descendant                            = dg::network_tile_member_getsetter::get_mono_descendant_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_mono_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!ping_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, requestee, expected_ops_id, ping_signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), descendant, requestee,
                                                                                                                                                                                   expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_mono_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongPairRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongPairRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pair_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = dg::network_tile_metadata::PAIR_DESCENDANT_COUNT;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz); 
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_pair_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr; 

                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_pair_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_pair_operatable_memevent_id_nothrow(requestee);
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_pair_signal_smph_addr_nothrow(requestee); 
                        uma_ptr_t left_descendant                       = dg::network_tile_member_getsetter::get_pair_left_descendant_nothrow(requestee);
                        uma_ptr_t right_descendant                      = dg::network_tile_member_getsetter::get_pair_right_descendant_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_pair_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!ping_signal_smph_addr.has_value()){
                                    auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(left_descendant, requestee, expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(right_descendant, requestee, expected_ops_id, ping_signal_smph_addr));

                                    dg::network_producer_consumer::delvrsrv_deliver(std::move(decay_signal_event_1));
                                    dg::network_producer_consumer::delvrsrv_deliver(std::move(decay_signal_event_2));
                                } else{
                                    auto sigagg_1               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), left_descendant, requestee,
                                                                                                                                                                                       expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_1));

                                    auto sigagg_2               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), right_descendant, requestee,
                                                                                                                                                                                       expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_2));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));
                                }

                                dg::network_tile_member_getsetter::set_pair_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongUACMRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongUACMRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_uacm_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = UACM_ACM_SZ;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get())); 

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_uacm_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr;

                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_uacm_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_uacm_operatable_memevent_id_nothrow(requestee);
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_uacm_signal_smph_addr_nothrow(requestee); 

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_uacm_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> descendant_arr(UACM_ACM_SZ);
                                dg::network_tile_member_getsetter::get_uacm_descendant_nothrow(ptr, descendant_arr.get());

                                if (!ping_signal_smph_addr.has_value()){
                                    for (size_t i = 0u; i < UACM_ACM_SZ; ++i){
                                        auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant_arr[i], requestee, expected_ops_id, ping_signal_smph_addr));
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                    }
                                } else{
                                    for (size_t i = 0u; i < UACM_ACM_SZ; ++i){
                                        auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), descendant_arr[i], requestee, 
                                                                                                                                                                                       expected_ops_id, ping_signal_smph_addr));
                                        auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                    }
                                }

                                dg::network_tile_member_getsetter::set_uacm_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongPACMRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongPACMRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pacm_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = PACM_ACM_SZ * 2;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz); 
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_pacm_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr; 

                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_pacm_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_pacm_operatable_memevent_id_nothrow(requestee);
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_pacm_signal_smph_addr_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_pacm_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event)); 
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));
                                    
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> left_descendant_arr(PACM_ACM_SZ);
                                dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> right_descendant_arr(PACM_ACM_SZ);

                                dg::network_tile_member_getsetter::get_pacm_left_descendant_nothrow(requestee, left_descendant_arr.get());
                                dg::network_tile_member_getsetter::get_pacm_right_descendant_nothrow(requestee, right_descendant_arr.get());
                                
                                if (!ping_signal_smph_addr.has_value()){
                                    for (size_t i = 0u; i < PACM_ACM_SZ; ++i){
                                        auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(left_descendant_arr[i], requestee, expected_ops_id, ping_signal_smph_addr));
                                        auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(right_descendant_arr[i], requestee, expected_ops_id, ping_signal_smph_addr));

                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));
                                    }    
                                } else{
                                    for (size_t i = 0u; i < PACM_ACM_SZ; ++i){
                                        auto sigagg_1               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), left_descendant_arr[i], requestee,
                                                                                                                                                                                           expected_ops_id, ping_signal_smph_addr));
                                        auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_1));
                                        auto sigagg_2               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), right_descendant_arr[i], requestee,
                                                                                                                                                                                           expected_ops_id, ping_signal_smph_addr));
                                        auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_2));

                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));
                                    }    
                                }

                                dg::network_tile_member_getsetter::set_pacm_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongCritRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongCritRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_crit_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_crit_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr;
                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_crit_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_crit_operatable_memevent_id_nothrow(requestee); 
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_crit_signal_smph_addr_nothrow(requestee); 
                        uma_ptr_t descendant                            = dg::network_tile_member_getsetter::get_crit_descendant_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_crit_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id)); 
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED; [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!ping_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, requestee, expected_ops_id, ping_signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), descendant, requestee,
                                                                                                                                                                                   expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_crit_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongImmuRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongImmuRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_immu_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR         = 1u;
                size_t max_possible_event_sz            = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity        = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost               = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                    = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_immu_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, std::tuple<uma_ptr_t, uma_ptr_t> * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                         = event_arr[i].requestee;
                        uma_ptr_t requestor                         = event_arr[i].requestor;
                        operatable_id_t expected_ops_id             = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> signal_smph_addr   = event_arr[i].notify_addr;
                        init_status_t init_status                   = dg::network_tile_member_getsetter::get_immu_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id              = dg::network_tile_member_getsetter::get_immu_operatable_memevent_id_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongPolyRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;
        
        public:

            ForwardPingPongPolyRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                size_t delivery_capacity,
                                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                   delivery_capacity(delivery_capacity),
                                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_poly_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 2u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));
                
                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_poly_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:
            
            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(const uma_ptr_t& rcu_addr, std::move_iterator<ForwardPingPongRequestEvent *> org_event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr;

                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_poly_init_status_nothrow(requestee);
                        operatable_id_set_t current_ops_id              = dg::network_tile_member_getsetter::get_poly_operatable_memevent_id_set_nothrow(requestee);
                        poly_tile_t poly_type                           = dg::network_tile_member_getsetter::get_poly_poly_type_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (!is_subset_id(expected_ops_id, current_ops_id)){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_poly_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (!is_subset_id(expected_ops_id, current_ops_id)){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event)); 
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (!is_subset_id(expected_ops_id, current_ops_id)){
                                    break;
                                }

                                if constexpr(DEBUG_MODE_FLAG){
                                    poly_tile_t poly_type = dg::network_tile_member_getsetter::get_poly_poly_type_nothrow(ptr);

                                    if (poly_type != POLY_TILE_PAIR){
                                        dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                        std::abort();
                                    }
                                }

                                uma_ptr_t lhs_poly  = dg::network_tile_member_getsetter::get_poly_left_descendant_nothrow(ptr);
                                uma_ptr_t rhs_poly  = dg::network_tile_member_getsetter::get_poly_right_descendant_nothrow(ptr);

                                if (!signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(lhs_poly, ptr, expected_ops_id, signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), lhs_poly, ptr, expected_ops_id, signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                if (rhs_poly != lhs_poly){
                                    if (!signal_smph_addr.has_value()){
                                        auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(rhs_poly, ptr, expected_ops_id, signal_smph_addr));
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                    } else{
                                        auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(signal_smph_addr.value(), rhs_poly, ptr, expected_ops_id, signal_smph_addr));
                                        auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));
    
                                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                    }
                                }

                                dg::network_tile_member_getsetter::set_poly_init_status_nothrow(ptr, TILE_INIT_STATUS_DECAYED);
                                break;                            
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongExtnSrcRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongExtnSrcRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                   size_t delivery_capacity,
                                                   size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                      delivery_capacity(delivery_capacity),
                                                                                      vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrc_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR         = 1u;
                size_t max_possible_event_sz            = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity        = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost               = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                    = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_extnsrc_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr; 

                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_extnsrc_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_extnsrc_operatable_memevent_id_nothrow(requestee);
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_extnsrc_signal_smph_addr_nothrow(requestee); 
                        uma_ptr_t descendant                            = dg::network_tile_member_getsetter::get_extnsrc_descendant_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_extnsrc_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!ping_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, requestee, expected_ops_id, ping_signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), descendant, requestee,
                                                                                                                                                                                   expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_extnsrc_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongExtnSrxRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrx_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent  * event_arr, size_t) noexcept{

                (void) event_arr;
            }
    };

    class ForwardPingPongExtnDstRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<UnifiedMemoryIPRetrieverInterface> uma_ip_retriever;
            const std::shared_ptr<HostIPRetrieverInterface> host_ip_retriever;
            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<Request<external_virtual_memory_event_t>>> outbound_request_box;
            const size_t request_delivery_capacity;
            const size_t outbound_delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongExtnDstRequestResolutor(std::shared_ptr<UnifiedMemoryIPRetrieverInterface> uma_ip_retriever,
                                                   std::shared_ptr<HostIPRetrieverInterface> host_ip_retriever,
                                                   std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                   std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<Request<external_virtual_memory_event_t>>> outbound_request_box,
                                                   size_t request_delivery_capacity,
                                                   size_t outbound_delivery_capacity,
                                                   size_t vectorization_sz) noexcept: uma_ip_retriever(std::move(uma_ip_retriever)),
                                                                                      host_ip_retriever(std::move(host_ip_retriever)),
                                                                                      request_box(std::move(request_box)),
                                                                                      outbound_request_box(std::move(outbound_request_box)),
                                                                                      request_delivery_capacity(request_delivery_capacity),
                                                                                      outbound_delivery_capacity(outbound_delivery_capacity),
                                                                                      vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndst_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t INTERNAL_EVENT_SCALE_FACTOR    = 1u;
                size_t max_possible_internal_event_sz       = sz * INTERNAL_EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_internal_event_sz); 
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                const size_t EXTERNAL_EVENT_SCALE_FACTOR    = 1u;
                size_t max_possible_external_event_sz       = sz * EXTERNAL_EVENT_SCALE_FACTOR;
                size_t trimmed_outbound_delivery_capacity   = std::min(this->oubound_delivery_capacity, max_possible_external_event_sz);
                size_t odh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->outbound_request_box.get(), trimmed_outbound_delivery_capacity); 
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> odh_mem(odh_allocation_cost);
                auto outbound_delivery_handle               = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->outbound_request_box.get(), trimmed_outbound_delivery_capacity, odh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.uma_ip_retriever         = this->uma_ip_retriever.get();
                    internal_resolutor.host_ip_retriever        = this->host_ip_retriever.get();
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.outbound_delivery_handle = outbound_delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz); 
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_extndst_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                UnifiedMemoryIPRetrieverInterface * uma_ip_retriever;
                HostIPRetrieverInterface * host_ip_retriever;
                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_producer_consumer::DeliveryHandle<Request<external_virtual_memory_event_t>> * outbound_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr;  

                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_extndst_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_extndst_operatable_memevent_id_nothrow(requestee);
                        user_id_t user_id                               = dg::network_tile_member_getsetter::get_extndst_user_id_nothrow(requestee);
                        uint8_t retry_count                             = dg::network_tile_member_getsetter::get_extndst_ping_retry_count_nothrow(requestee); 

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_extndst_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }   
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                uma_ptr_t counterpart           = dg::network_tile_member_getsetter::get_extndst_counterpart_nothrow(requestee);
                                auto ping_request               = Request<external_virtual_memory_event_t>{};
                                ping_request.requestee          = this->uma_ip_retriever->ip(counterpart);
                                ping_request.requestor          = this->host_ip_retriever->ip();
                                ping_request.content            = dg::network_external_memcommit_factory::virtualize_event(dg::network_external_memcommit_factory::make_event_forward_ping_signal(counterpart, expected_ops_id)); //should be pingpong
                                ping_request.retry_count        = retry_count;
                                ping_request.exception_handler  = dg::network_exception::make_exception_handler_from_lambda([user_id, requestee](exception_t err) noexcept{
                                    if (dg::network_exception::is_failed(err)){
                                        dg::network_log::log_user_tile_error(user_id, requestee, dg::network_exception::verbose(err));
                                    }
                                });

                                dg::network_producer_consumer::delvrsrv_deliver(this->outbound_delivery_handle, std::move(ping_request));
                                dg::network_tile_member_getsetter::set_extndst_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongExtnDsxRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndsx_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t) noexcept{

                (void) event_arr;
            }
    };

    class ForwardPingPongMsgrFwdRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongMsgrFwdRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                   size_t delivery_capacity,
                                                   size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                      delivery_capacity(delivery_capacity),
                                                                                      vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrfwd_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_msgrfwd_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr; 

                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_msgrfwd_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_msgrfwd_operatable_memevent_id_nothrow(requestee);
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_msgrfwd_signal_smph_addr_nothrow(requestee); 
                        uma_ptr_t descendant                            = dg::network_tile_member_getsetter::get_msgrfwd_descendant_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_msgrfwd_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event)); 
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!ping_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, requestee, expected_ops_id, ping_signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), descendant, requestee,
                                                                                                                                                                                   expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg)); 

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_msgrfwd_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongMsgrBwdRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            ForwardPingPongMsgrBwdRequestResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                                   size_t delivery_capacity,
                                                   size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                      delivery_capacity(delivery_capacity),
                                                                                      vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrbwd_ptr_access(event.requestee);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost); 
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_msgrbwd_rcu_addr_nothrow(event_arr[i].requestee);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void push(uma_ptr_t rcu_addr, ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t requestee                             = event_arr[i].requestee;
                        uma_ptr_t requestor                             = event_arr[i].requestor;
                        operatable_id_t expected_ops_id                 = event_arr[i].operatable_id;
                        std::optional<uma_ptr_t> pong_signal_smph_addr  = event_arr[i].notify_addr;
                        init_status_t init_status                       = dg::network_tile_member_getsetter::get_msgrbwd_init_status_nothrow(requestee);
                        operatable_id_t current_ops_id                  = dg::network_tile_member_getsetter::get_msgrbwd_operatable_memevent_id_nothrow(requestee);
                        std::optional<uma_ptr_t> ping_signal_smph_addr  = dg::network_tile_member_getsetter::get_msgrbwd_signal_smph_addr_nothrow(requestee);
                        uma_ptr_t descendant                            = dg::network_tile_member_getsetter::get_msgrbwd_descendant_nothrow(requestee);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                dg::network_tile_member_getsetter::controller_msgrbwd_push_observer(requestee, requestor, pong_signal_smph_addr);
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!pong_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(requestor, expected_ops_id));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(pong_signal_smph_addr.value(), requestor, expected_ops_id));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id != expected_ops_id){
                                    break;
                                }

                                if (!ping_signal_smph_addr.has_value()){
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_pingpong_request(descendant, requestee, expected_ops_id, ping_signal_smph_addr));
                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                } else{
                                    auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_pingpong_request(ping_signal_smph_addr.value(), descendant, requestee,
                                                                                                                                                                                   expected_ops_id, ping_signal_smph_addr));
                                    auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                    dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                                }

                                dg::network_tile_member_getsetter::set_msgrbwd_init_status_nothrow(requestee, TILE_INIT_STATUS_DECAYED);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class ForwardPingPongRequestResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent>{

        private:

            const std::unique_ptr<ForwardPingPongLeafRequestResolutor> leaf_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongBlkrRequestResolutor> blkr_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongRstrRequestResolutor> rstr_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongMonoRequestResolutor> mono_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongPairRequestResolutor> pair_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongUACMRequestResolutor> uacm_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongPACMRequestResolutor> pacm_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongCritRequestResolutor> crit_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongImmuRequestResolutor> immu_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongPolyRequestResolutor> poly_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongExtnSrcRequestResolutor> extnsrc_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongExtnSrxRequestResolutor> extnsrx_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongExtnDstRequestResolutor> extndst_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongExtnDsxRequestResolutor> extndsx_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongMsgrFwdRequestResolutor> msgrfwd_pingpong_resolutor;
            const std::unique_ptr<ForwardPingPongMsgrBwdRequestResolutor> msgrbwd_pingpong_resolutor;
            const size_t kvfeed_vectorization_sz;

        public:

            ForwardPingPongRequestResolutor(std::unique_ptr<ForwardPingPongLeafRequestResolutor> leaf_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongBlkrRequestResolutor> blkr_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongRstrRequestResolutor> rstr_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongMonoRequestResolutor> mono_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongPairRequestResolutor> pair_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongUACMRequestResolutor> uacm_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongPACMRequestResolutor> pacm_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongCritRequestResolutor> crit_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongImmuRequestResolutor> immu_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongPolyRequestResolutor> poly_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongExtnSrcRequestResolutor> extnsrc_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongExtnSrxRequestResolutor> extnsrx_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongExtnDstRequestResolutor> extndst_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongExtnDsxRequestResolutor> extndsx_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongMsgrFwdRequestResolutor> msgrfwd_pingpong_resolutor,
                                            std::unique_ptr<ForwardPingPongMsgrBwdRequestResolutor> msgrbwd_pingpong_resolutor,
                                            size_t kvfeed_vectorization_sz) noexcept: leaf_pingpong_resolutor(std::move(leaf_pingpong_resolutor)),
                                                                                      blkr_pingpong_resolutor(std::move(blkr_pingpong_resolutor)),
                                                                                      rstr_pingpong_resolutor(std::move(rstr_pingpong_resolutor)),
                                                                                      mono_pingpong_resolutor(std::move(mono_pingpong_resolutor)),
                                                                                      pair_pingpong_resolutor(std::move(pair_pingpong_resolutor)),
                                                                                      uacm_pingpong_resolutor(std::move(uacm_pingpong_resolutor)),
                                                                                      pacm_pingpong_resolutor(std::move(pacm_pingpong_resolutor)),
                                                                                      crit_pingpong_resolutor(std::move(crit_pingpong_resolutor)),
                                                                                      immu_pingpong_resolutor(std::move(immu_pingpong_resolutor)),
                                                                                      poly_pingpong_resolutor(std::move(poly_pingpong_resolutor)),
                                                                                      extnsrc_pingpong_resolutor(std::move(extnsrc_pingpong_resolutor)),
                                                                                      extnsrx_pingpong_resolutor(std::move(extnsrx_pingpong_resolutor)),
                                                                                      extndst_pingpong_resolutor(std::move(extndst_pingpong_resolutor)),
                                                                                      extndsx_pingpong_resolutor(std::move(extndsx_pingpong_resolutor)),
                                                                                      msgrfwd_pingpong_resolutor(std::move(msgrfwd_pingpong_resolutor)),
                                                                                      msgrbwd_pingpong_resolutor(std::move(msgrbwd_pingpong_resolutor)),
                                                                                      kvfeed_vectorization_sz(kvfeed_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardPingPongRequestEvent& event) const noexcept -> exception_t{

                std::expected<tile_kind_t, exception_t> tile_kind = dg::network_tile_member_getsetter::get_tile_kind(event.requestee);

                if (!tile_kind.has_value()){
                    return tile_kind.error();
                }

                switch (tile_kind.value()){
                    case TILE_KIND_LEAF: [[fallthrough]]
                    case TILE_KIND_BLKR: [[fallthrough]]
                    case TILE_KIND_RSTR: [[fallthrough]]
                    case TILE_KIND_MONO: [[fallthrough]]
                    case TILE_KIND_PAIR: [[fallthrough]]
                    case TILE_KIND_UACM: [[fallthrough]]
                    case TILE_KIND_PACM: [[fallthrough]]
                    case TILE_KIND_CRIT: [[fallthrough]]
                    case TILE_KIND_IMMU: [[fallthrough]]
                    case TILE_KIND_POLY: [[fallthrough]]
                    case TILE_KIND_EXTNSRC: [[fallthrough]]
                    case TILE_KIND_EXTNSRX: [[fallthrough]]
                    case TILE_KIND_EXTNDST: [[fallthrough]]
                    case TILE_KIND_EXTNDSX: [[fallthrough]]
                    case TILE_KIND_MSGRFWD: [[fallthrough]]
                    case TILE_KIND_MSGRBWD:
                    {
                        return dg::network_exception::SUCCESS;
                    }
                    default:
                    {
                        return dg::network_exception::BAD_TILE_ACCESS;
                    }
                }
            }

            void push(ForwardPingPongRequestEvent * event_arr, size_t sz) noexcept{

                auto internal_resolutor                 = InternalResolutor{};

                internal_resolutor.leaf_resolutor       = this->leaf_resolutor.get();
                internal_resolutor.blkr_resolutor       = this->blkr_resolutor.get();
                internal_resolutor.rstr_resolutor       = this->rstr_resolutor.get();
                internal_resolutor.mono_resolutor       = this->mono_resolutor.get();
                internal_resolutor.pair_resolutor       = this->pair_resolutor.get();
                internal_resolutor.uacm_resolutor       = this->uacm_resolutor.get();
                internal_resolutor.pacm_resolutor       = this->pacm_resolutor.get();
                internal_resolutor.crit_resolutor       = this->crit_resolutor.get();
                internal_resolutor.immu_resolutor       = this->immu_resolutor.get();
                internal_resolutor.poly_resolutor       = this->poly_resolutor.get();
                internal_resolutor.extnsrc_resolutor    = this->extnsrc_resolutor.get();
                internal_resolutor.extnsrx_resolutor    = this->extnsrx_resolutor.get();
                internal_resolutor.extndst_resolutor    = this->extndst_resolutor.get();
                internal_resolutor.extndsx_resolutor    = this->extndsx_resolutor.get();
                internal_resolutor.msgrfwd_resolutor    = this->msgrfwd_resolutor.get();
                internal_resolutor.msgrbwd_resolutor    = this->msgrbwd_resolutor.get();

                size_t trimmed_kvfeed_vectorization_sz  = std::min(this->kvfeed_vectorization_sz, sz);
                size_t kvfeed_allocation_cost           = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&internal_resolutor, trimmed_kvfeed_vectorization_sz);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> kvfeed_mem(kvfeed_allocation_cost);
                auto feeder                             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_kv_open_preallocated_raiihandle(&internal_resolutor, trimmed_kvfeed_vectorization_sz, kvfeed_mem.get()));

                for (size_t i = 0u; i < sz; ++i){
                    if constexpr(DEBUG_MODE_FLAG){
                        if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                            std::abort();
                        }
                    }

                    tile_kind_t tile_kind = dg::network_tile_member_getsetter::get_tile_kind_nothrow(event_arr[i].requestee);
                    dg::network_producer_consumer::delvrsrv_kv_deliver(feeder.get(), tile_kind, event_arr[i]);
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<tile_kind_t, ForwardPingPongRequestEvent>{

                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * leaf_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * blkr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * rstr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * mono_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * pair_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * uacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * pacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * crit_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * immu_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * poly_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * extnsrc_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * extnsrx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * extndst_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * extndsx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * msgrfwd_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardPingPongRequestEvent> * msgrbwd_resolutor;

                void push(const tile_kind_t& tile_kind, std::move_iterator<ForwardPingPongRequestEvent *> event_arr, size_t sz){

                    switch (tile_kind){
                        case TILE_KIND_LEAF:
                        {
                            this->leaf_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_BLKR:
                        {
                            this->blkr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_RSTR:
                        {
                            this->rstr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MONO:
                        {
                            this->mono_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PAIR:
                        {
                            this->pair_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_UACM:
                        {
                            this->uacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PACM:
                        {
                            this->pacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_CRIT:
                        {
                            this->crit_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_IMMU:
                        {
                            this->immu_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_POLY:
                        {
                            this->poly_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRC:
                        {
                            this->extnsrc_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRX:
                        {
                            this->extnsrx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDST:
                        {
                            this->extndst_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDSX:
                        {
                            this->extndsx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRFWD:
                        {
                            this->msgrfwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRBWD:
                        {
                            this->msgrbwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        default:
                        {
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                            } else{
                                std::unreachable();
                            }
                        }
                    }
                }
            };
    };

    //

    class CronSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<VirtualSignalAggregationEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            static inline constexpr size_t TICKING_CLOCK_RESOLUTION = 1024u; 

            CronSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                size_t delivery_capacity,
                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                   delivery_capacity(delivery_capacity),
                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const VirtualSignalAggregationEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_cron_ptr_access(event.smph_addr);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(VirtualSignalAggregationEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = CRON_TILE_MAX_VIRTUAL_SIGNAL_AGGREGATION_SIZE;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_cron_rcu_addr_nothrow(event_arr[i].smph_addr);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, VirtualSignalAggregationEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void dump_sigagg(uma_ptr_t smph_addr) noexcept{

                    size_t memevent_arr_cap = CRON_TILE_MAX_VIRTUAL_SIGNAL_AGGREGATION_SIZE;
                    size_t memevent_arr_sz  = {};
                    dg::network_stack_allocation::NoExceptRawIfPossibleAllocation<virtual_memory_event_t[]> memevent_arr(memevent_arr_cap);
                    dg::network_tile_member_getsetter::controller_cron_get_sigagg(smph_addr, memevent_arr.get(), memevent_arr_sz);

                    for (size_t i = 0u; i < memevent_arr_sz; ++i){
                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, memevent_arr[i]);
                    }

                    dg::network_tile_member_getsetter::controller_cron_clear_sigagg(smph_addr);
                }

                void push(const uma_ptr_t& rcu_addr, std::move_iterator<VirtualSignalAggregationEvent *> event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    VirtualSignalAggregationEvent * base_event_arr = event_arr.base();
                    auto clock = dg::ticking_clock<std::chrono::utc_clock>(TICKING_CLOCK_RESOLUTION);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                       = base_event_arr[i].smph_addr;
                        operatable_id_t expected_ops_id     = base_event_arr[i].operatable_id;
                        init_status_t init_status           = dg::network_tile_member_getsetter::get_cron_init_status_nothrow(ptr);
                        operatable_id_t cur_operatable_id   = dg::network_tile_member_getsetter::get_cron_operatable_memevent_id_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (cur_operatable_id != expected_ops_id){
                                    break;
                                }

                                std::chrono::time_point<std::chrono::utc_clock> cron_expiry_time = dg::network_tile_member_getsetter::get_cron_expiry_time_nothrow(ptr);
                                
                                //we'll attempt to devirtualize the content of the VirtualSignalAggreggationEvent

                                switch (base_event_arr[i].aggregation_kind){
                                    case dg::network_memcommit_model::AGGREGATION_KIND_SELF_DECAY:
                                    {
                                        if (clock.get() >= cron_expiry_time){
                                            this->dump_sigagg(ptr);
                                            //we'll set the decay responsibility of this decay event -> false
                                            dg::network_tile_member_getsetter::set_cron_decay_responsibility(ptr, true);
                                        } else{
                                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, dg::network_memcommit_model::virtualize_event(base_event_arr[i]));
                                        }

                                        break;
                                    }
                                    case dg::network_memcommit_model::AGGREGATION_KIND_VIRTUAL_EVENT:
                                    {
                                        if (clock.get() >= cron_expiry_time){
                                            //we are late fellas
                                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, dg::network_memcommit_model::devirtualize_aggregation_virtual_event(base_event_arr[i].content));
                                        } else{
                                            size_t cron_sigagg_cap  = dg::network_tile_member_getsetter::get_cron_sigagg_capacity_nothrow(ptr);
                                            size_t cron_sigagg_sz   = dg::network_tile_member_getsetter::get_cron_sigagg_size_nothrow(ptr);

                                            if (cron_sigagg_sz == cron_sigagg_cap){
                                                this->dump_sigagg(ptr);
                                            }

                                            dg::network_tile_member_getsetter::controller_cron_push_sigagg(ptr, dg::network_memcommit_model::devirtualize_aggregation_virtual_event(base_event_arr[i].content));

                                            bool decayability = dg::network_tile_member_getsetter::get_cron_decay_responsibility(ptr);
                                            //decayability == false means that we are sequenced before a decay signal, which guarantees to empty the sequence which is at worst contains our signal
                                            //decay is our notify bullet, in the sense that it starts at the first signal, and decayed into the void after the cron job expired, which guarantees to empty the container, decayability == false notes that we are in the lifetime of the decay signal
                                            //our decay signal can be actually reinitiated, for some reason, yet if we decay it, we guarantee that we are still in the comfort zone of dumping our signals

                                            if (decayability){
                                                auto sigagg                 = dg::network_memcommit_model::virtualize_sigagg(dg::network_memcommit_model::make_sigagg_decay_event(ptr, expected_ops_id)); 
                                                auto decay_signal_event     = dg::network_memcommit_model::virtualize_event(sigagg);

                                                dg::network_tile_member_getsetter::set_cron_decay_responsibility(ptr, false);
                                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, decay_signal_event);
                                            }
                                        }

                                        break;
                                    }
                                    default:
                                    {
                                        if constexpr(DEBUG_MODE_FLAG){
                                            dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                            std::abort();
                                        } else{
                                            std::unreachable();
                                        }
                                    }
                                }

                                break;
                            }
                            default:
                            [
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            ]
                        }
                    }
                }
            };
    };

    class SmphSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<VirtualSignalAggregationEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            SignalAggregationSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> requets_box,
                                             size_t delivery_capacity,
                                             size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                delivery_capacity(delivery_capacity),
                                                                                vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const VirtualSignalAggregationEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_smph_ptr_access(event_arr[i].smph_addr);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            } 

            void push(VirtualSignalAggregationEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = MAX_VIRTUAL_SIGNAL_AGGREGATION_PER_SMPH_TILE;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_smph_rcu_addr_nothrow(event_arr[i].smph_addr);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, VirtualSignalAggregationEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void dump_sigagg(uma_ptr_t smph_addr) noexcept{

                    size_t memevent_arr_cap = SMPH_TILE_MAX_VIRTUAL_SIGNAL_AGGREGATION_SIZE;
                    size_t memevent_arr_sz  = {};
                    dg::network_stack_allocation::NoExceptRawIfPossibleAllocation<virtual_memory_event_t[]> memevent_arr(memevent_arr_cap);
                    dg::network_tile_member_getsetter::controller_smph_get_sigagg(smph_addr, memevent_arr.get(), memevent_arr_sz);

                    for (size_t i = 0u; i < memevent_arr_sz; ++i){
                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, memevent_arr[i]);
                    }

                    dg::network_tile_member_getsetter::controller_smph_clear_sigagg(smph_addr);
                }

                void push(const uma_ptr_t& rcu_addr, std::move_iterator<VirtualSignalAggregationEvent *> event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    VirtualSignalAggregationEvent * base_event_arr = event_arr.base();

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                       = base_event_arr[i].smph_addr;
                        operatable_id_t expected_ops_id     = base_event_arr[i].operatable_id;
                        init_status_t init_status           = dg::network_tile_member_getsetter::get_smph_init_status_nothrow(ptr);
                        operatable_id_t cur_operatable_id   = dg::network_tile_member_getsetter::get_smph_operatable_memevent_id_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (cur_operatable_id != expected_ops_id){
                                    break;
                                }

                                size_t smph_sigagg_cap  = dg::network_tile_member_getsetter::get_smph_sigagg_capacity_nothrow(ptr);
                                size_t smph_sigagg_sz   = dg::network_tile_member_getsetter::get_smph_sigagg_size_nothrow(ptr);

                                if (smph_sigagg_sz == smph_sigagg_cap){
                                    this->dump_sigagg(ptr);
                                }

                                switch (base_event_arr[i].aggregation_kind){
                                    case dg::network_memcommit_factory::AGGREGATION_KIND_VIRTUAL_EVENT:
                                    {
                                        dg::network_tile_member_getsetter::controller_smph_push_sigagg(ptr, dg::network_memcommit_model::devirtualize_aggregation_virtual_event(base_event_arr[i]));
                                        break;
                                    }
                                    default:
                                    {
                                        if constexpr(DEBUG_MODE_FLAG){
                                            dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                            std::abort();
                                        } else{
                                            std::unreachable();
                                        }
                                    }
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    } 
                }
            };
    };

    class FsmpSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<VirtualSignalAggregationEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const size_t delivery_capacity;
            const size_t vectorization_sz;

        public:

            static inline constexpr size_t TICKING_CLOCK_RESOLUTION = 1024u; //make this stdx::

            FsmpSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                size_t delivery_capacity,
                                size_t vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                   delivery_capacity(delivery_capacity),
                                                                   vectorization_sz(vectorization_sz){}

            auto is_met_dispatch_requirements(const VirtualSignalAggregationEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_fsmp_ptr_access(event.smph_addr);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(VirtualSignalAggregationEvent * event_arr, size_t sz) noexcept{

                const size_t EVENT_SCALE_FACTOR     = MAX_VIRTUAL_SIGNAL_AGGREGATION_PER_FSMP_TILE;
                size_t max_possible_event_sz        = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_delivery_capacity    = std::min(this->delivery_capacity, max_possible_event_sz);
                size_t dh_allocation_cost           = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> dh_mem(dh_allocation_cost);
                auto delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_delivery_capacity, dh_mem.get()));

                {
                    InternalResolutor internal_resolutor        = {};
                    internal_resolutor.request_delivery_handle  = delivery_handle.get();

                    size_t trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr  = dg::network_tile_member_getsetter::get_fsmp_rcu_addr_nothrow(event_arr[i].smph_addr);
                        uma_ptr_t lck_addr  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, event_arr[i]);
                    }
                }
            }

        private:

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, VirtualSignalAggregationEvent>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;

                void dump_sigagg(uma_ptr_t smph_addr) noexcept{

                    size_t memevent_arr_cap = FSMP_TILE_MAX_VIRTUAL_SIGNAL_AGGREGATION_SIZE;
                    size_t memevent_arr_sz  = {};
                    dg::network_stack_allocation::NoExceptRawIfPossibleAllocation<virtual_memory_event_t[]> memevent_arr(memevent_arr_cap);
                    dg::network_tile_member_getsetter::controller_fsmp_get_sigagg(smph_addr, memevent_arr.get(), memevent_arr_sz);

                    for (size_t i = 0u; i < memevent_arr_sz; ++i){
                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, memevent_arr[i]);
                    }

                    dg::network_tile_member_getsetter::controller_fsmp_clear_sigagg(smph_addr);
                }

                void push(const uma_ptr_t& rcu_addr, std::move_iterator<VirtualSignalAggregationEvent *> event_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    VirtualSignalAggregationEvent * base_event_arr = event_arr.base();
                    auto clock = dg::ticking_clock<std::chrono::utc_clock>(TICKING_CLOCK_RESOLUTION);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t ptr                       = base_event_arr[i].smph_addr;
                        operatable_id_t expected_ops_id     = base_event_arr[i].operatable_id;
                        init_status_t init_status           = dg::network_tile_member_getsetter::get_fsmp_init_status_nothrow(ptr);
                        operatable_id_t cur_operatable_id   = dg::network_tile_member_getsetter::get_fsmp_operatable_memevent_id_nothrow(ptr);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (cur_operatable_id != expected_ops_id){
                                    break;
                                }

                                std::chrono::time_point<std::chrono::utc_clock> last_signal_time    = dg::network_tile_member_getsetter::get_fsmp_last_updated_nothrow(ptr);
                                std::chrono::nanoseconds successive_expiry_interval                 = dg::network_tile_member_getsetter::get_fsmp_release_latency_nothrow(ptr);
                                std::chrono::time_point<std::chrono::utc_clock> expiry_time         = last_signal_time + successive_expiry_interval;

                                switch (base_event_arr[i].aggregation_kind){
                                    case dg::network_memcommit_model::AGGREGATION_KIND_SELF_DECAY:
                                    {
                                        if (clock.get() >= expiry_time){
                                            this->dump_sigagg(ptr);
                                            dg::network_tile_member_getsetter::set_fsmp_decay_responsibility(ptr, true);
                                        } else{
                                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, dg::network_memcommit_model::virtualize_event(base_event_arr[i]));
                                        }

                                        break;
                                    }
                                    case dg::network_memcommit_model::AGGREGATION_KIND_VIRTUAL_EVENT:
                                    {
                                        size_t cron_sigagg_cap  = dg::network_tile_member_getsetter::get_fsmp_sigagg_capacity_nothrow(ptr);
                                        size_t cron_sigagg_sz   = dg::network_tile_member_getsetter::get_fsmp_sigagg_size_nothrow(ptr);

                                        if (cron_sigagg_sz == cron_sigagg_cap){
                                            this->dump_sigagg(ptr);
                                        }

                                        dg::network_tile_member_getsetter::controller_fsmp_push_sigagg(ptr, dg::network_memcommit_model::devirtualize_aggregation_virtual_event(base_event_arr[i].content));

                                        bool decayability = dg::network_tile_member_getsetter::get_fsmp_decay_responsibility(ptr);
                                        //decayability == false means that we are sequenced before a decay signal, which guarantees to empty the sequence which is at worst contains our signal
                                        //decay is our notify bullet, in the sense that it starts at the first signal, and decayed into the void after the cron job expired, which guarantees to empty the container, decayability == false notes that we are in the lifetime of the decay signal
                                        //our decay signal can be actually reinitiated, for some reason, yet if we decay it, we guarantee that we are still in the comfort zone of dumping our signals

                                        if (decayability){
                                            auto sigagg                 = dg::network_memcommit_model::virtualize_sigagg(dg::network_memcommit_model::make_sigagg_decay_event(ptr, expected_ops_id)); 
                                            auto decay_signal_event     = dg::network_memcommit_model::virtualize_event(sigagg);

                                            dg::network_tile_member_getsetter::set_fsmp_decay_responsibility(ptr, false);
                                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, decay_signal_event);
                                        }

                                        break;
                                    }
                                    default:
                                    {
                                        if constexpr(DEBUG_MODE_FLAG){
                                            dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                            std::abort();
                                        } else{
                                            std::unreachable();
                                        }
                                    }
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
    };

    class AggregationSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<VirtualSignalAggregationEvent>{

        private:

            const std::unique_ptr<CronSignalResolutor> cron_resolutor;
            const size_t cron_dispatch_sz;
            const std::unique_ptr<SmphSignalResolutor> smph_resolutor;
            const size_t smph_dispatch_sz;
            const std::unique_ptr<FsmpSignalResolutor> fsmp_resolutor;
            const size_t fsmp_dispatch_sz;

        public:

            AggregationSignalResolutor(std::unique_ptr<CronSignalResolutor> cron_resolutor,
                                       size_t cron_dispatch_sz,
                                       std::unique_ptr<SmphSignalResolutor> smph_resolutor,
                                       size_t smph_dispatch_sz,
                                       std::unique_ptr<FsmpSignalResolutor> fsmp_resolutor,
                                       size_t fsmp_dispatch_sz) noexcept: cron_resolutor(std::move(cron_resolutor)),
                                                                          cron_dispatch_sz(cron_dispatch_sz),
                                                                          smph_resolutor(std::move(smph_resolutor)),
                                                                          smph_dispatch_sz(smph_dispatch_sz),
                                                                          fsmp_resolutor(fsmp_resolutor),
                                                                          fsmp_dispatch_sz(fsmp_dispatch_sz){}

            auto is_met_dispatch_requirements(const VirtualSignalAggregationEvent& event) const noexcept -> exception_t{

                std::expected<tile_kind_t, exception_t> tile_kind = dg::network_tile_member_getsetter::get_tile_kind(event.smph_addr);

                if (!tile_kind.has_value()){
                    return tile_kind.error();
                }

                switch (tile_kind.value()){
                    case TILE_KIND_CRON: [[fallthrough]]
                    case TILE_KIND_SMPH: [[fallthrough]]
                    case TILE_KIND_FSMP:
                    {
                        return dg::network_exception::SUCCESS;
                    }
                    default:
                    {
                        return dg::network_exception::BAD_TILE_ACCESS;
                    }
                }
            }

            void push(VirtualSignalAggregationEvent * event_arr, size_t sz) noexcept{

                size_t trimmed_cron_dispatch_sz     = std::min(this->cron_dispatch_sz, sz);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> cron_dh_mem(dg::network_producer_consumer::delvrsrv_allocation_cost(this->cron_resolutor.get(), trimmed_cron_dispatch_sz));

                size_t trimmed_smph_dispatch_sz     = std::min(this->smph_dispatch_sz, sz);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> smph_dh_mem(dg::network_producer_consumer::delvrsrv_allocation_cost(this->smph_resolutor.get(), trimmed_smph_dispatch_sz));

                size_t trimmed_fsmp_dispatch_sz     = std::min(this->fsmp_dispatch_sz, sz);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> fsmp_dh_mem(dg::network_producer_consumer::delvrsrv_allocation_cost(this->fsmp_resolutor.get(), trimmed_fsmp_dispatch_sz));
                
                auto cron_delivery_handle   = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->cron_resolutor.get(), trimmed_cron_dispatch_sz, cron_dh_mem.get()));
                auto smph_delivery_handle   = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->smph_resolutor.get(), trimmed_smph_dispatch_sz, smph_dh_mem.get()));
                auto fsmp_delivery_handle   = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->fsmp_resolutor.get(), trimmed_fsmp_dispatch_sz, fsmp_dh_mem.get()));
                
                for (size_t i = 0u; i < sz; ++i){
                    if constexpr(DEBUG_MODE_FLAG){
                        if (auto err = is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                            std::abort();
                        }
                    }

                    tile_kind_t tile_kind = dg::network_tile_member_getsetter::get_tile_kind_nothrow(event_arr[i].smph_addr);

                    switch (tile_kind){
                        case TILE_KIND_CRON:
                        {
                            dg::network_producer_consumer::delvrsrv_deliver(cron_delivery_handle.get(), event_arr[i]);
                            break;
                        }
                        case TILE_KIND_SMPH:
                        {   
                            dg::network_producer_consumer::delvrsrv_deliver(smph_delivery_handle.get(), event_arr[i]);
                            break;
                        }
                        case TILE_KIND_FSMP:
                        {
                            dg::network_producer_consumer::delvrsrv_deliver(fsmp_delivery_handle.get(), event_arr[i]);
                            break;
                        }
                        default:
                        {
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        } 
                    }
                }
            }
    };

    //
    
    constexpr auto convert_grad_status_to_cuda_write_option(grad_status_t grad_status) noexcept -> cuda_write_option_t{

        if (grad_status == TILE_GRAD_STATUS_HAS_VALUE){
            return CUDA_TILEOPS_OPERATION_ACCUM;
        } else if (grad_status == TILE_GRAD_STATUS_EMPTY){
            return CUDA_TILEOPS_OPERATION_ASSIGN;
        } else{
            std::unreachable();
        }
    }

    constexpr auto convert_grad_status_to_host_write_option(grad_status_t grad_status) noexcept -> host_write_option_t{

        if (grad_status == TILE_GRAD_STATUS_HAS_VALUE){
            return HOST_TILEOPS_OPERATION_ACCUM;
        } else if (grad_status == TILE_GRAD_STATUS_EMPTY){
            return HOST_TILEOPS_OPERATION_ASSIGN;
        } else{
            std::unreachable();
        }
    }

    //

    //clear
    class ForwardDoLeafSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_leaf_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    //clear
    class ForwardDoBlkrSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoBlkrSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                         std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                         std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                         size_t request_delivery_capacity,
                                         size_t radxfetch_vectorization_sz,
                                         size_t region_vectorization_sz,
                                         size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                    cuda_async_device(std::move(cuda_async_device)),
                                                                                    host_async_device(std::move(host_async_device)),
                                                                                    request_delivery_capacity(request_delivery_capacity),
                                                                                    radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                    region_vectorization_sz(region_vectorization_sz),
                                                                                    forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_blkr_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_blkr_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = DispatchRadixArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        //this is the magic - the minimum of the two regions must guarantee
                        //(1): the new derived region has equivalent lockability
                        //(2): the new derived region must be a representation such that all of the representees must share the same uma_memregion - this combined with device_id_t guarantees such for vma_memregion   
                        //this works for n number of aligned region sizes - we want to share the region-benefits by using min(region_size_arr) followed by getting a region representation - as long as the regionizable is aligned <= min(region_size_arr) 

                        const size_t lck_region_sz          = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size())); 
                        uma_ptr_t dst_rcu_addr              = dg::network_tile_member_getsetter::get_blkr_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key                  = ResolutorKeyArgument{};
                        resolutor_key.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key.dst_vd_id             = dispatch_radix_arg_arr[i]->dst_vd_id;
                        resolutor_key.src_vd_id             = dispatch_radix_arg_arr[i]->src_vd_id;
                        resolutor_key.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val                  = ResolutorValueArgument{};
                        resolutor_val.dst                   = event_arr[i].dst;
                        resolutor_val.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key, resolutor_val);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t src_vd_id;
                device_id_t dst_vd_id;
                platform_t dispatch_platform;
            };

            struct DispatchRadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, DispatchRadixFetcherArgument>{

                void push(uma_ptr_t lck_addr, DispatchRadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(lck_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_blkr_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_blkr_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_blkr_forward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_blkr_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_blkr_forward_dispatch(dispatch_control));
                                    dispatch_radix.src_vd_id            = dispatch_info.src_vd_id;
                                    dispatch_radix.dst_vd_id            = dispatch_info.dst_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t dst;
                cuda_ptr_t src;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_vec_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_vec(cuda_ptr_vec_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_vec[i * 2]     = data_arr[i].dst;
                        cuda_ptr_vec[i * 2 + 1] = data_arr[i].src;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::forward_mono(e.dst, e.src, e.dispatch_control)); //kernel launches might be expensive
                        };

                        auto async_task         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order)); 
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(async_task)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_vec.get(), std::next(cuda_ptr_vec.get(), cuda_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                host_ptr_t src;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_vec_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_vec(host_ptr_vec_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_vec[i * 2]     = data_arr[i].dst;
                        host_ptr_vec[i * 2 + 1] = data_arr[i].src;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_mono(e.dst, e.src, e.dispatch_control));
                        };

                        auto async_task         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(async_task)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_vec.get(), std::next(host_ptr_vec.get(), host_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: optimizables word size memcmp + has_unique_object_representations_v
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                  = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 2u>{}));
                    auto dst_vmamap_reacquirer              = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_vmamap_reacquirer              = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                  = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer         = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_resolutor                     = InternalCudaResolutor{};
                    cuda_resolutor.async_device             = this->cuda_async_device;
                    cuda_resolutor.synchronizer             = &cuda_synchronizer;
                    cuda_resolutor.restrict_synchronizer    = &cuda_restrict_synchronizer;

                    auto host_synchronizer                  = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer         = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_resolutor                     = InternalHostResolutor{};
                    host_resolutor.async_device             = this->host_async_device;
                    host_resolutor.synchronizer             = &host_synchronizer;
                    host_resolutor.restrict_synchronizer    = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz    = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost              = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle               = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz    = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost              = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle               = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]        = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                       = dg::network_tile_member_getsetter::get_blkr_descendant_nothrow(dst);
                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_blkr_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_fwd_operatable_id   = dg::network_tile_member_getsetter::get_blkr_operatable_forward_id_nothrow(dst);
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_blkr_init_status_nothrow(dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_blkr_logit_addr_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_blkr_forward_dispatch_control_nothrow(dst);
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_blkr_observer_array_size_nothrow(dst);

                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_blkr_observer_array_nothrow(dst, dst_observer_arr.get());

                        std::expected<operatable_id_t, exception_t> src_fwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(src);
                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src);

                        if (!src_fwd_operatable_id.has_value() || !src_init_status.has_value() || !src_logit_umaptr.has_value()){
                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_DECAYED && dst_init_status != TILE_INIT_STATUS_ADOPTED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_fwd_operatable_id != src_fwd_operatable_id.value()){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_blkr_forward_dispatch(dispatch_control));

                        if (dispatch_info.dst_vd_id != key.dst_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_vd_id != key.src_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{dst_logit_umaptr, dispatch_info.dst_vd_id}, 
                                                                                                           {src_logit_umaptr.value(), dispatch_info.src_vd_id}});

                        vma_ptr_t dst_map_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{}); //TODOs: these should be std::expected<> - we'll reconsider whether this is a precond or an exception 
                        vma_ptr_t src_map_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(dst_vmamap_reacquirer, dst_map_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_vmamap_reacquirer, src_map_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_arg               = CudaResolutorArgument{};
                            cuda_arg.dst                = dg::network_vmamap::get_cuda_ptr(dst_vmamap_reacquirer);
                            cuda_arg.src                = dg::network_vmamap::get_cuda_ptr(src_vmamap_reacquirer);
                            cuda_arg.dispatch_control   = dispatch_info.tileops_cuda_dispatch_control; 

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_arg.src, cuda_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_arg               = HostResolutorArgument{};
                            host_arg.dst                = dg::network_vmamap::get_host_ptr(dst_vmamap_reacquirer);
                            host_arg.src                = dg::network_vmamap::get_host_ptr(src_vmamap_reacquirer);
                            host_arg.dispatch_control   = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_arg.src, host_arg); 
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(),
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }

                        }

                        dg::network_tile_member_getsetter::set_blkr_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);
                    }
                }
            };
    };

    class ForwardDoRstrSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_rstr_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    //clear
    class ForwardDoMonoSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoMonoSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                         std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                         std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                         size_t request_delivery_capacity,
                                         size_t radxfetch_vectorization_sz,
                                         size_t region_vectorization_sz,
                                         size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                    cuda_async_device(std::move(cuda_async_device)),
                                                                                    host_async_device(std::move(host_async_device)),
                                                                                    request_delivery_capacity(request_delivery_capacity),
                                                                                    radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                    region_vectorization_sz(region_vectorization_sz),
                                                                                    forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_mono_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity); 
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_mono_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_mono_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.dst_vd_id             = dispatch_radix_arg_arr[i]->dst_vd_id;
                        resolutor_key_arg.src_vd_id             = dispatch_radix_arg_arr[i]->src_vd_id;
                        resolotor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t src_vd_id;
                device_id_t dst_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_mono_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_mono_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_mono_forward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_mono_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_mono_forward_dispatch(dispatch_control));
                                    dispatch_radix.src_vd_id            = dispatch_info.src_vd_id;
                                    dispatch_radix.dst_vd_id            = dispatch_info.dst_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t dst;
                cuda_ptr_t src;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_vec_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_vec(cuda_ptr_vec_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_vec[i * 2]     = data_arr[i].dst;
                        cuda_ptr_vec[i * 2 + 1] = data_arr[i].src;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::forward_mono(e.dst, e.src, e.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_vec.get(), std::next(cuda_ptr_vec.get(), cuda_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                host_ptr_t src;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_vec_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_vec(host_ptr_vec_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_vec[i * 2]     = data_arr[i].dst;
                        host_ptr_vec[i * 2 + 1] = data_arr[i].src;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_mono(e.dst, e.src, e.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_vec.get(), std::next(host_ptr_vec.get(), host_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: word_size aligned cmp + has_unique_object_representations_v 
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_emmory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 2u>{}));
                    auto dst_vmamap_reacquirer                      = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_vmamap_reacquirer                      = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    
                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto internal_cuda_resolutor                    = InternalCudaResolutor{};
                    internal_cuda_resolutor.async_device            = this->cuda_async_device;
                    internal_cuda_resolutor.synchronizer            = &cuda_synchronizer;
                    internal_cuda_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto internal_host_resolutor                    = InternalHostResolutor{};
                    internal_host_resolutor.async_device            = this->host_async_device;
                    internal_host_resolutor.synchronizer            = &host_synchronizer;
                    internal_host_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    size_t cdh_trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_cuda_resolutor, cdh_trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_cuda_resolutor, cdh_trimmed_vectorization_sz, cdh_mem.get()));

                    size_t hdh_trimmed_vectorization_sz             = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_host_resolutor, hdh_trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_host_resolutor, hdh_trimmed_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]        = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                       = dg::network_tile_member_getsetter::get_mono_descendant_nothrow(dst);
                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_mono_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_fwd_operatable_id   = dg::network_tile_member_getsetter::get_mono_operatable_forward_id_nothrow(dst);
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_mono_init_status_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_mono_forward_dispatch_control_nothrow(dst); 
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_mono_logit_addr_nothrow(dst); 
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_mono_observer_array_size_nothrow(dst);

                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_mono_observer_array_nothrow(dst, dst_observer_arr.get());

                        std::expected<operatable_id_t, exception_t> src_fwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(src);
                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src);

                        if (!src_fwd_operatable_id.has_value() || !src_init_status.has_value() || !src_logit_umaptr.has_value()){
                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_ADOPTED && dst_init_status != TILE_INIT_STATUS_DECAYED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_fwd_operatable_id != src_fwd_operatable_id.value()){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_mono_forward_dispatch(dispatch_control));

                        if (dispatch_info.dst_vd_id != key.dst_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_vd_id != key.src_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{dst_logit_umaptr, dispatch_info.dst_vd_id}, 
                                                                                                           {src_logit_umaptr.value(), dispatch_info.src_vd_id}});

                        auto dst_map_vmaptr = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        auto src_map_vmaptr = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(dst_vmamap_reacquirer, dst_map_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_vmamap_reacquirer, src_map_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.dst              = dg::network_vmamap::get_cuda_ptr(dst_vmamap_reacquirer);
                            cuda_resolutor_arg.src              = dg::network_vmamap::get_cuda_ptr(src_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg.src, cuda_resolutor_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.dst              = dg::network_vmamap::get_host_ptr(dst_vmamap_reacquirer);
                            host_resolutor_arg.src              = dg::network_vmamap::get_host_ptr(src_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg.src, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(),
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }
                        }

                        dg::network_tile_member_getsetter::set_mono_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);
                    }
                }
            };
    };

    //clear
    class ForwardDoPairSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoPairSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                         std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                         std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                         size_t request_delivery_capacity,
                                         size_t radxfetch_vectorization_sz,
                                         size_t region_vectorization_sz,
                                         size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                    cuda_async_device(std::move(cuda_async_device)),
                                                                                    host_async_device(std::move(host_async_device)),
                                                                                    request_delivery_capacity(request_delivery_capacity),
                                                                                    radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                    region_vectorization_sz(region_vectorization_sz),
                                                                                    forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pair_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz); 
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz); 
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_pair_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz); 
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost); 
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> lhs_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->lhs); //we are doing polymorphic access - it's better to safeguards the assumption here 
                        std::expected<uma_ptr_t, exception_t> rhs_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->rhs);

                        if (!lhs_rcu_addr.has_value() || !rhs_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_pair_rcu_addr_nothrow(event_arr[i].dst); //assume that descendant_arr[i].has_value() => safe pair access

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.lhs_region_rcu_addr   = dg::memult::region(lhs_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.rhs_region_rcu_addr   = dg::memult::region(rhs_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.dst_vd_id             = dispatch_radix_arg_arr[i]->dst_vd_id;
                        resolutor_key_arg.lhs_vd_id             = dispatch_radix_arg_arr[i]->lhs_vd_id;
                        resolutor_key_arg.rhs_vd_id             = dispatch_radix_arg_arr[i]->rhs_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.lhs                   = dispatch_radix_arg_arr[i]->lhs;
                        resolutor_val_arg.rhs                   = dispatch_radix_arg_arr[i]->rhs;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t lhs;
                uma_ptr_t rhs;
                device_id_t dst_vd_id;
                device_id_t lhs_vd_id;
                device_id_t rhs_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_pair_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_pair_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != data_arr[i].expected_ops_id){
                                    break;
                                }

                                pong_count_t pong_count = dg::network_tile_member_getsetter::get_pair_pong_count_nothrow(data_arr[i].root);
                                pong_count              = std::min(static_cast<pong_count_t>(dg::network_tile_metadata::PAIR_DESCENDANT_COUNT), static_cast<pong_count_t>(pong_count + 1u)); //has to be unsigned otherwise we risk signed wraparound
                                dg::network_tile_member_getsetter::set_pair_pong_count_nothrow(data_arr[i].root, pong_count);

                                if (pong_count == dg::network_tile_metadata::PAIR_DESCENDANT_COUNT){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_pair_forward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.lhs                  = dg::network_tile_member_getsetter::get_pair_left_descendant_nothrow(data_arr[i].root);
                                    dispatch_radix.rhs                  = dg::network_tile_member_getsetter::get_pair_right_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_forward_pair_dispatch(dispatch_control));
                                    dispatch_radix.dst_vd_id            = dispatch_info.dst_vd_id;
                                    dispatch_radix.lhs_vd_id            = dispatch_info.lhs_vd_id;
                                    dispatch_radix.rhs_vd_id            = dispatch_info.rhs_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t dst;
                cuda_ptr_t lhs;
                cuda_ptr_t rhs;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_vec_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_vec(cuda_ptr_vec_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_vec[i * 3]     = data_arr[i].dst;
                        cuda_ptr_vec[i * 3 + 1] = data_arr[i].lhs;
                        cuda_ptr_vec[i * 3 + 2] = data_arr[i].rhs;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_pair_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::forward_pair(e.dst, e.lhs, e.rhs, e.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_vec.get(), std::next(cuda_ptr_vec.get(), cuda_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                host_ptr_t lhs;
                host_ptr_t rhs;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_vec_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_vec(host_ptr_vec_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_vec[i * 3]     = data_arr[i].dst;
                        host_ptr_vec[i * 3 + 1] = data_arr[i].lhs;
                        host_ptr_vec[i * 3 + 2] = data_arr[i].rhs;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_pair_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_pair(e.dst, e.lhs, e.rhs, e.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order, virtual_wo_buf));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_vec.get(), std::next(host_ptr_vec.get(), host_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: word_size memcmp + has_unique_object_representations_v
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t lhs_region_rcu_addr;
                uma_ptr_t rhs_region_rcu_addr;
                device_id_t dst_vd_id;
                device_id_t lhs_vd_id;
                device_id_t rhs_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr, dst_vd_id, lhs_vd_id, rhs_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr, dst_vd_id, lhs_vd_id, rhs_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t lhs;
                uma_ptr_t rhs;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.lhs_region_rcu_addr, key.rhs_region_rcu_addr);

                    auto umamap_reacquirer                              = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 3u>{}));
                    auto dst_vmamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto lhs_vmamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto rhs_vmamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto internal_cuda_resolutor                        = InternalCudaResolutor{};
                    internal_cuda_resolutor.async_device                = this->cuda_async_device;
                    internal_cuda_resolutor.synchronizer                = &cuda_synchronizer;
                    internal_cuda_resolutor.restrict_synchronizer       = &cuda_restrict_synchronizer;

                    auto host_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto internal_host_resolutor                        = InternalHostResolutor{};
                    internal_host_resolutor.async_device                = this->host_async_device;
                    internal_host_resolutor.synchronizer                = &host_synchronizer;
                    internal_host_resolutor.restrict_synchronizer       = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_cuda_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_cuda_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_cuda_mixed_vectorization_sz          = std::min(this->vectorization_sz, sz);
                    size_t cmdh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_cuda_resolutor, trimmed_cuda_mixed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cmdh_mem(cmdh_allocation_cost);
                    auto cuda_mixed_delivery_handle                     = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_cuda_resolutor, trimmed_cuda_mixed_vectorization_sz, cmdh_mem.get())); 

                    size_t trimmed_host_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_host_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_host_resolutor, trimmed_host_vectorization_sz, hdh_mem.get())); 

                    size_t trimmed_host_mixed_vectorization_sz          = std::min(this->vectorization_sz, sz);
                    size_t hmdh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_host_resolutor, trimmed_host_mixed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hmdh_mem(hmdh_allocation_cost);
                    auto host_mixed_delivery_handle                     = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_host_resolutor, trimmed_host_mixed_vectorization_sz, hmdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, lhs, rhs, expected_ops_id]   = std::make_tuple(data_arr[i].dst, data_arr[i].lhs, data_arr[i].rhs, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_lhs                       = dg::network_tile_member_getsetter::get_pair_left_descendant_nothrow(dst);
                        uma_ptr_t dst_rhs                       = dg::network_tile_member_getsetter::get_pair_right_descendant_nothrow(dst);
                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_pair_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_fwd_operatable_id   = dg::network_tile_member_getsetter::get_pair_operatable_forward_id_nothrow(dst);
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_pair_init_status_nothrow(dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_pair_logit_addr_nothrow(dst);
                        dispatch_major_t dst_dispatch_major     = dg::network_tile_member_getsetter::get_pair_dispatch_major_nothrow(dst);
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_pair_observer_array_size_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_pair_forward_dispatch_control_nothrow(dst);

                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_pair_observer_array_nothrow(dst, dst_observer_arr.get());

                        std::expected<operatable_id_t, exception_t> lhs_fwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(lhs);
                        std::expected<uma_ptr_t, exception_t> lhs_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(lhs);
                        std::expected<init_status_t, exception_t> lhs_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(lhs);

                        std::expected<operatable_id_t, exception_t> rhs_fwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(rhs);
                        std::expected<uma_ptr_t, exception_t> rhs_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(rhs);
                        std::expected<init_status_t, exception_t> rhs_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(rhs);

                        if (!lhs_fwd_operatable_id.has_value() || !lhs_logit_umaptr.has_value() || !lhs_init_status.has_value() 
                            || !rhs_fwd_operatable_id.has_value() || !rhs_logit_umaptr.has_value() || !rhs_init_status.has_value()){

                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_DECAYED && dst_init_status != TILE_INIT_STATUS_ADOPTED){
                            continue;
                        }

                        if (lhs_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (rhs_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_lhs != lhs){
                            continue;
                        }

                        if (dst_rhs != rhs){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_fwd_operatable_id != lhs_fwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_fwd_operatable_id != rhs_fwd_operatable_id.value()){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_pair_forward_dispatch(dispatch_control));

                        if (dispatch_info.dst_vd_id != key.dst_vd_id){
                            continue;
                        }

                        if (dispatch_info.lhs_vd_id != key.lhs_vd_id){
                            continue;
                        }

                        if (dispatch_info.rhs_vd_id != key.rhs_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{dst_logit_umaptr, dispatch_info.dst_vd_id}, 
                                                                                                           {lhs_logit_umaptr.value(), dispatch_info.lhs_vd_id}, 
                                                                                                           {rhs_logit_umaptr.value(), dispatch_info.rhs_vd_id}});

                        vma_ptr_t dst_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t lhs_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t rhs_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(dst_vmamap_reacquirer, dst_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(lhs_vmamap_reacquirer, lhs_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(rhs_vmamap_reacquirer, rhs_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.dst              = dg::network_vmamap::get_cuda_ptr(dst_vmamap_reacquirer);
                            cuda_resolutor_arg.lhs              = dg::network_vmamap::get_cuda_ptr(lhs_vmamap_reacquirer);
                            cuda_resolutor_arg.rhs              = dg::network_vmamap::get_cuda_ptr(rhs_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            //compiler's hint
                            cuda_ptr_t cuda_dispatch_buf[3];
                            cuda_dispatch_buf[0]                = cuda_resolutor_arg.rhs;
                            cuda_dispatch_buf[1]                = cuda_resolutor_arg.lhs;
                            cuda_dispatch_buf[2]                = dg::pointer_limits<cuda_ptr_t>::null_value();

                            if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_RIGHT){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_dispatch_buf[0], cuda_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_LEFT){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_dispatch_buf[1], cuda_resolutor_arg);
                            } else if (dst_dispatch_major = PAIR_DISPATCH_MAJOR_MIXED){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_mixed_delivery_handle.get(), cuda_dispatch_buf[2], cuda_resolutor_arg);
                            } else{
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.dst              = dg::network_vmamap::get_host_ptr(dst_vmamap_reacquirer);
                            host_resolutor_arg.lhs              = dg::network_vmamap::get_host_ptr(lhs_vmamap_reacquirer);
                            host_resolutor_arg.rhs              = dg::network_vmamap::get_host_ptr(rhs_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            //compiler's hint
                            host_ptr_t host_dispatch_buf[3];
                            host_dispatch_buf[0]                = host_resolutor_arg.rhs;
                            host_dispatch_buf[1]                = host_resolutor_arg.lhs;
                            host_dispatch_buf[2]                = dg::pointer_limits<host_ptr_t>::null_value();

                            if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_RIGHT){
                                dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_dispatch_buf[0], host_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_LEFT){
                                dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_dispatch_buf[1], host_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_MIXED){
                                dg::network_producer_consumer::delvrsrv_deliver(host_mixed_delivery_handle.get(), host_dispatch_buf[2], host_resolutor_arg);
                            } else{
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else[
                                    std::unreachable();
                                ]
                            }
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(),
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }
                        }

                        dg::network_tile_member_getsetter::set_pair_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);
                    }
                }
            };
    };

    //clear
    class ForwardDoPolySignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoPolySignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                         std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                         std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                         size_t request_delivery_capacity,
                                         size_t radxfetch_vectorization_sz,
                                         size_t region_vectorization_sz,
                                         size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                    host_async_device(std::move(host_async_device)),
                                                                                    cuda_async_device(std::move(cuda_async_device)),
                                                                                    request_delivery_capacity(request_delivery_capacity),
                                                                                    radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                    region_vectorization_sz(region_vectorization_sz),
                                                                                    forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_poly_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            } 

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fecther, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_poly_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        if constexpr(DEBUG_MODE_FLAG){
                            if (dispatch_radix_arg_arr[i].poly_type != POLY_TILE_MONO && dispatch_radix_arg_arr[i].poly_type != POLY_TILE_PAIR){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            }
                        }

                        std::optional<uma_ptr_t> lhs_rcu_addr   = std::nullopt;
                        std::optional<uma_ptr_t> rhs_rcu_addr   = std::nullopt;

                        //these are not necessary, should be DEBUG_MODE because we assume that tile state is correct at ALL TIME, we dont know if the tile has rcu_addr or not, this is probably why we decide to continue instead of aborting
                        //imagine that TILE can be correct, but the lack of tile_rcu_addr can also be considered correct, as if the missing of backward_forward_id or grad_logit_addr, etc. 
                        //we are having a problem
                        //the problem of key
                        //rhs_region_rcu_addr or rhs_vd_id could be missing
                        //yet it is compatible with any of the other guys that share lhs_region_rcu_addr
                        //we don't attempt to solve that YET, because that's incredibly complex to solve

                        std::expected<uma_ptr_t, exception_t> _lhs_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->lhs);

                        if (!_lhs_rcu_addr.has_value()){
                            continue;
                        }

                        lhs_rcu_addr = _lhs_rcu_addr.value();

                        if (dispatch_radix_arg_arr[i].poly_type == POLY_TILE_PAIR){
                            std::expected<uma_ptr_t, exception_t> _rhs_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->rhs); 

                            if (!_rhs_rcu_addr.has_value()){
                                continue;
                            }

                            rhs_rcu_addr = _rhs_rcu_addr.value();
                        }
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t lhs;
                uma_ptr_t rhs;
                device_id_t dst_vd_id;
                device_id_t lhs_vd_id;
                device_id_t rhs_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status           = dg::network_tile_member_getsetter::get_poly_init_status_nothrow(data_arr[i].root);
                        operatable_id_set_t current_ops_id  = dg::network_tile_member_getsetter::get_poly_operatable_memevent_id_set_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }         
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (!is_subset_id(data_arr[i].expected_ops_id, current_ops_id)){
                                    break;
                                }

                                if constexpr(DEBUG_MODE_FLAG){
                                    poly_tile_t poly_type = dg::network_tile_member_getsetter::get_poly_poly_type_nothrow(data_arr[i].root);

                                    if (poly_type != POLY_TILE_PAIR){
                                        dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                        std::abort();
                                    }
                                }

                                pong_count_t expected_pong_count    = dg::network_tile_member_getsetter::get_poly_expected_pong_count_nothrow(data_arr[i].root);
                                pong_count_t pong_count             = dg::network_tile_member_getsetter::get_poly_pong_count_nothrow(data_arr[i].root);
                                pong_count                          = std::min(expected_pong_count, static_cast<pong_count_t>(pong_count + 1u));

                                dg::network_tile_member_getsetter::set_poly_pong_count_nothrow(data_arr[i].root, pong_count);

                                if (pong_count == expected_pong_count){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_poly_forward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.lhs                  = dg::network_tile_member_getsetter::get_poly_left_descendant_nothrow(data_arr[i].root);
                                    dispatch_radix.rhs                  = dg::network_tile_member_getsetter::get_poly_right_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_forward_polypair_dispatch(dispatch_control));
                                    dispatch_radix.dst_vd_id            = dispatch_info.dst_vd_id;
                                    dispatch_radix.lhs_vd_id            = dispatch_info.lhs_vd_id;
                                    dispatch_radix.rhs_vd_id            = dispatch_info.rhs_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;  
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }          
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t dst;
                cuda_ptr_t lhs;
                cuda_ptr_t rhs;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer; //restrictness is per load, this is weird

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_vec_cap     = sz * 3;
                    size_t cuda_ptr_vec_sz      = 0u;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_vec(cuda_ptr_vec_cap);
                    size_t total_complexity     = 0u;
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(cuda_ptr_vec_cap)); 

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_vec[cuda_ptr_vec_sz++] = data_arr[i].dst;
                        cuda_ptr_vec[cuda_ptr_vec_sz++] = data_arr[i].lhs;
                        cuda_ptr_vec[cuda_ptr_vec_sz++] = data_arr[i].rhs;
                        total_complexity                += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_polypair_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order                 = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::forward_polypair(e.dst, e.lhs, e.rhs, e.dispatch_control));
                        };
                        auto virtual_wo                 = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(std::move(work_order)));

                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_vec.get(), std::next(cuda_ptr_vec.get(), cuda_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                host_ptr_t lhs;
                host_ptr_t rhs;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_vec_cap     = sz * 3;
                    size_t host_ptr_vec_sz      = 0u;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_vec(host_ptr_vec_cap);
                    size_t total_complexity     = 0u;
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(host_ptr_vec_cap));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_vec[host_ptr_vec_sz++] = data_arr[i].dst;
                        host_ptr_vec[host_ptr_vec_sz++] = data_arr[i].lhs;
                        host_ptr_vec[host_ptr_vec_sz++] = data_arr[i].rhs;
                        total_complexity                += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_polypair_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order                 = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_pair(e.dst, e.lhs, e.rhs, e.dispatch_control));
                        };
                        auto virtual_wo                 = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(std::move(work_order)));

                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_vec.get(), std::next(host_ptr_vec.get(), host_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t lhs_region_rcu_addr;
                uma_ptr_t rhs_region_rcu_addr;
                device_id_t dst_vd_id;
                device_id_t lhs_vd_id;
                device_id_t rhs_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr, dst_vd_id, lhs_vd_id, rhs_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr, dst_vd_id, lhs_vd_id, rhs_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t lhs;
                uma_ptr_t rhs;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(const ResolutorKeyArgument& key, std::move_iterator<ResolutorValueArgument *> data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.lhs_region_rcu_addr, key.rhs_region_rcu_addr);

                    auto umamap_reacquirer                              = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 3u>{}));
                    auto dst_vmamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto lhs_vmamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto rhs_vmamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize()); 

                    auto cuda_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto internal_cuda_resolutor                        = InternalCudaResolutor{};
                    internal_cuda_resolutor.async_device                = this->cuda_async_device;
                    internal_cuda_resolutor.synchronizer                = &cuda_synchronizer;
                    internal_cuda_resolutor.restrict_synchronizer       = &restrict_synchronizer;

                    auto host_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto internal_host_resolutor                        = InternalHostResolutor{};
                    internal_host_resolutor.async_device                = this->host_async_device;
                    internal_host_resolutor.synchronizer                = &host_synchronizer;
                    internal_host_resolutor.restrict_synchronizer       = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_cuda_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_cuda_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_cuda_mixed_vectorization_sz          = std::min(this->vectorization_sz, sz);
                    size_t cmdh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_cuda_resolutor, trimmed_cuda_mixed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cmdh_mem(cmdh_allocation_cost);
                    auto cuda_mixed_delivery_handle                     = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_cuda_resolutor, trimmed_cuda_mixed_vectorization_sz, cmdh_mem.get()));

                    size_t trimmed_host_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_host_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_host_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    size_t trimmed_host_mixed_vectorization_sz          = std::min(this->vectorization_sz, sz);
                    size_t hmdh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&internal_host_resolutor, trimmed_host_mixed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hmdh_mem(hmdh_allocation_cost);
                    auto host_mixed_delivery_handle                     = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&internal_host_resolutor, trimmed_host_mixed_vectorization_sz, hmdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, lhs, rhs, expected_ops_id]   = std::make_tuple(data_arr[i].dst, data_arr[i].lhs, data_arr[i].rhs, data_arr[i].expected_ops_id);
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_poly_init_status_nothrow(dst);

                        if (dst_init_status != TILE_INIT_STATUS_DECAYED && dst_init_status != TILE_INIT_STATUS_ADOPTED){
                            continue;
                        }

                        poly_tile_t poly_type                   = dg::network_tile_member_getsetter::get_poly_poly_type_nothrow(dst);

                        if (poly_type != POLY_TILE_PAIR)[
                            continue;
                        ]

                        uma_ptr_t dst_lhs                       = dg::network_tile_member_getsetter::get_poly_left_descendant_nothrow(dst);
                        uma_ptr_t dst_rhs                       = dg::network_tile_member_getsetter::get_poly_right_descendant_nothrow(dst);
                        operatable_id_set_t dst_operatable_id   = dg::network_tile_member_getsetter::get_poly_operatable_memevent_id_set_nothrow(dst);
                        operatable_id_t dst_fwd_operatable_id   = dg::network_tile_member_getsetter::get_poly_operatable_forward_id_nothrow(dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_poly_logit_addr_nothrow(dst);
                        dispatch_major_t dst_dispatch_major     = dg::network_tile_member_getsetter::get_poly_dispatch_major_nothrow(dst);
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_poly_observer_array_size_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_poly_forward_dispatch_control_nothrow(dst);

                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_poly_observer_array_nothrow(dst, dst_observer_arr.get());

                        std::expected<operatable_id_t, exception_t> lhs_fwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(lhs);
                        std::expected<uma_ptr_t, exception_t> lhs_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(lhs);
                        std::expected<init_status_t, exception_t> lhs_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(lhs);

                        std::expected<operatable_id_t, exception_t> rhs_fwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(rhs);
                        std::expected<uma_ptr_t, exception_t> rhs_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(rhs);
                        std::expected<init_status_t, exception_t> rhs_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(rhs);

                        if (!lhs_fwd_operatable_id.has_value() || !lhs_logit_umaptr.has_value() || !lhs_init_status.has_value()
                            || !rhs_fwd_operatable_id.has_value() || !rhs_logit_umaptr.has_value() || !rhs_init_status.has_value()){

                            continue;
                        }

                        if (lhs_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (rhs_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_lhs != lhs){
                            continue;
                        }

                        if (dst_rhs != rhs){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_fwd_operatable_id != lhs_fwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_fwd_operatable_id != rhs_fwd_operatable_id.value()){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_polypair_forward_dispatch(dispatch_control));

                        if (dispatch_info.dst_vd_id != key.dst_vd_id){
                            continue;
                        }

                        if (dispatch_info.lhs_vd_id != key.lhs_vd_id){
                            continue;
                        }

                        if (dispatch_info.rhs_vd_id != key.rhs_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{dst_logit_umaptr, dispatch_info.dst_vd_id},
                                                                                                           {lhs_logit_umaptr.value(), dispatch_info.lhs_vd_id},
                                                                                                           {rhs_logit_umaptr.value(), dispatch_info.rhs_vd_id}});
                        
                        vma_ptr_t dst_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t lhs_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t rhs_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(dst_vmamap_reacquirer, dst_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(lhs_vmamap_reacquirer, lhs_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(rhs_vmamap_reacquirer, rhs_vmaptr);

                        //I dont think we'd ever want to use technology other than cuda + host

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.dst              = dg::network_vmamap::get_cuda_ptr(dst_vmamap_reacquirer);
                            cuda_resolutor_arg.lhs              = dg::network_vmamap::get_cuda_ptr(lhs_vmamap_reacquirer);
                            cuda_resolutor_arg.rhs              = dg::network_vmamap::get_cuda_ptr(rhs_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            //compiler's hint
                            cuda_ptr_t cuda_dispatch_buf[3];
                            cuda_dispatch_buf[0]                = cuda_resolutor_arg.rhs;
                            cuda_dispatch_buf[1]                = cuda_resolutor_arg.lhs;
                            cuda_dispatch_buf[2]                = dg::pointer_limits<cuda_ptr_t>::null_value();

                            if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_RIGHT){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_dispatch_buf[0], cuda_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_LEFT){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_dispatch_buf[1], cuda_resolutor_arg);
                            } else if (dst_dispatch_major = PAIR_DISPATCH_MAJOR_MIXED){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_mixed_delivery_handle.get(), cuda_dispatch_buf[2], cuda_resolutor_arg);
                            } else{
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.dst              = dg::network_vmamap::get_host_ptr(dst_vmamap_reacquirer);
                            host_resolutor_arg.lhs              = dg::network_vmamap::get_host_ptr(lhs_vmamap_reacquirer);
                            host_resolutor_arg.rhs              = dg::network_vmamap::get_host_ptr(rhs_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            //compiler's hint
                            host_ptr_t host_dispatch_buf[3];
                            host_dispatch_buf[0]                = host_resolutor_arg.rhs;
                            host_dispatch_buf[1]                = host_resolutor_arg.lhs;
                            host_dispatch_buf[2]                = dg::pointer_limits<host_ptr_t>::null_value();

                            if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_RIGHT){
                                dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_dispatch_buf[0], host_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_LEFT){
                                dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_dispatch_buf[1], host_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_MIXED){
                                dg::network_producer_consumer::delvrsrv_deliver(host_mixed_delivery_handle.get(), host_dispatch_buf[2], host_resolutor_arg);
                            } else{
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else[
                                    std::unreachable();
                                ]
                            }
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(),
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }
                        }

                        dg::network_tile_member_getsetter::set_poly_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);
                    }
                }
            };
    };

    //the major operation that we'd use for UACM is to buff a data type from uint8_t -> uint64_t for a struct of 8 uint8_t
    //or uint64_t -> uint512_t 
    //or uint8_t -> uint512_t

    //we dont have applications for this except for that
    //I dont know why we need unordered accum + pair accum
    //we'll find the applications for this later

    class ForwardDoUACMSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoUACMSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                         std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                         std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                         size_t request_delivery_capacity,
                                         size_t radxfetch_vectorization_sz,
                                         size_t region_vectorization_sz,
                                         size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                    host_async_device(std::move(host_async_device)),
                                                                                    cuda_async_device(std::move(cuda_async_device)),
                                                                                    request_delivery_capacity(request_delivery_capacity),
                                                                                    radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                    region_vectorization_sz(region_vectorization_sz),
                                                                                    forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_uacm_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_uacm_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<dg::vector<uma_ptr_t>, exception_t> rcu_vec = this->to_region_rcu_vec(dispatch_radix_arg_arr[i]->descendant_vec);

                        if (!rcu_vec.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                        = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                      = dg::network_tile_member_getsetter::get_uacm_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t dst_region_rcu_addr               = dg::memult::region(dst_rcu_addr, lck_region_sz);

                        ResolutorKeyArgument resolutor_key_arg      = this->make_resolutor_key_argument(dst_region_rcu_addr, 
                                                                                                        dispatch_radix_arg_arr[i]->dst_vd_id, 
                                                                                                        rcu_vec.value(), 
                                                                                                        dispatch_radix_arg_arr[i]->descendant_vd_id_vec,
                                                                                                        dispatch_radix_arg_arr[i]->platform);

                        ResolutorValueArgument resolutor_val_arg    = this->make_resolutor_value_argument(event_arr[i].dst, 
                                                                                                          dispatch_radix_arg_arr[i]->descendant_vec, 
                                                                                                          event_arr[i].operatable_id);
                        
                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, std::move(resolutor_val_arg));
                    }
                }
            }

        private:

            static auto to_region_rcu_vec(const dg::vector<uma_ptr_t>& tile_addr_vec) noexcept -> std::expected<dg::vector<uma_ptr_t>, exception_t>{

                //sorts

                dg::vector<uma_ptr_t> region_rcu_vec    = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<uma_ptr_t>>(tile_addr_vec.size()));
                size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));

                for (size_t i = 0u; i < tile_addr_vec.size(); ++i){
                    std::expected<uma_ptr_t, exception_t> tile_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(tile_addr_vec[i]);

                    if (!tile_rcu_addr.has_value()){
                        return std::unexpected(tile_rcu_addr.error());
                    }

                    region_rcu_vec[i] = dg::memult::region(tile_rcu_addr.value(), lck_region_sz);
                }

                return region_rcu_vec;
            }

            struct DispatchRadixArgument{
                dg::vector<uma_ptr_t> descendant_vec;
                device_id_t dst_vd_id;
                dg::vector<device_id_t> descendant_vd_id_vec;
                platform_t platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDescendantAddressFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_uacm_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_uacm_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != data_arr[i].expected_ops_id){
                                    break;
                                }

                                DispatchRadixArgument dispatch_radix_arg{.descendant_vec        = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector>(UACM_ACM_SZ)),
                                                                         .dst_vd_id             = {},
                                                                         .descendant_vd_id_vec  = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector>(UACM_ACM_SZ)),
                                                                         .platform              = {}}; 

                                dg::network_tile_member_getsetter::get_uacm_descendant_nothrow(dst, dispatch_radix_arg.descendant_vec.data());

                                auto dispatch_control               = dg::network_tile_member_getsetter::get_uacm_forward_dispatch_control_nothrow(dst);
                                auto devirtualized_dispatch_control = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::devirtualize_uacm_dispatch_control(dispatch_control));

                                dispatch_radix_arg.dst_vd_id        = devirtualized_dispatch_control.dst_vd_id;
                                std::copy(devirtualized_dispatch_control.descendant_vd_id_vec.begin(), devirtualized_dispatch_control.descendant_vd_id_vec.end(), dispatch_radix_arg.descendant_vec.begin());
                                dispatch_radix_arg.platform         = devirtualized_dispatch_control.platform;

                                *data_arr[i].fetching_addr          = std::move(dispatch_radix_arg);
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t dst;
                dg::vector<cuda_ptr_t> descendant_vec; 
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            static auto make_cuda_resolutor_argument(cuda_ptr_t dst,
                                                     const dg::vector<cuda_ptr_t>& descendant_vec,
                                                     cuda_tileops_dispatch_control_t dispatch_control) noexcept -> CudaResolutorArgument{
                
                return CudaResolutorArgument{.dst               = dst,
                                             .descendant_vec    = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<cuda_ptr_t>>(descendant_vec)),
                                             .dispatch_control  = dispatch_control};
            }

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    const size_t DISPATCH_ARR_SZ    = UACM_ACM_SZ + 1u;

                    size_t cuda_ptr_arr_cap         = sz * DISPATCH_ARR_SZ;
                    size_t cuda_ptr_arr_sz          = 0u;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_cap);
                    size_t total_complexity         = 0u;
                    auto virtual_wo_vec             = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (data_arr[i].descendant_vec.size() != UACM_ACM_SZ){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            }
                        }

                        auto cpy_ptr        = std::copy(data_arr[i].descendant_vec.begin(), data_arr[i].descendant_vec.end(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz));
                        *cpy_ptr            = data_arr[i].dst;
                        cuda_ptr_arr_sz     += DISPATCH_ARR_SZ;
                        total_complexity    += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_uacm_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;

                        auto work_order     = [e = data_arr[i]]() noexcept{ //
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::forward_uacm(e.dst, e.descendant_vec.data(), e.dispatch_control));
                        };

                        auto virtual_wo     = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(std::move(work_order)));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                dg::vector<host_ptr_t> descendant_vec;
                host_tileops_dispatch_control_t dispatch_control; 
            };

            static auto make_host_resolutor_argument(host_ptr_t dst,
                                                     const dg::vector<host_ptr_t>& descendant_vec,
                                                     host_tileops_dispatch_control_t dispatch_control) noexcept -> HostResolutorArgument{

                return HostResolutorArgument{.dst               = dst,
                                             .descendant_vec    = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<host_ptr_t>>(descendant_vec)),
                                             .dispatch_control  = dispatch_control};
            } 

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    const size_t DISPATCH_ARR_SZ    = UACM_ACM_SZ + 1u;

                    size_t host_ptr_arr_cap         = sz * DISPATCH_ARR_SZ;
                    size_t host_ptr_arr_sz          = 0u;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity         = 0u;
                    auto virtual_wo_vec             = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (data_arr[i].descendant_vec.size() != UACM_ACM_SZ){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            }
                        }

                        auto cpy_ptr        = std::copy(data_arr[i].descendant_vec.begin(), data_arr[i].descendant_vec.end(), std::next(host_ptr_arr.get(), host_ptr_arr_sz));
                        *cpy_ptr            = data_arr[i].dst;
                        host_ptr_arr_sz     += DISPATCH_ARR_SZ;
                        total_complexity    += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_uacm_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order     = [e = data_arr[i]]() noexcept{ //
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_uacm(e.dst, e.descendant_vec.data(), e.dispatch_control));
                        };

                        auto virtual_wo     = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(std::move(work_order)));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                device_id_t dst_region_device_id;
                dg::vector<uma_ptr_t> src_region_rcu_addr_vec;
                dg::vector<device_id_t> src_region_device_id_vec;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const{
                    reflector(dst_region_rcu_addr, dst_region_device_id, src_region_rcu_addr_vec, src_region_device_id_vec, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector){
                    reflector(dst_region_rcu_addr, dst_region_device_id, src_region_rcu_addr_vec, src_region_device_id_vec, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr_vec);
                }
            };

            static auto make_resolutor_key_argument(uma_ptr_t dst_region_rcu_addr,
                                                    device_id_t dst_region_device_id,
                                                    const dg::vector<uma_ptr_t>& src_region_rcu_addr_vec,
                                                    const dg::vector<device_id_t>& src_region_device_id_vec,
                                                    platform_t dispatch_platform) noexcept -> ResolutorKeyArgument{

                return ResolutorKeyArgument{.dst_region_rcu_addr        = dst_region_rcu_addr,
                                            .dst_region_device_id       = dst_region_device_id,
                                            .src_region_rcu_addr_vec    = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<uma_ptr_t>>(src_region_rcu_addr_vec)),
                                            .src_region_device_id_vec   = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<device_id_t>>(src_region_device_id_vec)),
                                            .dispatch_platform          = dispatch_platform};
            }

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                dg::vector<uma_ptr_t> src_vec;
                operatable_id_t expected_ops_id;
            };

            static auto make_resolutor_value_argument(uma_ptr_t dst,
                                                      const dg::vector<uma_ptr_t>& src_vec,
                                                      operatable_id_t expected_ops_id) noexcept -> ResolutorValueArgument{

                return ResolutorValueArgument{.dst              = dst,
                                              .src_vec          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<uma_ptr_t>>(src_vec)),
                                              .expected_ops_id  = expected_ops_id};
            }

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;
                
                static auto get_src_operatable_forward_id_arr(uma_ptr_t * src_arr, size_t src_arr_sz, operatable_id_t * output_arr) noexcept -> exception_t{

                    for (size_t i = 0u; i < src_arr_sz; ++i){
                        std::expected<operatable_id_t, exception_t> src_operatable_fwd_id = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(src_arr[i]);

                        if (!src_operatable_fwd_id.has_value()){
                            return src_operatable_fwd_id.error();
                        }

                        output_arr[i] = src_operatable_fwd_id.value();
                    }

                    return dg::network_exception::SUCCESS;
                }

                static auto get_src_logit_uma_ptr_arr(uma_ptr_t * src_arr, size_t src_arr_sz, uma_ptr_t * output_arr) noexcept -> exception_t{

                    for (size_t i = 0u; i < src_arr_sz; ++i){
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr = dg::network_tile_member_getsetter::get_tile_logit_addr(src_arr[i]);

                        if (!src_logit_umaptr.has_value()){
                            return src_logit_umaptr.error();
                        }

                        output_arr[i] = src_logit_umaptr.value();
                    }

                    return dg::network_exception::SUCCESS;
                }

                static auto get_src_init_status_arr(uma_ptr_t * src_arr, size_t src_arr_sz, init_status_t * output_arr) noexcept -> exception_t{

                    for (size_t i = 0u; i < src_arr_sz; ++i){
                        std::expected<init_status_t, exception_t> src_init_status = dg::network_tile_member_getsetter::get_tile_init_status(src_arr[i]);

                        if (!src_init_status.has_value()){
                            return src_init_status.error();
                        }

                        output_arr[i] = src_init_status.value();
                    }

                    return dg::network_exception::SUCCESS;
                }

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard_x mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr_vec);

                    auto dst_umamap_reacquirer                      = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_raii_initialize());
                    auto src_umamap_reacquirer                      = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(UACM_ACM_SZ));

                    auto dst_vmamap_remapper                        = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_vmamap_remapper                        = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_fixedsize_raii_initialize(UACM_ACM_SZ)); 

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz); 
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz); //alright - we might want to do optimization - its hard 
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_uacm_init_status_nothrow(data_arr[i].dst);

                        if (dst_init_status != TILE_INIT_STATUS_ADOPTED && dst_init_status != TILE_INIT_STATUS_DECAYED){
                            continue;
                        }

                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_uacm_operatable_memevent_id_nothrow(data_arr[i].dst);

                        if (dst_operatable_id != data_arr[i].expected_ops_id){
                            continue;
                        }

                        dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> dst_src(UACM_ACM_SZ);
                        dg::network_tile_member_getsetter::get_uacm_descendant_nothrow(data_arr[i].dst, dst_src.get());

                        operatable_id_t dst_operatable_fwd_id   = dg::network_tile_member_getsetter::get_uacm_operatable_forward_id_nothrow(data_arr[i].dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_uacm_logit_addr_nothrow(data_arr[i].dst);
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_uacm_observer_array_size_nothrow(data_arr[i].dst);
                        dispatch_control_fat_t dispatch_control = dg::network_tile_member_getsetter::get_uacm_forward_dispatch_control_nothrow(data_arr[i].dst);

                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_uacm_observer_array_nothrow(data_arr[i].dst, dst_observer_arr.get());

                        dg::network_stack_allocation::NoExceptAllocation<init_status_t[]> src_init_status_arr(UACM_ACM_SZ);

                        if (exception_t err = this->get_src_init_status_arr(dst_src.get(), UACM_ACM_SZ, src_init_status_arr.get()); dg::network_exception::is_failed(err)){
                            continue;
                        }

                        if (std::find(src_init_status_arr.get(), std::next(src_init_status_arr.get(), UACM_ACM_SZ), 
                                      [](const init_status_t& init_status){return init_status != TILE_INIT_STATUS_INITIALIZED;}) != std::next(src_init_status_arr.get(), UACM_ACM_SZ)){
                            continue;
                        }

                        dg::network_stack_allocation::NoExceptAllocation<operatable_id_t[]> src_operatable_fwd_id_arr(UACM_ACM_SZ);
                        
                        if (exception_t err = this->get_src_operatable_forward_id_arr(dst_src.get(), UACM_ACM_SZ, src_operatable_fwd_id_arr.get()); dg::network_exception::is_failed(err)){
                            continue;
                        }

                        dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> src_logit_umaptr_arr(UACM_ACM_SZ);

                        if (exception_t err = this->get_src_logit_uma_ptr_arr(dst_src.get(), UACM_ACM_SZ, src_logit_umaptr_arr.get()); dg::network_exception::is_failed(err)){
                            continue;
                        }

                        if (!std::equal(dst_src.get(), std::next(dst_src.get(), UACM_ACM_SZ), data_arr[i].src_vec.begin())){ //
                            continue;
                        }

                        if (std::find(src_operatable_fwd_id_arr.get(), std::next(src_operatable_fwd_id_arr.get(), UACM_ACM_SZ), 
                                     [&](const operatable_id_t& operatable_id){return operatable_id != dst_operatable_fwd_id;}) != std::next(src_operatable_fwd_id_arr.get(), UACM_ACM_SZ)){
                            continue;
                        }

                        auto devirtualized_dispatch_control = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::devirtualize_uacm_dispatch_control(dispatch_control));

                        if (devirtualized_dispatch_control.dst_vd_id != key.dst_region_device_id){
                            continue;
                        }

                        if (devirtualized_dispatch_control.descendant_vd_id_vec != key.src_region_device_id_vec){
                            continue;
                        }

                        if (devirtualized_dispatch_control.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        //

                        dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_reacquire(dst_umamap_reacquirer, dst_logit_umaptr)); //we are relaxing the nothrow from now on
                        vma_ptr_t dst_vmaptr = dg::network_uma::get_vma_ptr(dst_umamap_reacquirer); 
                        dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_remap(dst_vmamap_remapper, dst_vmaptr));

                        //

                        dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_reacquire_range(src_umamap_reacquirer, src_logit_umaptr_arr.data(), UACM_ACM_SZ));
                        dg::network_stack_allocation::NoExceptAllocation<vma_ptr_t[]> src_vma_ptr_arr(UACM_ACM_SZ);
                        dg::network_uma::get_vma_ptr_range(src_umamap_reacquirer, src_vma_ptr_arr.get(), 0u, UACM_ACM_SZ);
                        dg::networK_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_remap_range(src_vmamap_remapper, src_vma_ptr_arr.get(), UACM_ACM_SZ));

                        //

                        if (dg::network_dispatch_control::is_cuda_dispatch(devirtualized_dispatch_control.dispatch_platform)){
                            cuda_ptr_t dst_cu_ptr                       = dg::network_vmamap::get_cuda_ptr(dst_vmamap_remapper);
                            dg::vector<cuda_ptr_t> src_cu_ptr_vec       = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector>(UACM_ACM_SZ));
                            dg::network_vmamap::get_cuda_ptr_range(src_vmamap_remapper, src_cu_ptr_vec.data(), 0u, UACM_ACM_SZ);

                            CudaResolutorArgument cuda_resolutor_arg    = make_cuda_resolutor_argument(dst_cu_ptr, std::move(src_cu_ptr_vec), devirtualized_dispatch_control.tileops_cuda_dispatch_control); 
                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), std::move(cuda_resolutor_arg)); 
                        } else if (dg::network_dispatch_control::is_host_dispatch(devirtualized_dispatch_control.dispatch_platform)){
                            host_ptr_t dst_host_ptr                     = dg::network_vmamap::get_host_ptr(dst_vmamap_remapper);
                            dg::vector<host_ptr_t> src_host_ptr_vec     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector>(UACM_ACM_SZ));
                            dg::network_vmamap::get_host_ptr_range(src_vmamap_remapper, src_host_ptr_vec.data(), 0u, UACM_ACM_SZ); 

                            HostResolutorArgument host_resolutor_arg    = make_host_resolutor_argument(dst_host_ptr, std::move(src_host_ptr_vec), devirtualized_dispatch_control.tileops_host_dispatch_control);
                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), std::move(host_resolutor_arg));
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_uacm_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(),
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));
                                
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }
                        }
                    }
                }
            };
    };

    class ForwardDoPACMSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoPACMSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                         std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                         std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                         size_t request_delivery_capacity,
                                         size_t radxfetch_vectorization_sz,
                                         size_t region_vectorization_sz
                                         size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                    host_async_device(std::move(host_async_device)),
                                                                                    cuda_async_device(std::move(cuda_async_device)),
                                                                                    request_delivery_capacity(request_delivery_capacity),
                                                                                    radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                    region_vectorization_sz(region_vectorization_sz),
                                                                                    forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pacm_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_pacm_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<dg::vector<uma_ptr_t>, exception_t> lhs_rcu_vec = this->to_region_rcu_vec(dispatch_radix_arg_arr[i]->lhs_vec);

                        if (!lhs_rcu_vec.has_value()){
                            continue;
                        }

                        std::expected<dg::vector<uma_ptr_t>, exception_t> rhs_rcu_vec = this->to_region_rcu_vec(dispatch_radix_arg_arr[i]->rhs_vec);

                        if (!rhs_rcu_vec.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                        = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                      = dg::network_tile_member_getsetter::get_pacm_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t dst_region_rcu_addr               = dg::memult::region(dst_rcu_addr, lck_region_sz);

                        //we desparately wanted to combine these guys to have a unique representative, but we'd rather think that is the reflection problem
                        ResolutorKeyArgument resolutor_key_arg      = this->make_resolutor_key_argument(dst_region_rcu_addr,
                                                                                                        dispatch_radix_arg_arr[i]->dst_vd_id,
                                                                                                        lhs_rcu_vec.value(),
                                                                                                        rhs_rcu_vec.value(),
                                                                                                        dispatch_radix_arg_arr[i]->lhs_vd_id,
                                                                                                        dispatch_radix_arg_arr[i]->rhs_vd_id,
                                                                                                        dispatch_radix_arg_arr[i]->platform);

                        ResolutorValueArgument resolutor_val_arg    = this->make_resolutor_value_argument(event_arr[i].dst,
                                                                                                          dispatch_radix_arg_arr[i]->lhs_vec,
                                                                                                          dispatch_radix_arg_arr[i]->rhs_vec,
                                                                                                          event_arr[i].operatable_id);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, std::move(resolutor_val_arg));
                    }
                }
            }
        
        private:

            struct DispatchRadixArgument{
                dg::vector<uma_ptr_t> lhs_vec;
                dg::vector<uma_ptr_t> rhs_vec;
                device_id_t dst_vd_id;
                dg::vector<device_id_t> lhs_vd_id_vec;
                dg::vector<device_id_t> rhs_vd_id_vec;
                platform_t platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t dst;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        uma_ptr_t dst                   = data_arr[i].dst;
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_pacm_init_status_nothrow(dst);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_pacm_operatable_memevent_id_nothrow(dst);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id != data_arr[i].expected_ops_id){
                                    break;
                                }

                                DispatchRadixArgument dispatch_radix_arg{.lhs_vec           = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<uma_ptr_t>>(PACM_ACM_SZ)),
                                                                         .rhs_vec           = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<uma_ptr_t>>(PACM_ACM_SZ)),
                                                                         .dst_vd_id         = {},
                                                                         .lhs_vd_id_vec     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<device_id_t>>(PACM_ACM_SZ)),
                                                                         .rhs_vd_id_vec     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<device_id_t>>(PACM_ACM_SZ)),
                                                                         .platform          = {}};
                                
                                dg::network_tile_member_getsetter::get_pacm_left_descendant_nothrow(dst, dispatch_radix_arg.lhs_vec.data());
                                dg::network_tile_member_getsetter::get_pacm_right_descendant_nothrow(dst, dispatch_radix_arg.rhs_vec.data());

                                auto dispatch_control               = dg::network_tile_member_getsetter::get_pacm_forward_dispatch_control_nothrow(dst);
                                auto devirtualized_dispatch_control = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::devirtualize_pacm_dispatch_control(dispatch_control));

                                dispatch_radix_arg.dst_vd_id        = devirtualized_dispatch_control.dst_vd_id;
                                std::copy(devirtualized_dispatch_control.lhs_vd_id_vec.begin(), devirtualized_dispatch_control.lhs_vd_id_vec.end(), dispatch_radix_arg.lhs_vec.begin());
                                std::copy(devirtualized_dispatch_control.rhs_vd_id_vec.begin(), devirtualized_dispatch_control.rhs_vd_id_vec.end(), dispatch_radix_arg.rhs_vec.begin());
                                dispatch_radix_arg.platform         = devirtualized_dispatch_control.platform;

                                *data_arr[i].fetching_addr          = std::move(dispatch_radix_arg); 
                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            }

            struct CudaResolutorArgument{
                cuda_ptr_t dst;
                dg::vector<cuda_ptr_t> lhs;
                dg::vector<cuda_ptr_t> rhs;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(std::move_iterator<CudaResolutorArgument *> arg_data_arr, size_t sz) noexcept{

                    CudaResolutorArgument * data_arr    = arg_data_arr.base();
                    const size_t DISPATCH_ARR_CAP       = (PACM_ACM_SZ + PACM_ACM_SZ + 1u) * sz;
                    size_t cuda_ptr_arr_sz              = 0u;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(DISPATCH_ARR_CAP);
                    size_t total_complexity             = 0u;
                    auto virtual_wo_vec                 = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr_sz                 += std::distance(std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz), 
                                                                         std::copy(data_arr[i].lhs.begin(), data_arr[i].lhs.end(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));

                        cuda_ptr_arr_sz                 += std::distance(std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz),
                                                                         std::copy(data_arr[i].rhs.begin(), data_arr[i].rhs.end(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));

                        cuda_ptr_arr[cuda_ptr_arr_sz++] = data_arr[i].dst;
                        total_complexity                += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_pacm_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;

                        auto work_order = [lhs_arr_cpy      = std::move(data_arr[i].lhs),
                                           rhs_arr_cpy      = std::move(data_arr[i].rhs),
                                           dst              = data_arr[i].dst,
                                           dispatch_control = data_arr[i].dispatch_control]() noexcept{

                            if constexpr(DEBUG_MODE_FLAG){
                                if (lhs_arr_cpy.size() != PACM_ACM_SZ){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                }

                                if (rhs_arr_cpy.size() != PACM_ACM_SZ){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                }
                            }

                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::forward_pacm(dst, lhs_arr_cpy.data(), rhs_arr_cpy.data(), dispatch_control));
                        };

                        auto virtual_wo = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(std::move(work_order)));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                dg::vector<host_ptr_t> lhs;
                dg::vector<host_ptr_t> rhs;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(std::move_iterator<HostResolutorArgument *> arg_data_arr, size_t sz) noexcept{

                    HostResolutorArgument * data_arr    = arg_data_arr.base();
                    const size_t DISPATCH_ARR_CAP       = (PACM_ACM_SZ + PACM_ACM_SZ + 1u) * sz;
                    size_t host_ptr_arr_sz              = 0u;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(DISPATCH_ARR_CAP);
                    size_t total_complexity             = 0u;
                    auto virtual_wo_vec                 = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr_sz                 += std::distance(std::next(host_ptr_arr.get(), host_ptr_arr_sz),
                                                                         std::copy(data_arr[i].lhs.begin(), data_arr[i].lhs.end(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));

                        host_ptr_arr_sz                 += std::distance(std::next(host_ptr_arr.get(), host_ptr_arr_sz),
                                                                         std::copy(data_arr[i].rhs.begin(), data_arr[i].rhs.end(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));

                        host_ptr_arr[host_ptr_arr_sz++] = data_arr[i].dst;
                        total_complexity                += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_pacm_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;

                        auto work_order = [lhs_arr_cpy      = std::move(data_arr[i].lhs),
                                           rhs_arr_cpy      = std::move(data_arr[i].rhs),
                                           dst              = data_arr[i].dst,
                                           dispatch_control = data_arr[i].dispatch_control]() noexcept{
                            
                            if constexpr(DEBUG_MODE_FLAG){
                                if (lhs_arr_cpy.size() != PACM_ACM_SZ){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                }

                                if (rhs_arr_cpy.size() != PACM_ACM_SZ){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                }
                            }

                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_pacm(dst, lhs_arr_cpy.data(), rhs_arr_cpy.data(), dispatch_control));
                        };

                        auto virtual_wo = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(std::move(work_order)));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->add(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                device_id_t dst_region_device_id;
                dg::vector<uma_ptr_t> lhs_region_rcu_addr_vec;
                dg::vector<device_id_t> lhs_region_device_id_vec;
                dg::vector<uma_ptr_t> rhs_region_rcu_addr_vec;
                dg::vector<device_id_t> rhs_region_device_id_vec;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const{
                    reflector(dst_region_rcu_addr, dst_region_device_id, lhs_region_rcu_addr_vec, lhs_region_device_id_vec,
                              rhs_region_rcu_addr_vec, rhs_region_device_id_vec, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector){
                    reflector(dst_region_rcu_addr, dst_region_device_id, lhs_region_rcu_addr_vec, lhs_region_device_id_vec,
                              rhs_region_rcu_addr_vec, rhs_region_device_id_vec, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr_vec, rhs_region_rcu_addr_vec);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                dg::vector<uma_ptr_t> lhs_vec;
                dg::vector<uma_ptr_t> rhs_vec;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard_x mem_grd(key.dst_region_rcu_addr, key.lhs_region_rcu_addr_vec, key.rhs_region_rcu_addr_vec);

                    auto dst_umamap_reacquirer                      = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_raii_initialize());
                    auto lhs_umamap_reacquirer                      = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(PACM_ACM_SZ));
                    auto rhs_umamap_reacquirer                      = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(PACM_ACM_SZ)); 

                    auto dst_vmamap_remapper                        = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto lhs_vmamap_remapper                        = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_fixedsize_raii_initialize(PACM_ACM_SZ));
                    auto rhs_vmamap_remapper                        = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_fixedsize_raii_initialize(PACM_ACM_SZ)); 

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&synchronizer));
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz); //optimizables
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz); //optimizables
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_pacm_init_status_nothrow(data_arr[i].dst); 

                        if (dst_init_status != TILE_INIT_STATUS_ADOPTED && dst_init_status != TILE_INIT_STATUS_DECAYED){
                            continue;
                        }

                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_pacm_operatable_memevent_id_nothrow(data_arr[i].dst);

                        if (dst_operatable_id != data_arr[i].expected_ops_id){
                            continue;
                        }

                        dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> dst_lhs(PACM_ACM_SZ);
                        dg::network_tile_member_getsetter::get_pacm_left_descendant_nothrow(data_arr[i].dst, dst_lhs.get());

                        dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> dst_rhs(PACM_ACM_SZ);
                        dg::network_tile_member_getsetter::get_pacm_right_descendant_nothrow(data_arr[i].dst, dst_rhs.get());

                        //I'll change that by using regex later

                        operatable_id_t dst_operatable_fwd_id   = dg::network_tile_member_getsetter::get_pacm_operatable_forward_id_nothrow(data_arr[i].dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_pacm_logit_addr_nothrow(data_arr[i].dst);
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_pacm_observer_array_size_nothrow(data_arr[i].dst);
                        dispatch_control_fat_t dispatch_control = dg::network_tile_member_getsetter::get_pacm_forward_dispatch_control_nothrow(data_arr[i].dst);  
                        
                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_pacm_observer_array_nothrow(data_arr[i].dst, dst_observer_arr.get());

                        dg::network_stack_allocation::NoExceptAllocation<init_status_t[]> lhs_init_status_arr(PACM_ACM_SZ);

                        if (exception_t err = this->get_src_init_status_arr(dst_lhs.get(), PACM_ACM_SZ, lhs_init_status_arr.get()); dg::network_exception::is_failed(err)){
                            continue;
                        }

                        if (std::find(lhs_init_status_arr.get(), std::next(lhs_init_status_arr.get(), PACM_ACM_SZ),
                                      [](const init_status_t& init_status){return init_status != TILE_INIT_STATUS_INITIALIZED;}) != std::next(lhs_init_status_arr.get(), PACM_ACM_SZ)){
                            continue;
                        }

                        dg::network_stack_allocation::NoExceptAllocation<init_status_t[]> rhs_init_status_arr(PACM_ACM_SZ);

                        if (exception_t err = this->get_src_init_status_arr(dst_rhs.get(), PACM_ACM_SZ, rhs_init_status_arr.get()); dg::network_exception::is_failed(err)){
                            continue;
                        }

                        if (std::find(rhs_init_status_arr.get(), std::next(rhs_init_status_arr.get(), PACM_ACM_SZ),
                                      [](const init_status_t& init_status){return init_status != TILE_INIT_STATUS_INITIALIZED;}) != std::next(rhs_init_status_arr.get(), PACM_ACM_SZ)){
                            continue;
                        }

                        dg::network_stack_allocation::NoExceptAllocation<operatable_id_t[]> lhs_fwd_operatable_id(PACM_ACM_SZ);

                        if (exception_t err = this->get_src_operatable_forward_id_arr(dst_lhs.get(), PACM_ACM_SZ, lhs_fwd_operatable_id.get()); dg::network_exception::is_failed(err)){
                            continue;
                        }

                        dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> lhs_logit_umaptr_arr(PACM_ACM_SZ);

                        if (exception_t err = this->get_src_logit_uma_ptr_arr(dst_lhs.get(), PACM_ACM_SZ, lhs_logit_umaptr_arr.get()); dg::network_exception::is_failed(err)){
                            continue;
                        }

                        dg::network_stack_allocation::NoExceptAllocation<operatable_id_t[]> rhs_fwd_operatable_id(PACM_ACM_SZ);

                        if (exception_t err = this->get_src_operatable_forward_id_arr(dst_rhs.get(), PACM_ACM_SZ, rhs_fwd_operatable_id.get()); dg::network_exception::is_failed(err)){
                            continue;
                        }

                        dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> rhs_logit_umaptr_arr(PACM_ACM_SZ);

                        if (exception_t err = this->get_src_logit_uma_ptr_arr(dst_rhs.get(), PACM_ACM_SZ, rhs_logit_umaptr_arr.get()); dg::network_exception::is_failed(err)){
                            continue;
                        }

                        if constexpr(DEBUG_MODE_FLAG){
                            if (data_arr[i].lhs_vec.size() != PACM_ACM_SZ){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            }
                        }

                        if (!std::equal(dst_lhs.get(), std::next(dst_lhs.get(), PACM_ACM_SZ); data_arr[i].lhs_vec.begin())){
                            continue;
                        }

                        if constexpr(DEBUG_MODE_FLAG){
                            if (data_arr[i].rhs_vec.size() != PACM_ACM_SZ){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            }
                        }

                        if (!std::equal(dst_rhs.get(), std::next(dst_rhs.get(), PACM_ACM_SZ); data_arr[i].rhs_vec.begin())){
                            continue;
                        }

                        if (std::find(lhs_fwd_operatable_id.get(), std::next(lhs_fwd_operatable_id.get(), PACM_ACM_SZ),
                                     [&](const operatable_id_t& operatable_id){return operatable_id != dst_operatable_fwd_id;}) != std::next(lhs_fwd_operatable_id.get(), PACM_ACM_SZ)){
                            continue;
                        }

                        if (std::find(rhs_fwd_operatable_id.get(), std::next(rhs_fwd_operatable_id.get(), PACM_ACM_SZ),
                                      [&](const operatable_id_t& operatable_id){return operatable_id != dst_operatable_fwd_id;}) != std::next(rhs_fwd_operatable_id.get(), PACM_ACM_SZ)){
                            continue;
                        }

                        auto devirtualized_dispatch_control = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::devirtualize_pacm_dispatch_control(dispatch_control));
                        
                        if (devirtualized_dispatch_control.dst_vd_id != key.dst_region_vd_id){
                            continue;
                        }

                        if (devirtualized_dispatch_control.lhs_vd_id_vec != key.lhs_region_device_id_vec){
                            continue;
                        }

                        if (devirtualized_dispatch_control.rhs_vd_id_vec != key.rhs_region_device_id_vec){
                            continue;
                        }

                        if (devirtualized_dispatch_control.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        //

                        dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_reacquire(dst_umamap_reacquirer, dst_logit_umaptr));
                        vma_ptr_t dst_vmaptr = dg::network_uma::get_vma_ptr(dst_umamap_reacquirer);
                        dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_remap(dst_vmamap_remapper, dst_vmaptr));

                        //

                        dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_reacquire_range(lhs_umamap_reacquirer, lhs_logit_umaptr_arr.get(), PACM_ACM_SZ));
                        dg::network_stack_allocation::NoExceptAllocation<vma_ptr_t[]> lhs_vma_ptr_arr(PACM_ACM_SZ);
                        dg::network_uma::get_vma_ptr_range(lhs_umamap_reacquirer, lhs_vma_ptr_arr.get(), 0u, PACM_ACM_SZ);
                        dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_remap_range(lhs_vmamap_remapper, lhs_vma_ptr_arr.get(), PACM_ACM_SZ));
                        
                        //

                        dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_reacquire_range(rhs_umamap_reacquirer, rhs_logit_umaptr_arr.get(), PACM_ACM_SZ));
                        dg::network_stack_allocation::NoExceptAllocation<vma_ptr_t[]> rhs_vma_ptr_arr(PACM_ACM_SZ);
                        dg::network_uma::get_vma_ptr_range(rhs_umamap_reacquirer, rhs_vma_ptr_arr.get(), 0u, PACM_ACM_SZ);
                        dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_remap_range(rhs_vmamap_remapper, rhs_vma_ptr_arr.get(), PACM_ACM_SZ));

                        //


                        if (dg::network_dispatch_control::is_cuda_dispatch(devirtualized_dispatch_control.dispatch_platform)){
                            cuda_ptr_t dst_cu_ptr                       = dg::network_vmamap::get_cuda_ptr(dst_vmamap_remapper);
                            dg::vector<cuda_ptr_t> lhs_cu_ptr_vec       = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<cuda_ptr_t>>(PACM_ACM_SZ));
                            dg::vector<cuda_ptr_t> rhs_cu_ptr_vec       = dg::networK_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<cuda_ptr_t>>(PACM_ACM_SZ));

                            dg::network_vmamap::get_cuda_ptr_range(lhs_vmamap_remapper, lhs_cu_ptr_vec.data(), 0u, PACM_ACM_SZ);
                            dg::network_vmamap::get_cuda_ptr_range(rhs_vmamap_remapper, rhs_cu_ptr_vec.data(), 0u, PACM_ACM_SZ);

                            CudaResolutorArgument cuda_resolutor_arg    = make_cuda_resolutor_argument(dst_cu_ptr, std::move(lhs_cu_ptr_vec), std::move(rhs_cu_ptr_vec), devirtualized_dispatch_control.tileops_cuda_dispatch_control);
                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), std::move(cuda_resolutor_arg));
                        } else if (dg::network_dispatch_control::is_host_dispatch(devirtualized_dispatch_control.dispatch_platform)){
                            host_ptr_t dst_host_ptr                     = dg::network_vmamap::get_host_ptr(dst_vmamap_remapper);
                            dg::vector<host_ptr_t> lhs_host_ptr_vec     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<host_ptr_t>>(PACM_ACM_SZ));
                            dg::vector<host_ptr_t> rhs_host_ptr_vec     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::vector<host_ptr_t>>(PACM_ACM_SZ));

                            dg::network_vmamap::get_host_ptr_range(lhs_vmamap_remapper, lhs_host_ptr_vec.data(), 0u, PACM_ACM_SZ);
                            dg::network_vmamap::get_host_ptr_range(rhs_vmamap_remapper, rhs_host_ptr_vec.data(), 0u, PACM_ACM_SZ);

                            HostResolutorArgument host_resolutor_arg    = make_host_resolutor_argument(dst_host_ptr, std::move(lhs_host_ptr_vec), std::move(rhs_host_ptr_vec), devirtualized_dispatch_control.tileops_host_dispatch_control);

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), std::move(host_resolutor_arg));
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(), 
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }
                        }

                        dg::network_tile_member_getsetter::set_pacm_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);
                    }
                }
            };
    };

    //clear
    class ForwardDoExtnSrcSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<Request<external_virtual_memory_event_t>>> request_box;
            const std::shared_ptr<UnifiedMemoryIPRetrieverInterface> uma_ip_retriever;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoExtnSrcSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<Request<external_virtual_memory_event_t>>> request_box,
                                            std::shared_ptr<UnifiedMemoryIPRetrieverInterface> uma_ip_retriever,
                                            std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                            size_t request_delivery_capacity,
                                            size_t radxfetch_vectorization_sz,
                                            size_t region_vectorization_sz,
                                            size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                       uma_ip_retriever(std::move(uma_ip_retriever)),
                                                                                       host_async_device(std::move(host_async_device)),
                                                                                       request_delivery_capacity(request_delivery_capacity),
                                                                                       radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                       region_vectorization_sz(region_vectorization_sz),
                                                                                       forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrc_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = 1u;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz); 
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_extnsrc_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.uma_ip_retriever         = this->uma_ip_retriever.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_extnsrc_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.dst_vd_id             = dispatch_radix_arg_arr[i]->dst_vd_id;
                        resolutor_key_arg.src_vd_id             = dispatch_radix_arg_arr[i]->src_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;   
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_extnsrc_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_extnsrc_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_extnsrc_forward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_extnsrc_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extnsrc_forward_dispatch(dispatch_control));
                                    dispatch_radix.dst_vd_id            = dispatch_info.dst_vd_id;
                                    dispatch_radix.src_vd_id            = dispatch_info.src_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                host_ptr_t src;
                host_ptr_t cpy_dst;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_vec_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> host_ptr_vec(host_ptr_vec_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_vec[i * 3]     = data_arr[i].dst;
                        host_ptr_vec[i * 3 + 1] = data_arr[i].src;
                        host_ptr_vec[i * 3 + 2] = data_arr[i].cpy_dst;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(MEMCPY)).runtime_complexity;

                        auto work_order         = [e = data_arr[i]]() noexcept{
                            size_t cpy_sz = dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(e.dispatch_control)).dst_byte_size;
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_mono(e.dst, e.src, e.dispatch_control));
                            dg::network_exception_handler::nothrow_log(dg::network_memops_clib::memcpy_host_to_host(e.cpy_dst, e.dst, cpy_sz));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_vec.get(), std::next(host_ptr_vec.get(), host_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<Request<external_virtual_memory_event_t>> * request_delivery_handle;
                UnifiedMemoryIPRetrieverInterface * uma_ip_retriever;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    dg::network_stack_allocation::NoExceptAllocation<std::optional<ExtnSrxTile>[]> extnsrx_tile_arr(sz);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 2u>{}));
                    auto dst_logit_vmamap_reacquirer                = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_logit_vmamap_reacquirer                = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto synchronizer                               = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto restrict_synchronizer                      = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &restrict_synchronizer;

                    size_t trimmed_vectorization_sz                 = std::min(this->vectorization_sz, sz);
                    size_t hvdh_allocation_cost                     = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hvdh_mem(hvdh_allocation_cost);
                    auto host_vectorizer_delivery_handle            = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_vectorization_sz, hvdh_mem.get())); 

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]        = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                       = dg::network_tile_member_getsetter::get_extnsrc_descendant_nothrow(dst);
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_extnsrc_init_status_nothrow(dst);
                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_extnsrc_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_fwd_operatable_id   = dg::network_tile_member_getsetter::get_extnsrc_operatable_forward_id_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_extnsrc_forward_dispatch_control_nothrow(dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_extnsrc_logit_addr_nothrow(dst);
                        uma_ptr_t dst_counterpart               = dg::network_tile_member_getsetter::get_extnsrc_counterpart_nothrow(dst);
                        size_t dst_logit_bsz                    = dg::network_tile_member_getsetter::get_extnsrc_logit_byte_size_nothrow(dst);

                        std::expected<operatable_id_t, exception_t> src_fwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(src);
                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src); 

                        if (!src_fwd_operatable_id.has_value() || !src_init_status.has_value() || !src_logit_umaptr.has_value()){
                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_DECAYED && dst_init_status != TILE_INIT_STATUS_ADOPTED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_fwd_operatable_id != src_fwd_operatable_id.value()){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extnsrc_forward_control(dispatch_control));

                        if (dispatch_info.dst_vd_id != key.dst_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_vd_id != key.src_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        extnsrx_tile_arr[i]     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<ExtnSrxTile>());
                        auto extnsrc_metadata   = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<ExtnSrcMetadata>());
                        dg::network_tile_member_getsetter::burn_extnsrc_metadata_nothrow(dst, extnsrc_metadata);
                        static_cast<ExtnSrxMetadata&>(extnsrx_tile_arr[i].value()) = dg::network_tile_member_getsetter::extnsrc_metadata_to_extnsrx_metadata_nothrow(extnsrc_metadata); 

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{dst_logit_umaptr, dispatch_info.dst_vd_id}, 
                                                                                                           {src_logit_umaptr.value(), dispatch_info.src_vd_id}});

                        vma_ptr_t dst_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(dst_logit_vmamap_reacquirer, dst_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);

                        if(dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            extnsrx_tile_arr[i]->logit          = dg::string(dst_logit_bsz, ' '); //TODOs: optimizables - alright - its hard to optimize this yet - I'll be back
                            host_ptr_t cpy_dst_addr             = extnsrx_tile_arr[i]->logit.data();
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.dst              = dg::network_vmamap::get_host_ptr(dst_logit_vmamap_reacquirer);
                            host_resolutor_arg.src              = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.cpy_dst          = cpy_dst_addr
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_vectorizer_delivery_handle.get(), host_resolutor_arg.src, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_extnsrc_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);
                    }

                    dg::network_producer_consumer::delvrsrv_clear(host_vectorizer_delivery_handle.get());
                    synchronizer.sync();

                    for (size_t i = 0u; i < sz; ++i){
                        if (!extnsrx_tile_arr[i].has_value()){
                            continue;
                        }

                        auto rq = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<Request<external_virtual_memory_event_t>>());
                        std::expected<Address, exception_t> to_addr = this->uma_ip_retriver->ip(extnsrx_tile_arr[i]->forward_shadow);

                        if (!to_addr.has_value()){
                            dg::network_log::log_user_tile_error(extnsrx_tile_arr[i]->user_id, extnsrx_tile_arr[i]->forward_shadow, dg::network_exception::verbose(to_addr.error()));
                            continue;
                        }

                        rq.requestee                                    = to_addr.value();
                        dg::string serialized                           = dg::network_compact_serializer::serialize<dg::string>(extnsrx_tile_arr[i].value()); //TODOs: optimizables, we are not allowed to do memory iterations (this is a very stingent requirements) 
                        external_virtual_memory_event_t inject_event    = dg::network_exception_handler::nothrow_log(dg::network_external_memcommit_factory::make_event_shadow_injection(extnsrx_tile_arr[i]->forward_shadow, TILE_KIND_EXTNSRX, std::move(serialized)));
                        external_virtual_memory_event_t notify_event    = dg::network_exception_handler::nothrow_log(dg::network_external_memcommit_factory::make_event_forward_do_signal(extnsrx_tile_arr[i]->counterpart, data_arr[i].expected_ops_id));
                        external_virtual_memory_event_t event           = dg::network_exception_handler::nothrow_log(dg::network_external_memcommit_factory::make_event_sequential(std::move(inject_event), std::move(notify_event)));
                        rq.content                                      = std::move(event);
                        rq.retry_count                                  = extnsrx_tile_arr[i]->retry_count;
                        rq.exception_handler                            = dg::network_exception::make_exception_handler_from_lambda([user_id = extnsrx_tile_arr[i]->user_id, notifying_addr = extnsrx_tile_arr[i]->forward_shadow](exception_t err) noexcept{
                            if (dg::network_exception::is_failed(err)){
                                dg::network_log::log_user_tile_error(user_id, notifying_addr, dg::network_exception::verbose(err)); //we offload the responsibility of tile transmit here - if the transmit is not thru - then it's forever lost - its an ok assumption to reduce complexity of implementation and usually packet lost happens because of incorrect load balancing management (we must reconsider this to avoid forward of multiple leafs)
                            }
                        });

                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(rq));
                    }
                }
            };
    };

    //clear
    class ForwardDoExtnSrxSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrx_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    //clear
    class ForwardDoExtnDstSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoExtnDstSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                            std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                            size_t request_delivery_capacity,
                                            size_t radxfetch_vectorization_sz,
                                            size_t region_vectorization_sz,
                                            size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                       host_async_device(std::move(host_async_device)),
                                                                                       cuda_async_device(std::move(cuda_async_device)),
                                                                                       request_delivery_capacity(request_delivery_capacity),
                                                                                       radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                       region_vectorization_sz(region_vectorization_sz),
                                                                                       forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndst_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz); 

                const size_t EVENT_SCALE_FACTOR             = dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost); 
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost); 
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_extndst_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memregion_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i); 

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz); 
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src); 

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size(), static_cast<size_t>(dg::network_uma::memregion_size())));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_extndst_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.dst_vd_id             = dispatch_radix_arg_arr[i]->dst_vd_id;
                        resolutor_key_arg.src_vd_id             = dispatch_radix_arg_arr[i]->src_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::ConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_extndst_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_extndst_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_extndst_forward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_extndst_forward_shadow_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extndst_forward_dispatch(dispatch_control));
                                    dispatch_radix.dst_vd_id            = dispatch_info.dst_vd_id;
                                    dispatch_radix.src_vd_id            = dispatch_info.src_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t dst;
                cuda_ptr_t src;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 2]     = data_arr[i].dst;
                        cuda_ptr_arr[i * 2 + 1] = data_arr[i].src;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::forward_mono(e.dst, e.src, e.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                host_ptr_t src;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 2]     = data_arr[i].dst;
                        host_ptr_arr[i * 2 + 1] = data_arr[i].src;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_mono(e.dst, e.src, e.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //word_size memcmp + has_unique_object_representations_v 
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::ConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                size_t vectorization_sz; 

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                  = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 2u>{}));
                    auto dst_logit_vmamap_reacquirer        = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize()); 
                    auto src_logit_vmamap_reacquirer        = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                  = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer         = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer)); 
                    auto cuda_resolutor                     = InternalCudaResolutor{};
                    cuda_resolutor.async_device             = this->cuda_async_device;
                    cuda_resolutor.synchronizer             = &cuda_synchronizer;
                    cuda_resolutor.restrict_synchronizer    = &cuda_restrict_synchronizer;

                    auto host_synchronizer                  = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer         = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));                     
                    auto host_resolutor                     = InternalHostResolutor{};
                    host_resolutor.async_device             = this->host_async_device;
                    host_resolutor.synchronizer             = &host_synchronizer;
                    host_resolutor.restrict_synchronizer    = &restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz    = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost              = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle               = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz    = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost              = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle               = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]        = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                       = dg::network_tile_member_getsetter::get_extndst_forward_shadow_nothrow(dst);
                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_extndst_operatable_memevent_id_nothrow(dst);
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_extndst_init_status_nothrow(dst);
                        operatable_id_t dst_fwd_operatable_id   = dg::network_tile_member_getsetter::get_extndst_operatable_forward_id_nothrow(dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_extndst_logit_addr_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_extndst_forward_dispatch_control_nothrow(dst);
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_extndst_observer_array_size_nothrow(dst);

                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(dg::network_tile_metadata::MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_extndst_observer_array_nothrow(dst, dst_observer_arr.get());

                        if (dst_init_status != TILE_INIT_STATUS_DECAYED && dst_init_status != TILE_INIT_STATUS_ADOPTED){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> extnsrx_ptr_access = dg::network_tile_member_access::safecthrow_extnsrx_ptr_access(src);

                        if (!extnsrx_ptr_access.has_value()){
                            continue;
                        } 

                        operatable_id_t src_fwd_operatable_id   = dg::network_tile_member_getsetter::get_extnsrx_operatable_forward_id_nothrow(src);
                        init_status_t src_init_status           = dg::network_tile_member_getsetter::get_extnsrx_init_status_nothrow(src);
                        uma_ptr_t src_logit_umaptr              = dg::network_tile_member_getsetter::get_extnsrx_logit_addr_nothrow(src);

                        if (src_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_fwd_operatable_id != src_fwd_operatable_id){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extndst_forward_dispatch(dispatch_control));

                        if (dispatch_info.dst_vd_id != key.dst_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_vd_id != key.src_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{dst_logit_umaptr, dispatch_info.dst_vd_id}, 
                                                                                                           {src_logit_umaptr, dispatch_info.src_vd_id}});

                        vma_ptr_t dst_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{}); 

                        dg::network_vmamap::region_remapper_remap_nothrow(dst_logit_vmamap_reacquirer, dst_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.dst              = dg::network_vmamap::get_cuda_ptr(dst_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.src              = dg::network_vmamap::get_cuda_ptr(src_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg.src, cuda_resolutor_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.dst              = dg::network_vmamap::get_host_ptr(dst_logit_vmamap_reacquirer);
                            host_resolutor_arg.src              = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg.src, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_extndst_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(), 
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }
                        }
                    }
                }
            };
    };

    //clear
    class ForwardDoExtnDsxSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndsx_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    //clear
    class ForwardDoCritSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz; 

        public:

            ForwardDoCritSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                         std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                         std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                         size_t radxfetch_vectorization_sz,
                                         size_t request_delivery_capacity,
                                         size_t region_vectorization_sz,
                                         size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                    host_async_device(std::move(host_async_device)),
                                                                                    cuda_async_device(std::move(cuda_async_device)),
                                                                                    radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                    request_delivery_capacity(request_delivery_capacity),
                                                                                    region_vectorization_sz(region_vectorization_sz),
                                                                                    forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_crit_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS:
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = MAX_OBSERVER_ARR_SZ + 1u;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_crit_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_crit_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.src_logit_vd_id       = dispatch_radix_arg_arr[i]->src_logit_vd_id;
                        resolutor_key_arg.dst_logit_vd_id       = dispatch_radix_arg_arr[i]->dst_logit_vd_id;
                        resolutor_key_arg.dst_crit_vd_id        = dispatch_radix_arg_arr[i]->dst_crit_vd_id;
                        resolutor_key_arg.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t src_logit_vd_id;
                device_id_t dst_logit_vd_id;
                device_id_t dst_crit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_crit_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_crit_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_crit_forward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_crit_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_crit_forward_dispatch(dispatch_control));
                                    dispatch_radix.src_logit_vd_id      = dispatch_info.src_logit_vd_id;
                                    dispatch_radix.dst_logit_vd_id      = dispatch_info.dst_logit_vd_id;
                                    dispatch_radix.dst_crit_vd_id       = dispatch_info.dst_crit_vd_id;
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t dst_logit_ptr;
                cuda_ptr_t src_logit_ptr;
                cuda_ptr_t dst_crit_ptr;
                cuda_ptr_t dst_grad_ptr;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 4;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 4]     = data_arr[i].dst_logit_ptr;
                        cuda_ptr_arr[i * 4 + 1] = data_arr[i].src_logit_ptr;
                        cuda_ptr_arr[i * 4 + 2] = data_arr[i].dst_crit_ptr;
                        cuda_ptr_arr[i * 4 + 3] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_crit_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [arg = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::forward_crit(arg.dst_logit_ptr, arg.src_logit_ptr, 
                                                                                                                   arg.dst_crit_ptr, arg.dst_grad_ptr, 
                                                                                                                   arg.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        virtual_wo_vec->add(std::move(virtual_wo));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst_logit_ptr;
                host_ptr_t src_logit_ptr;
                host_ptr_t dst_crit_ptr;
                host_ptr_t dst_grad_ptr;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 4;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 4]     = data_arr[i].dst_logit_ptr;
                        host_ptr_arr[i * 4 + 1] = data_arr[i].src_logit_ptr;
                        host_ptr_arr[i * 4 + 2] = data_arr[i].dst_crit_ptr;
                        host_ptr_arr[i * 4 + 3] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_crit_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [arg = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_crit(arg.dst_logit_ptr, arg.src_logit_ptr, 
                                                                                                                   arg.dst_crit_ptr, arg.dst_grad_ptr, 
                                                                                                                   arg.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        virtual_wo_vec->add(std::move(virtual_wo));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: word size cmp + has_unique_object_representations_v
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t dst_logit_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_crit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_logit_vd_id, src_logit_vd_id, dst_crit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_logit_vd_id, src_logit_vd_id, dst_crit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 4u>{}));
                    auto dst_logit_vmamap_reacquirer                = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_logit_vmamap_reacquirer                = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto dst_crit_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto dst_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]        = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                       = dg::network_tile_member_getsetter::get_crit_descendant_nothrow(dst);
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_crit_init_status_nothrow(dst);
                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_crit_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_operatable_fwd_id   = dg::network_tile_member_getsetter::get_crit_operatable_forward_id_nothrow(dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_crit_logit_addr_nothrow(dst);
                        uma_ptr_t dst_crit_umaptr               = dg::network_tile_member_getsetter::get_crit_crit_addr_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr               = dg::network_tile_member_getsetter::get_crit_grad_addr_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_crit_forward_dispatch_control_nothrow(dst);
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_crit_observer_array_size_nothrow(dst);

                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_crit_observer_array_nothrow(dst, dst_observer_arr.get()); 

                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<operatable_id_t, exception_t> src_operatable_fwd_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src);

                        if (!src_init_status.has_value() || !src_operatable_fwd_id.has_value() || !src_logit_umaptr.has_value()){
                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_ADOPTED && dst_init_status != TILE_INIT_STATUS_DECAYED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_operatable_fwd_id != src_operatable_fwd_id.value()){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_crit_forward_dispatch(dispatch_control)); 

                        if (dispatch_info.dst_logit_vd_id != key.dst_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_logit_vd_id != key.src_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_crit_vd_id != key.dst_crit_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_reacquire_nothrow(umamap_reacquirer, {{dst_logit_umaptr, dispatch_info.dst_logit_vd_id},
                                                                                                 {src_logit_umaptr.value(), dispatch_info.src_logit_vd_id},
                                                                                                 {dst_crit_umaptr, dispatch_info.dst_crit_vd_id},
                                                                                                 {dst_grad_umaptr, dispatch_info.dst_grad_vd_id}});

                        vma_ptr_t dst_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t dst_crit_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});
                        vma_ptr_t dst_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 3u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(dst_logit_vmamap_reacquirer, dst_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_crit_vmamap_reacquirer, dst_crit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dst_grad_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.dst_logit_ptr    = dg::network_vmamap::get_cuda_ptr(dst_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.src_logit_ptr    = dg::network_vmamap::get_cuda_ptr(src_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.dst_crit_ptr     = dg::network_vmamap::get_cuda_ptr(dst_crit_vmamap_reacquirer);
                            cuda_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_cuda_ptr(dst_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg.src_logit_ptr, cuda_resolutor_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.dst_logit_ptr    = dg::network_vmamap::get_host_ptr(dst_logit_vmamap_reacquirer);
                            host_resolutor_arg.src_logit_ptr    = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.dst_crit_ptr     = dg::network_vmamap::get_host_ptr(dst_crit_vmamap_reacquirer);
                            host_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg.src_logit_ptr, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_crit_grad_status_nothrow(dst, TILE_GRAD_STATUS_HAS_VALUE);
                        dg::network_tile_member_getsetter::set_crit_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(),
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }
                        }

                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(dst, expected_ops_id)));
                    }
                }
            };
    };

    //optimizables
    class ForwardDoMsgrFwdSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<EndUserPacket>> eu_packet_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t eu_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoMsgrFwdSingalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<EndUserPacket>> eu_packet_box,
                                            std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                            size_t request_delivery_capacity,
                                            size_t eu_delivery_capacity,
                                            size_t radxfetch_vectorization_sz,
                                            size_t region_vectorization_sz,
                                            size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                       eu_packet_box(std::move(eu_packet_box)),
                                                                                       host_async_device(std::move(host_async_device)),
                                                                                       request_delivery_capacity(request_delivery_capacity),
                                                                                       eu_delivery_capacity(eu_delivery_capacity),
                                                                                       radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                       region_vectorization_sz(region_vectorization_sz),
                                                                                       forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrfwd_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t REQUEST_EVENT_SCALE_FACTOR     = MAX_OBSERVER_ARRAY_SZ;
                size_t max_possible_event_sz                = sz * REQUEST_EVENT_SCALE_FACTOR; 
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost); 
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                const size_t EU_PACKET_SCALE_FACTOR         = 1u;
                size_t max_possible_eu_packet               = sz * EU_PACKET_SCALE_FACTOR;
                size_t trimmed_eu_packet_delivery_capacity  = std::min(this->eu_packet_delivery_capacity, max_possible_eu_packet); 
                size_t epdh_allocation_cost                 = dg::network_producer_consumer::delvrsrv_allocation_cost(this->eu_packet_box.get(), trimmed_eu_packet_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> epdh_mem(epdh_allocation_cost);
                auto eu_packet_delivery_handle              = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->eu_packet_box.get(), trimmed_eu_packet_delivery_capacity, epdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_kv_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_msgrfwd_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst; 
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_producer_consumer::delvrsrv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                         = InternalResolutor{};
                    internal_resolutor.request_delivery_handle      = request_delivery_handle.get();
                    internal_resolutor.eu_packet_delivery_handle    = eu_packet_delivery_handle.get();
                    internal_resolutor.host_async_device            = this->host_async_device.get();
                    internal_resolutor.vectorization_sz             = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz          = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle                 = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_kv_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get())); 

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size())); 
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_msgrfwd_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.dst_vd_id             = dispatch_radix_arg_arr[i]->dst_vd_id;
                        resolutor_key_arg.src_vd_id             = dispatch_radix_arg_arr[i]->src_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_producer_consumer::delvrsrv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_msgrfwd_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_msgrfwd_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_msgrfwd_forward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_msgrfwd_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_msgrfwd_forward_dispatch());
                                    dispatch_radix.dst_vd_id            = dispatch_info.dst_vd_id;
                                    dispatch_radix.src_vd_id            = dispatch_info.src_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix; 
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                host_ptr_t src;
                host_ptr_t cpy_dst;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_vec_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_vec(host_ptr_vec_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_vec[i * 3]     = data_arr[i].dst;
                        host_ptr_vec[i * 3 + 1] = data_arr[i].src;
                        host_ptr_vec[i * 3 + 2] = data_arr[i].cpy_dst;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(MEMCPY)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            size_t cpy_dst_bsz = dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(e.dispatch_control)).dst_byte_size;
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_mono(e.dst, e.src, e.dispatch_control));
                            dg::network_exception_handler::nothrow_log(dg::network_memops_clib::memcpy_host_to_host(e.cpy_dst, e.dst, cpy_dst_bsz));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_vec.get(), std::next(host_ptr_vec.get(), host_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct MsgrFwdData{
                user_id_t user_id;
                uma_ptr_t addr;
                dg::string logit_value;
                Address dst;
                eu_packet_urgency_t urgency;
                uint8_t retry_count;
                eu_packet_comm_t comm; 
            };

            //word_size memcmp + has_unique_object_representations_v
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_producer_consumer::DeliveryHandle<EndUserPacket> * eu_packet_delivery_handle;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                  = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 2u>{}));
                    auto dst_logit_vmamap_reacquirer        = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_logit_vmamap_reacquirer        = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto host_synchronizer                  = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer         = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_resolutor                     = InternalHostResolutor{};
                    host_resolutor.async_device             = this->host_async_device;
                    host_resolutor.synchronizer             = &host_synchronizer;
                    host_resolutor.restrict_synchronizer    = &host_restrict_synchronizer;

                    size_t trimmed_vectorization_sz         = std::min(this->vectorization_sz, sz);
                    size_t hv_allocation_cost               = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_resolutor, trimmed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hv_mem(hv_allocation_cost);
                    auto host_vectorizer                    = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_resolutor, trimmed_vectorization_sz, hv_mem.get())); 

                    auto msgrfwd_outbound_vec               = dg::vector<std::optional<MsgrFwdData>>(sz, std::optional<MsgrFwdData>(std::nullopt));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]        = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                       = dg::network_tile_member_getsetter::get_msgrfwd_descendant_nothrow(dst);
                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_msgrfwd_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_fwd_operatable_id   = dg::network_tile_member_getsetter::get_msgrfwd_operatable_forward_id_nothrow(dst);
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_msgrfwd_init_status_nothrow(dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_msgrfwd_logit_addr_nothrow(dst);
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_msgrfwd_observer_array_size_nothrow(dst);
                        size_t dst_logit_bsz                    = dg::network_tile_member_getsetter::get_msgrfwd_logit_byte_size_nothrow(dst);
                        dst_info_t dst_msgr_info                = dg::network_tile_member_getsetter::get_msgrfwd_dst_info_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_msgrfwd_forward_dispatch_control_nothrow(dst);
                        user_id_t user_id                       = dg::network_tile_member_getsetter::get_msgrfwd_user_id_nothrow(dst);

                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_msgrfwd_observer_array_nothrow(dst, dst_observer_arr.get());

                        std::expected<operatable_id_t, exception_t> src_fwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(src);
                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src);

                        if (!src_fwd_operatable_id.has_value() || !src_init_status.has_value() || !src_logit_umaptr.has_value()){
                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_DECAYED && dst_init_status != TILE_INIT_STATUS_ADOPTED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_fwd_operatable_id != src_fwd_operatable_id.value()){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_msgrfwd_forward_dispatch(dispatch_control));

                        if (dispatch_info.dst_vd_id != key.dst_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_vd_id != key.src_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{dst_logit_umaptr, dispatch_info.dst_vd_id}, 
                                                                                                           {src_logit_umaptr.value(), dispatch_info.src_vd_id}});

                        vma_ptr_t dst_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(dst_logit_vmamap_reacquirer, dst_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);

                        if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){ //we are doing cuda_ptr_t (cutf_ptr_t) -> host_ptr_t
                            auto msgrfwd_data                   = MsgrFwdData{};
                            msgrfwd_data.user_id                = user_id;
                            msgrfwd_data.addr                   = dst;
                            msgrfwd_data.logit_value            = dg::string(dst_logit_bsz, ' '); //TODOs: optimizables
                            msgrfwd_data.dst                    = dst_msgr_info.dst;
                            msgrfwd_data.urgency                = dst_msgr_info.urgency;
                            msgrfwd_data.retry_count            = dst_msgr_info.retry_count;
                            msgrfwd_data.comm                   = dst_msgr_info.comm;
                            host_ptr_t cpylogit_value_ptr       = msgrfwd_data.logit_value.data();
                            msgrfwd_outbound_vec[i]             = std::move(msgrfwd_data);

                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.dst              = dg::network_vmamap::get_host_ptr(dst_logit_vmamap_reacquirer);
                            host_resolutor_arg.src              = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.cpy_dst          = cpylogit_value_ptr;
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_vectorizer.get(), host_resolutor_arg.src, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_msgrfwd_init_status_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(),
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }
                        }
                    }

                    dg::network_producer_consumer::delvrsrv_clear(host_vectorizer.get());
                    host_synchronizer.sync();

                    for (size_t i = 0u; i < sz; ++i){
                        if (!msgrfwd_outbound_vec[i].has_value()){
                            continue;
                        }

                        user_id_t user_id               = msgrfwd_outbound_vec[i]->user_id
                        uma_ptr_t addr                  = msgrfwd_outbound_vec[i]->addr; 
                        EndUserPacket eu_packet         = {};
                        eu_packet.serialization_header  = EUPACKET_MSGRFWD; //serialization header
                        eu_packet.content               = dg::network_compact_serializer::serialize<dg::string>(LogitValue{msgrfwd_outbound_vec[i]->addr, std::move(msgrfwd_outbound_vec[i]->logit_value)}); //TODOs: optimizables - solve hardware cache pollution 
                        eu_packet.dst                   = msgrfwd_outbound_vec[i]->dst;
                        eu_packet.retry_count           = msgrfwd_outbound_vec[i]->retry_count;
                        eu_packet.urgency               = msgrfwd_outbound_vec[i]->urgency;
                        eu_packet.comm                  = msgrfwd_outbound_vec[i]->comm;
                        eu_packet.exception_handler     = dg::network_exception::make_exception_handler_from_lambda([user_id, addr](exception_t err) noexcept{ //TODOs: optimizables
                            if (dg::network_exception::is_failed(err)){
                                dg::network_log::log_user_tile_error(user_id, addr, dg::network_exception::verbose(err));
                            }
                        });

                        dg::network_producer_consumer::delvrsrv_deliver(this->eu_packet_delivery_handle, std::move(eu_packet));
                    }
                }
            };
    };

    //clear
    class ForwardDoMsgrBwdSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t forward_vectorization_sz;

        public:

            ForwardDoMsgrBwdSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                            std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                            std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                            size_t request_delivery_capacity,
                                            size_t radxfetch_vectorization_sz,
                                            size_t region_vectorization_sz,
                                            size_t forward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                       host_async_device(std::move(host_async_device)),
                                                                                       cuda_async_device(std::move(cuda_async_device)),
                                                                                       request_delivery_capacity(request_delivery_capacity),
                                                                                       radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                       region_vectorization_sz(region_vectorization_sz),
                                                                                       forward_vectorization_sz(forward_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrbwd_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = MAX_OBSERVER_ARRAY_SZ;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost); 
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_kv_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_msgrbwd_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_producer_consumer::delvrsrv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.allocator                = &arena_allocator;
                    internal_resolutor.vectorization_sz         = this->forward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz); 
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_kv_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_msgrbwd_tile_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.dst_vd_id             = dispatch_radix_arg_arr[i]->dst_vd_id;
                        resolutor_key_arg.src_vd_id             = dispatch_radix_arg_arr[i]->src_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_producer_consumer::delvrsrv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_msgrbwd_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_msgrbwd_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_DECAYED: [[fallthrough]]:
                            case TILE_INIT_STATUS_ADOPTED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_msgrbwd_forward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_msgrbwd_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_msgrbwd_forward_dispatch(dispatch_control)); 
                                    dispatch_radix.dst_vd_id            = dispatch_info.dst_vd_id;
                                    dispatch_radix.src_vd_id            = dispatch_info.src_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;  
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t dst;
                cuda_ptr_t src;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 2]     = data_arr[i].dst;
                        cuda_ptr_arr[i * 2 + 1] = data_arr[i].src;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::forward_mono(e.dst, e.src, e.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst;
                host_ptr_t src;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 2]     = data_arr[i].dst;
                        host_ptr_arr[i * 2 + 1] = data_arr[i].src;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_forward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::forward_mono(e.dst, e.src, e.dispatch_control));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: word_size memcmp + has_unique_object_representations_v
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t dst_vd_id;
                device_id_t src_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, dst_vd_id, src_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                  = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 2u>{}));
                    auto dst_vmamap_reacquirer              = dg::network_exception_handler::nothrow_log(dg::network_vmamap::remapper_raii_initialize());
                    auto src_vmamap_reacquirer              = dg::network_exception_handler::nothrow_log(dg::network_vmamap::remapper_raii_initialize());

                    auto cuda_synchronizer                  = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer         = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer)); 
                    auto cuda_resolutor                     = InternalCudaResolutor{};
                    cuda_resolutor.async_device             = this->cuda_async_device;
                    cuda_resolutor.synchronizer             = &cuda_synchronizer;
                    cuda_resolutor.restrict_synchronizer    = &cuda_restrict_synchronizer;

                    auto host_synchronizer                  = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer         = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer)); 
                    auto host_resolutor                     = InternalHostResolutor{};
                    host_resolutor.async_device             = this->host_async_device;
                    host_resolutor.synchronizer             = &host_synchronizer;
                    host_resolutor.restrict_synchronizer    = &host_restrict_synchronizer;

                    size_t trimmed_host_vectorization_sz    = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost              = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle               = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_resolutor, trimmed_host_vectorization_sz, hdh_mem.get())); 

                    size_t trimmed_cuda_vectorization_sz    = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost              = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle               = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]        = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        operatable_id_t dst_operatable_id       = dg::network_tile_member_getsetter::get_msgrbwd_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_fwd_operatable_id   = dg::network_tile_member_getsetter::get_msgrbwd_operatable_forward_id_nothrow(dst);
                        init_status_t dst_init_status           = dg::network_tile_member_getsetter::get_msgrbwd_init_status_nothrow(dst);
                        uma_ptr_t dst_logit_umaptr              = dg::network_tile_member_getsetter::get_msgrbwd_logit_addr_nothrow(dst);
                        size_t dst_observer_arr_sz              = dg::network_tile_member_getsetter::get_msgrbwd_observer_array_size_nothrow(dst);
                        uma_ptr_t dst_src                       = dg::network_tile_member_getsetter::get_msgrbwd_descendant_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_msgrbwd_forward_dispatch_control_nothrow(dst);

                        dg::network_stack_allocation::NoExceptAllocation<TileObserver[]> dst_observer_arr(MAX_OBSERVER_ARR_SZ);
                        dg::network_tile_member_getsetter::get_msgrbwd_observer_array_nothrow(dst, dst_observer_arr.get());

                        std::expected<operatable_id_t, exception_t> src_fwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_forward_id(src);
                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src); 

                        if (!src_fwd_operatable_id.has_value() || !src_init_status.has_value() || !src_logit_umaptr.has_value()){
                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_DECAYED && dst_init_status != TILE_INIT_STATUS_ADOPTED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_fwd_operatable_id != src_fwd_operatable_id.value()){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_msgrbwd_forward_dispatch(dispatch_control));

                        if (dispatch_info.dst_vd_id != key.dst_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_vd_id != key.src_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{dst_logit_umaptr, dispatch_info.dst_vd_id}, 
                                                                                                           {src_logit_umaptr.value(), dispatch_info.src_vd_id}});

                        vma_ptr_t dst_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_vmaptr    = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(dst_vmamap_reacquirer, dst_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_vmamap_reacquirer, src_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.dst              = dg::network_vmamap::get_cuda_ptr(dst_vmamap_reacquirer);
                            cuda_resolutor_arg.src              = dg::network_vmamap::get_cuda_ptr(src_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg.src, cuda_resolutor_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.dst              = dg::network_vmamap::get_host_ptr(dst_vmamap_reacquirer);
                            host_resolutor_arg.src              = dg::network_vmamap::get_host_ptr(src_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg.src, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }                        
                        }

                        for (size_t j = 0u; j < dst_observer_arr_sz; ++j){
                            if (!dst_observer_arr[j].notify_addr.has_value()){
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_forward_do_signal(dst_observer_arr[j].observer_addr, expected_ops_id));
                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            } else{
                                auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_forward_do_signal(dst_observer_arr[j].notify_addr.value(),
                                                                                                                                                                        dst_observer_arr[j].observer_addr, expected_ops_id));
                                auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                                dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                            }
                        }

                        dg::network_tile_member_getsetter::set_init_status_msgrbwd_nothrow(dst, TILE_INIT_STATUS_INITIALIZED);
                    }
                }
            };
    };

    //clear
    class ForwardDoImmuSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_immu_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    //clear
    class ForwardDoSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent>{

        private:

            const std::unique_ptr<ForwardDoLeafSignalResolutor> leaf_resolutor;
            const std::unique_ptr<ForwardDoBlkrSignalResolutor> blkr_resolutor;
            const std::unique_ptr<ForwardDoRstrSignalResolutor> rstr_resolutor;
            const std::unique_ptr<ForwardDoMonoSignalResolutor> mono_resolutor;
            const std::unique_ptr<ForwardDoPairSignalResolutor> pair_resolutor;
            const std::unique_ptr<ForwardDoUACMSignalResolutor> uacm_resolutor;
            const std::unique_ptr<ForwardDoPACMSignalResolutor> pacm_resolutor;
            const std::unique_ptr<ForwardDoCritSignalResolutor> crit_resolutor;
            const std::unique_ptr<ForwardDoImmuSignalResolutor> immu_resolutor;
            const std::unique_ptr<ForwardDoPolySignalResolutor> poly_resolutor;
            const std::unique_ptr<ForwardDoExtnSrcSignalResolutor> extnsrc_resolutor;
            const std::unique_ptr<ForwardDoExtnSrxSignalResolutor> extnsrx_resolutor;
            const std::unique_ptr<ForwardDoExtnDstSignalResolutor> extndst_resolutor;
            const std::unique_ptr<ForwardDoExtnDsxSignalResolutor> extndsx_resolutor;
            const std::unique_ptr<ForwardDoMsgrFwdSignalResolutor> msgrfwd_resolutor;
            const std::unique_ptr<ForwardDoMsgrBwdSignalResolutor> msgrbwd_resolutor;
            const size_t kvfeed_vectorization_sz;

        public:

            ForwardDoSignalResolutor(std::unique_ptr<ForwardDoLeafSignalResolutor> leaf_resolutor,
                                     std::unique_ptr<ForwardDoBlkrSignalResolutor> blkr_resolutor,
                                     std::unique_ptr<ForwardDoRstrSignalResolutor> rstr_resolutor,
                                     std::unique_ptr<ForwardDoMonoSignalResolutor> mono_resolutor,
                                     std::unique_ptr<ForwardDoPairSignalResolutor> pair_resolutor,
                                     std::unique_ptr<ForwardDoUACMSignalResolutor> uacm_resolutor,
                                     std::unique_ptr<ForwardDoPACMSignalResolutor> pacm_resolutor,
                                     std::unique_ptr<ForwardDoCritSignalResolutor> crit_resolutor,
                                     std::unique_ptr<ForwardDoImmuSignalResolutor> immu_resolutor,
                                     std::unique_ptr<ForwardDoPolySignalResolutor> poly_resolutor,
                                     std::unique_ptr<ForwardDoExtnSrcSignalResolutor> extnsrc_resolutor,
                                     std::unique_ptr<ForwardDoExtnSrxSignalResolutor> extnsrx_resolutor,
                                     std::unique_ptr<ForwardDoExtnDstSignalResolutor> extndst_resolutor,
                                     std::unique_ptr<ForwardDoExtnDsxSignalResolutor> extndsx_resolutor,
                                     std::unique_ptr<ForwardDoMsgrFwdSignalResolutor> msgrfwd_resolutor,
                                     std::unique_ptr<ForwardDoMsgrBwdSignalResolutor> msgrbwd_resolutor,
                                     size_t kvfeed_vectorization_sz) noexcept: leaf_resolutor(std::move(leaf_resolutor)),
                                                                               blkr_resolutor(std::move(blkr_resolutor)),
                                                                               rstr_resolutor(std::move(rstr_resolutor)),
                                                                               mono_resolutor(std::move(mono_resolutor)),
                                                                               pair_resolutor(std::move(pair_resolutor)),
                                                                               uacm_resolutor(std::move(uacm_resolutor)),
                                                                               pacm_resolutor(std::move(pacm_resolutor)),
                                                                               crit_resolutor(std::move(crit_resolutor)),
                                                                               immu_resolutor(std::move(immu_resolutor)),
                                                                               poly_resolutor(std::move(poly_resolutor)),
                                                                               extnsrc_resolutor(std::move(extnsrc_resolutor)),
                                                                               extnsrx_resolutor(std::move(extnsrx_resolutor)),
                                                                               extndst_resolutor(std::move(extndst_resolutor)),
                                                                               extndsx_resolutor(std::move(extndsx_resolutor)),
                                                                               msgrfwd_resolutor(std::move(msgrfwd_resolutor)),
                                                                               msgrbwd_resolutor(std::move(msgrbwd_resolutor)),
                                                                               kvfeed_vectorization_sz(kvfeed_vectorization_sz){}

            auto is_met_dispatch_requirements(const ForwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<tile_kind_t, exception_t> tile_kind = dg::network_tile_member_getsetter::get_tile_kind(event.dst);

                if (!tile_kind.has_value()){
                    return tile_kind.error();
                }

                switch (tile_kind.value()){
                    case TILE_KIND_LEAF: [[fallthrough]]
                    case TILE_KIND_BLKR: [[fallthrough]]
                    case TILE_KIND_RSTR: [[fallthrough]]
                    case TILE_KIND_MONO: [[fallthrough]]
                    case TILE_KIND_PAIR: [[fallthrough]]
                    case TILE_KIND_UACM: [[fallthrough]]
                    case TILE_KIND_PACM: [[fallthrough]]
                    case TILE_KIND_CRIT: [[fallthrough]]
                    case TILE_KIND_IMMU: [[fallthrough]]
                    case TILE_KIND_POLY: [[fallthrough]]
                    case TILE_KIND_EXTNSRC: [[fallthrough]]
                    case TILE_KIND_EXTNSRX: [[fallthrough]]
                    case TILE_KIND_EXTNDST: [[fallthrough]]
                    case TILE_KIND_EXTNDSX: [[fallthrough]]
                    case TILE_KIND_MSGRFWD: [[fallthrough]]
                    case TILE_KIND_MSGRBWD:
                    {
                        return dg::network_exception::SUCCESS;
                    }
                    default:
                    {
                        return dg::network_exception::BAD_TILE_ACCESS;
                    }
                }
            }

            void push(ForwardDoSignalEvent * event_arr, size_t sz) noexcept{

                auto internal_resolutor                 = InternalResolutor{};

                internal_resolutor.leaf_resolutor       = this->leaf_resolutor.get();
                internal_resolutor.blkr_resolutor       = this->blkr_resolutor.get();
                internal_resolutor.rstr_resolutor       = this->rstr_resolutor.get();
                internal_resolutor.mono_resolutor       = this->mono_resolutor.get();
                internal_resolutor.pair_resolutor       = this->pair_resolutor.get();
                internal_resolutor.uacm_resolutor       = this->uacm_resolutor.get();
                internal_resolutor.pacm_resolutor       = this->pacm_resolutor.get();
                internal_resolutor.crit_resolutor       = this->crit_resolutor.get();
                internal_resolutor.immu_resolutor       = this->immu_resolutor.get();
                internal_resolutor.poly_resolutor       = this->poly_resolutor.get();
                internal_resolutor.extnsrc_resolutor    = this->extnsrc_resolutor.get();
                internal_resolutor.extnsrx_resolutor    = this->extnsrx_resolutor.get();
                internal_resolutor.extndst_resolutor    = this->extndst_resolutor.get();
                internal_resolutor.extndsx_resolutor    = this->extndsx_resolutor.get();
                internal_resolutor.msgrfwd_resolutor    = this->msgrfwd_resolutor.get();
                internal_resolutor.msgrbwd_resolutor    = this->msgrbwd_resolutor.get();

                size_t trimmed_kvfeed_vectorization_sz  = std::min(this->kvfeed_vectorization_sz, sz);
                size_t kvfeed_allocation_cost           = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&internal_resolutor, trimmed_kvfeed_vectorization_sz);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> kvfeed_mem(kvfeed_allocation_cost);
                auto feeder                             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_kv_open_preallocated_raiihandle(&internal_resolutor, trimmed_kvfeed_vectorization_sz, kvfeed_mem.get()));

                for (size_t i = 0u; i < sz; ++i){
                    if constexpr(DEBUG_MODE_FLAG){
                        if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                            std::abort();
                        }
                    }

                    tile_kind_t tile_kind = dg::network_tile_member_getsetter::get_tile_kind_nothrow(event_arr[i].dst);
                    dg::network_producer_consumer::delvrsrv_kv_deliver(feeder.get(), tile_kind, event_arr[i]);
                }
            }
        
        private:
            
            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<tile_kind_t, ForwardDoSignalEvent>{

                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * leaf_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * blkr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * rstr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * mono_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * pair_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * uacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * pacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * crit_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * immu_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * poly_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * extnsrc_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * extnsrx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * extndst_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * extndsx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * msgrfwd_resolutor;
                dg::network_producer_consumer::ConsumerInterface<ForwardDoSignalEvent> * msgrbwd_resolutor;

                void push(const tile_kind_t& tile_kind, std::move_iterator<ForwardDoSignalEvent *> event_arr, size_t sz){

                    switch (tile_kind){
                        case TILE_KIND_LEAF:
                        {
                            this->leaf_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_BLKR:
                        {
                            this->blkr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_RSTR:
                        {
                            this->rstr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MONO:
                        {
                            this->mono_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PAIR:
                        {
                            this->pair_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_UACM:
                        {
                            this->uacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PACM:
                        {
                            this->pacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_CRIT:
                        {
                            this->crit_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_IMMU:
                        {
                            this->immu_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_POLY:
                        {
                            this->poly_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRC:
                        {
                            this->extnsrc_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRX:
                        {
                            this->extnsrx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDST:
                        {
                            this->extndst_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDSX:
                        {
                            this->extndsx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRFWD:
                        {
                            this->msgrfwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRBWD:
                        {
                            this->msgrbwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        default:
                        {
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                            } else{
                                std::unreachable();
                            }
                        }
                    }
                }
            };
    };

    //

    //clear
    class BackwardDoLeafSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t gradupdate_vectorization_sz;

        public:

            BackwardDoLeafSignalResolutor(std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                          std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                          size_t radxfetch_vectorization_sz,
                                          size_t region_vectorization_sz,
                                          size_t gradupdate_vectorization_sz) noexcept: cuda_async_device(std::move(cuda_async_device)),
                                                                                        host_async_device(std::move(host_async_device)),
                                                                                        radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                        region_vectorization_sz(region_vectorization_sz),
                                                                                        gradupdate_vectorization_sz(gradupdate_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_leaf_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                {
                    auto dispatch_radix_fetcher                 = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&dispatch_radix_fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&dispatch_radix_fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_leaf_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i); 

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                 = InternalResolutor{};
                    internal_resolutor.cuda_async_device    = this->cuda_async_device.get();
                    internal_resolutor.host_async_device    = this->host_async_device.get();
                    internal_resolutor.vectorization_sz     = this->gradupdate_vectorization_sz;

                    size_t trimmed_region_vectorization_sz  = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost              = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle         = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_leaf_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.dst_logit_vd_id       = dispatch_radix_arg_arr[i]->dst_logit_vd_id;
                        resolutor_key_arg.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id; 

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }   
                }
            }

        private:

            struct DispatchRadixArgument{
                device_id_t dst_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status               = dg::network_tile_member_getsetter::get_leaf_init_status_nothrow(data_arr[i].root);
                        set_operatable_id_t current_ops_id_set  = dg::network_tile_member_getsetter::get_leaf_operatable_memevent_id_set_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (is_subset_id(data_arr[i].expected_ops_id, current_ops_id_set)){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_leaf_gradupdate_dispatch_control_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_leaf_gradupdate_dispatch(dispatch_control));
                                    dispatch_radix.dst_logit_vd_id      = dispatch_info.logit_vd_id;
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform; 

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t logit_ptr;
                cuda_ptr_t grad_ptr;
                cuda_tileops_dispatch_control_t dispatch_control;
                cuda_write_option_t grad_write_option;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_vec_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_vec(cuda_ptr_vec_sz);
                    size_t total_complexity     = {}; 
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_vec[i * 2]     = data_arr[i].logit_ptr;
                        cuda_ptr_vec[i * 2 + 1] = data_arr[i].grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_gradupdate_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::grad_update(e.logit_ptr, e.grad_ptr, e.dispatch_control, e.write_option)); //TODOs: cuda limitation of kernel dispatches
                        };

                        auto async_task         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(async_task)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_vec.get(), std::next(cuda_ptr_vec.get(), cuda_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t logit_ptr;
                host_ptr_t grad_ptr;
                host_tileops_dispatch_control_t dispatch_control;
                host_write_option_t grad_write_option;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_vec_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_vec(host_ptr_vec_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_vec[i * 2]     = data_arr[i].logit_ptr;
                        host_ptr_vec[i * 2 + 1] = data_arr[i].grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_gradupdate_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::grad_update(e.logit_ptr, e.grad_ptr, e.dispatch_control, e.write_option));
                        };

                        auto async_task         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(async_task)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_vec.get(), std::next(host_ptr_vec.get(), host_ptr_vec_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                device_id_t dst_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, dst_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, dst_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz; 

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{
                    
                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 2u>{}));
                    auto logit_vmamap_reacquirer                    = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto grad_vmamap_reacquirer                     = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, expected_ops_id]             = std::make_tuple(data_arr[i].dst, data_arr[i].expected_ops_id);
                        operatable_id_set_t operatable_id_set   = dg::network_tile_member_getsetter::get_leaf_operatable_memevent_id_set_nothrow(dst); //we are doing compact set by using interval [first, last)
                        init_status_t init_status               = dg::network_tile_member_getsetter::get_leaf_init_status_nothrow(dst);
                        grad_status_t grad_status               = dg::network_tile_member_getsetter::get_leaf_grad_status_nothrow(dst);
                        dispatch_control_t dispatch_control     = dg::network_tile_member_getsetter::get_leaf_gradupdate_dispatch_control_nothrow(dst);
                        uma_ptr_t logit_umaptr                  = dg::network_tile_member_getsetter::get_leaf_logit_addr_nothrow(dst);
                        uma_ptr_t grad_umaptr                   = dg::network_tile_member_getsetter::get_leaf_grad_addr_nothrow(dst);

                        if (init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (!is_subset_id(expected_ops_id, operatable_id_set)){
                            continue;
                        }

                        if (grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_leaf_gradupdate_dispatch(dispatch_control));

                        if (dispatch_info.logit_vd_id != key.dst_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{logit_umaptr, dispatch_info.logit_vd_id}, 
                                                                                                           {grad_umaptr, dispatch_info.grad_vd_id}});

                        vma_ptr_t logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(logit_vmamap_reacquirer, logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(grad_vmamap_reacquirer, grad_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg                 = CudaResolutorArgument{};
                            cuda_resolutor_arg.logit_ptr            = dg::network_vmamap::get_cuda_ptr(logit_vmamap_reacquirer);
                            cuda_resolutor_arg.grad_ptr             = dg::network_vmamap::get_cuda_ptr(grad_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control     = dispatch_info.tileops_cuda_dispatch_control;
                            cuda_resolutor_arg.grad_write_option    = CUDA_TILEOPS_OPERATION_ZERO;

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg                 = HostResolutorArgument{};
                            host_resolutor_arg.logit_ptr            = dg::network_vmamap::get_host_ptr(logit_vmamap_reacquirer);
                            host_resolutor_arg.grad_ptr             = dg::network_vmamap::get_host_ptr(grad_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control     = dispatch_info.tileops_host_dispatch_control;
                            host_resolutor_arg.grad_write_option    = HOST_TILEOPS_OPERATION_ZERO;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_leaf_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED); //this guarantees pointer restriction - we relax this hacky maneuver for now
                    }
                }
            };
    };

    //clear
    class BackwardDoMonoSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;

        public:

            BackwardDoMonoSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                          std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                          std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                          size_t request_delivery_capacity,
                                          size_t radxfetch_vectorization_sz,
                                          size_t region_vectorization_sz,
                                          size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                      cuda_async_device(std::move(cuda_async_device)),
                                                                                      host_async_device(std::move(host_async_device)),
                                                                                      request_delivery_capacity(request_delivery_capacity),
                                                                                      radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                      region_vectorization_sz(region_vectorization_sz),
                                                                                      backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_mono_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = 1u;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_mono_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = AddressFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->backward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr              = dg::network_tile_member_getsetter::get_mono_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key                  = ResolutorKeyArgument{};
                        resolutor_key.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key.src_grad_vd_id        = dispatch_radix_arg_arr[i]->src_grad_vd_id;
                        resolutor_key.src_logit_vd_id       = dispatch_radix_arg_arr[i]->src_logit_vd_id;
                        resolutor_key.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val                  = ResolutorValueArgument{};
                        resolutor_arg.dst                   = event_arr[i].dst;
                        resolutor_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key, resolutor_val);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_mono_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_mono_operatable_memevent_id_nothrow(data_arr[i].root);  

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_mono_backward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_mono_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_mono_backward_dispatch(dispatch_control));
                                    dispatch_radix.src_grad_vd_id       = dispatch_info.src_grad_vd_id;
                                    dispatch_radix.src_logit_vd_id      = dispatch_info.src_logit_vd_id;
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t src_grad_addr;
                cuda_ptr_t src_logit_addr;
                cuda_ptr_t dst_grad_addr;
                grad_status_t src_grad_status;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 3]     = data_arr[i].src_grad_addr;
                        cuda_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_addr;
                        cuda_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_addr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_mono(e.src_grad_addr, e.src_logit_addr, e.dst_grad_addr, 
                                                                                                                    e.dispatch_control, convert_grad_status_to_cuda_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order)); 
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t src_grad_addr;
                host_ptr_t src_logit_addr;
                host_ptr_t dst_grad_addr;
                grad_status_t src_grad_status;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 3]     = data_arr[i].src_grad_addr;
                        host_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_addr;
                        host_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_addr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_mono(e.src_grad_addr, e.src_logit_addr, e.dst_grad_addr, 
                                                                                                                    e.dispatch_control, convert_grad_status_to_host_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: word_size memcmp + has_unique_object_representations_v
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                              = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 3u>{}));
                    auto src_grad_vmamap_reacquirer                     = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_logit_vmamap_reacquirer                    = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto dst_grad_vmamap_reacquirer                     = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                        = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device                = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer                = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer       = &cuda_restrict_synchronizer;  

                    auto host_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                        = InternalHostResolutor{};
                    host_internal_resolutor.async_device                = this->host_async_device;
                    host_internal_resolutor.synchronizer                = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer       = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]            = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                           = dg::network_tile_member_getsetter::get_mono_descendant_nothrow(dst);
                        operatable_id_t dst_operatable_id           = dg::network_tile_member_getsetter::get_mono_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_bwd_operatable_id       = dg::network_tile_member_getsetter::get_mono_operatable_backward_id_nothrow(dst);
                        init_status_t dst_init_status               = dg::network_tile_member_getsetter::get_mono_init_status_nothrow(dst);
                        grad_status_t dst_grad_status               = dg::network_tile_member_getsetter::get_mono_grad_status_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr                   = dg::network_tile_member_getsetter::get_mono_grad_addr_nothrow(dst);
                        dispatch_control_t dispatch_control         = dg::network_tile_member_getsetter::get_mono_backward_dispatch_control_nothrow(dst);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_mono_signal_smph_addr_nothrow(dst);

                        std::expected<operatable_id_t, exception_t> src_bwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_backward_id(src);
                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<uma_ptr_t, exception_t> src_grad_umaptr               = dg::network_tile_member_getsetter::get_tile_grad_addr(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src);
                        std::expected<grad_status_t, exception_t> src_grad_status           = dg::network_tile_member_getsetter::get_tile_grad_status(src);

                        if (!src_bwd_operatable_id.has_value() || !src_init_status.has_value() || !src_grad_umaptr.has_value()
                            || !src_logit_umaptr.has_value() || !src_grad_status.has_value()){

                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_bwd_operatable_id != src_bwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_mono_backward_dispatch(dispatch_control));

                        if (dispatch_info.src_grad_vd_id != key.src_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_logit_vd_id != key.src_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_reacquire_nothrow(umamap_reacquirer, {{src_grad_umaptr.value(), dispatch_info.src_grad_vd_id},
                                                                                                 {src_logit_umaptr.value(), dispatch_info.src_logit_vd_id},
                                                                                                 {dst_grad_umaptr, dispatch_info.dst_grad_vd_id}});

                        vma_ptr_t src_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t dst_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(src_grad_vmamap_reacquirer, src_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dst_grad_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.src_grad_addr    = dg::network_vmamap::get_cuda_ptr(src_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_logit_addr   = dg::network_vmamap::get_cuda_ptr(src_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.dst_grad_addr    = dg::network_vmamap::get_cuda_ptr(dst_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_grad_status  = src_grad_status.value();
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg.src_logit_addr, cuda_resolutor_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.src_grad_addr    = dg::network_vmamap::get_host_ptr(src_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_logit_addr   = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.dst_grad_addr    = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_grad_status  = src_grad_status.value();
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg.src_logit_addr, host_resolutor_arg); 
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_mono_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                        exception_t src_gradstat_set_err = dg::network_tile_member_getsetter::set_tile_grad_status(src, TILE_GRAD_STATUS_HAS_VALUE);

                        if (dg::network_exception::is_failed(src_gradstat_set_err)){
                            (void) src_gradstat_set_err; //
                        }

                        if (!signal_smph_addr.has_value()){
                            auto decay_signal_event = dg::network_memcommit_factory::vitualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(src, expected_ops_id));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        } else{
                            auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_backward_do_signal(signal_smph_addr.value(), src, expected_ops_id));
                            auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        }
                    }
                }
            };
    };

    //clear
    class BackwardDoBlkrSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_blkr_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{
                
                (void) event_arr;
            };
    };

    class BackwardDoRstrSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

    };

    //clear
    class BackwardDoPairSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<uma_ptr_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;

        public:

            BackwardDoPairSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<uma_ptr_t>> request_box,
                                          std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                          std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                          size_t request_delivery_capacity,
                                          size_t radxfetch_vectorization_sz,
                                          size_t region_vectorization_sz,
                                          size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                      cuda_async_device(std::move(cuda_async_device)),
                                                                                      host_async_device(std::move(host_async_device)),
                                                                                      request_delivery_capacity(request_delivery_capacity),
                                                                                      radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                      region_vectorization_sz(region_vectorization_sz),
                                                                                      backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pair_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = 2u;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity); 
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr              = dg::network_tile_member_getsetter::get_pair_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr              = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg                  = AddressFetcherArgument{};
                        fetch_arg.root                  = event_arr[i].dst;
                        fetch_arg.expected_ops_id       = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr         = std::next(dispatch_radix_arg_arr.get(), i); 

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->backward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> lhs_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->lhs);
                        std::expected<uma_ptr_t, exception_t> rhs_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->rhs);

                        if (!lhs_rcu_addr.has_value() || !rhs_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr              = dg::network_tile_member_getsetter::get_pair_rcu_addr_nothrow(event_arr[i].dst); //assumption: descendant_arr[i].has_value() => safe access

                        auto resolutor_key                  = ResolutorKeyArgument{};
                        resolutor_key.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key.lhs_region_rcu_addr   = dg::memult::region(lhs_rcu_addr.value(), lck_region_sz);
                        resolutor_key.rhs_region_rcu_addr   = dg::memult::region(rhs_rcu_addr.value(), lck_region_sz);
                        resolutor_key.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key.lhs_logit_vd_id       = dispatch_radix_arg_arr[i]->lhs_logit_vd_id;
                        resolutor_key.lhs_grad_vd_id        = dispatch_radix_arg_arr[i]->lhs_grad_vd_id;
                        resolutor_key.rhs_logit_vd_id       = dispatch_radix_arg_arr[i]->rhs_logit_vd_id;
                        resolutor_key.rhs_grad_vd_id        = dispatch_radix_arg_arr[i]->rhs_grad_vd_id;
                        resolutor_key.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val                  = ResolutorValueArgument{};
                        resolutor_val.dst                   = event_arr[i].dst;
                        resolutor_val.lhs                   = dispatch_radix_arg_arr[i]->lhs;
                        resolutor_val.rhs                   = dispatch_radix_arg_arr[i]->rhs;
                        resolutor_val.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key, resolutor_val);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t lhs;
                uma_ptr_t rhs;
                device_id_t dst_grad_vd_id;
                device_id_t lhs_logit_vd_id;
                device_id_t lhs_grad_vd_id;
                device_id_t rhs_logit_vd_id;
                device_id_t rhs_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_pair_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_pair_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_pair_backward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.lhs                  = dg::network_tile_member_getsetter::get_pair_left_descendant_nothrow(data_arr[i].root);
                                    dispatch_radix.rhs                  = dg::network_tile_member_getsetter::get_pair_right_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_backward_pair_dispatch(dispatch_control));
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                    dispatch_radix.lhs_logit_vd_id      = dispatch_info.lhs_logit_vd_id;
                                    dispatch_radix.lhs_grad_vd_id       = dispatch_info.lhs_grad_vd_id;
                                    dispatch_radix.rhs_logit_vd_id      = dispatch_info.rhs_logit_vd_id;
                                    dispatch_radix.rhs_grad_vd_id       = dispatch_info.rhs_grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }

                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t lhs_logit_ptr;
                cuda_ptr_t lhs_grad_ptr;
                grad_status_t lhs_grad_status;
                cuda_ptr_t rhs_logit_ptr;
                cuda_ptr_t rhs_grad_ptr;
                grad_status_t rhs_grad_status;
                cuda_ptr_t dst_grad_ptr;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 5;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = 0u;
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz)); 

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 5]     = data_arr[i].lhs_logit_ptr;
                        cuda_ptr_arr[i * 5 + 1] = data_arr[i].lhs_grad_ptr;
                        cuda_ptr_arr[i * 5 + 2] = data_arr[i].rhs_logit_ptr;
                        cuda_ptr_arr[i * 5 + 3] = data_arr[i].rhs_grad_ptr;
                        cuda_ptr_arr[i * 5 + 4] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_pair_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_pair(e.lhs_logit_ptr, e.lhs_grad_ptr, 
                                                                                                                    e.rhs_logit_ptr, e.rhs_grad_ptr,
                                                                                                                    e.dst_grad_ptr, e.dispatch_control,
                                                                                                                    convert_grad_status_to_cuda_write_option(e.lhs_grad_status),
                                                                                                                    convert_grad_status_to_cuda_write_option(e.rhs_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo))); 
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t lhs_logit_ptr;
                host_ptr_t lhs_grad_ptr;
                grad_status_t lhs_grad_status;
                host_ptr_t rhs_logit_ptr;
                host_ptr_t rhs_grad_ptr;
                grad_status_t rhs_grad_status;
                host_ptr_t dst_grad_ptr;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 5;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 5]     = data_arr[i].lhs_logit_ptr;
                        host_ptr_arr[i * 5 + 1] = data_arr[i].lhs_grad_ptr;
                        host_ptr_arr[i * 5 + 2] = data_arr[i].rhs_logit_ptr;
                        host_ptr_arr[i * 5 + 3] = data_arr[i].rhs_grad_ptr;
                        host_ptr_arr[i * 5 + 4] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_pair_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_pair(e.lhs_logit_ptr, e.lhs_grad_ptr,
                                                                                                                    e.rhs_logit_ptr, e.rhs_grad_ptr,
                                                                                                                    e.dst_grad_ptr, e.dispatch_control,
                                                                                                                    convert_grad_status_to_host_write_option(e.lhs_grad_status),
                                                                                                                    convert_grad_status_to_host_write_option(e.rhs_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except + optimizables
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: word_size memcmp + has_unique_object_representations_v 
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t lhs_region_rcu_addr;
                uma_ptr_t rhs_region_rcu_addr;
                device_id_t dst_grad_vd_id;
                device_id_t lhs_logit_vd_id;
                device_id_t lhs_grad_vd_id;
                device_id_t rhs_logit_vd_id;
                device_id_t rhs_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr, dst_grad_vd_id, lhs_logit_vd_id, lhs_grad_vd_id, rhs_logit_vd_id, rhs_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr, dst_grad_vd_id, lhs_logit_vd_id, lhs_grad_vd_id, rhs_logit_vd_id, rhs_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t lhs;
                uma_ptr_t rhs;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.lhs_region_rcu_addr, key.rhs_region_rcu_addr);

                    auto umamap_reacquirer                              = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 5u>{}));
                    auto lhs_logit_vmamap_reacquirer                    = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto lhs_grad_vmamap_reacquirer                     = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto rhs_logit_vmamap_reacquirer                    = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto rhs_grad_vmamap_reacquirer                     = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto dst_grad_vmamap_reacquirer                     = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                        = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device                = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer                = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer       = &cuda_restrict_synchronizer;

                    auto host_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                        = InternalHostResolutor{};
                    host_internal_resolutor.async_device                = this->host_async_device;  
                    host_internal_resolutor.synchronizer                = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer       = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    size_t trimmed_cuda_mixed_vectorization_sz          = std::min(this->vectorization_sz, sz);
                    size_t cmdh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_mixed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vmdh_mem(cmdh_allocation_cost);
                    auto cuda_mixed_delivery_handle                     = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_mixed_vectorization_sz, vmdh_mem.get()));

                    size_t trimmed_host_mixed_vectorization_sz          = std::min(this->vectorization_sz, sz);
                    size_t hmdh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_mixed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hmdh_mem(hmdh_allocation_cost);
                    auto host_mixed_delivery_handle                     = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_mixed_vectorization_sz, hmdh_mem.get())); 

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, lhs, rhs, expected_ops_id]       = std::make_tuple(data_arr[i].dst, data_arr[i].lhs, data_arr[i].rhs, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_lhs                           = dg::network_tile_member_getsetter::get_pair_left_descendant_nothrow(dst);
                        uma_ptr_t dst_rhs                           = dg::network_tile_member_getsetter::get_pair_right_descendant_nothrow(dst);
                        operatable_id_t dst_operatable_id           = dg::network_tile_member_getsetter::get_pair_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_bwd_operatable_id       = dg::network_tile_member_getsetter::get_pair_operatable_backward_id_nothrow(dst);
                        dispatch_control_t dispatch_control         = dg::network_tile_member_getsetter::get_pair_backward_dispatch_control_nothrow(dst);
                        init_status_t dst_init_status               = dg::network_tile_member_getsetter::get_pair_init_status_nothrow(dst);
                        grad_status_t dst_grad_status               = dg::network_tile_member_getsetter::get_pair_grad_status_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr                   = dg::network_tile_member_getsetter::get_pair_grad_addr_nothrow(dst);
                        dispatch_major_t dst_dispatch_major         = dg::network_tile_member_getsetter::get_pair_dispatch_major_nothrow(dst);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_pair_signal_smph_addr_nothrow(dst);

                        std::expected<operatable_id_t, exception_t> lhs_bwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_backward_id(lhs);
                        std::expected<uma_ptr_t, exception_t> lhs_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(lhs);
                        std::expected<uma_ptr_t, exception_t> lhs_grad_umaptr               = dg::network_tile_member_getsetter::get_tile_grad_addr(lhs);
                        std::expected<init_status_t, exception_t> lhs_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(lhs);
                        std::expected<grad_status_t, exception_t> lhs_grad_status           = dg::network_tile_member_getsetter::get_tile_grad_status(lhs);

                        std::expected<operatable_id_t, exception_t> rhs_bwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_backward_id(rhs);
                        std::expected<uma_ptr_t, exception_t> rhs_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(rhs);
                        std::expected<uma_ptr_t, exception_t> rhs_grad_umaptr               = dg::network_tile_member_getsetter::get_tile_grad_addr(rhs);
                        std::expected<init_status_t, exception_t> rhs_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(rhs);
                        std::expected<grad_status_t, exception_t> rhs_grad_status           = dg::network_tile_member_getsetter::get_tile_grad_status(rhs);

                        if (!lhs_bwd_operatable_id.has_value() || !lhs_logit_umaptr.has_value() || !lhs_grad_umaptr.has_value() || !lhs_init_status.has_value() || !lhs_grad_status.has_value()
                            || rhs_bwd_operatable_id.has_value() || !rhs_logit_umaptr.has_value() || !rhs_grad_umaptr.has_value() || !rhs_init_status.has_value() || !rhs_grad_status.has_value()){

                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (lhs_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (rhs_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_lhs != lhs){
                            continue;
                        }

                        if (dst_rhs != rhs){
                            continue;
                        }

                        if (dst_bwd_operatable_id != lhs_bwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_bwd_operatable_id != rhs_bwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_pair_backward_control(dispatch_control));

                        if (dispatch_info.lhs_logit_vd_id != key.lhs_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.lhs_grad_vd_id != key.lhs_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.rhs_logit_vd_id != key.rhs_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.rhs_grad_vd_id != key.rhs_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_reacquire_nothrow(umamap_reacquirer, {{lhs_logit_umaptr.value(), dispatch_info.lhs_logit_vd_id}, 
                                                                                                 {lhs_grad_umaptr.value(), dispatch_info.lhs_grad_vd_id}, 
                                                                                                 {rhs_logit_umaptr.value(), dispatch_info.rhs_logit_vd_id}, 
                                                                                                 {rhs_grad_umaptr.value(), dispatch_info.rhs_grad_vd_id}, 
                                                                                                 {dst_grad_umaptr, dispatch_info.dst_grad_vd_id}});

                        vma_ptr_t lhs_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t lhs_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t rhs_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});
                        vma_ptr_t rhs_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 3u>{});
                        vma_ptr_t dst_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 4u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(lhs_logit_vmamap_reacquirer, lhs_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(lhs_grad_vmamap_reacquirer, lhs_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(rhs_logit_vmamap_reacquirer, rhs_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(rhs_grad_vmamap_reacquirer, rhs_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dst_grad_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.lhs_logit_ptr    = dg::network_vmamap::get_cuda_ptr(lhs_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.lhs_grad_ptr     = dg::network_vmamap::get_cuda_ptr(lhs_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.lhs_grad_status  = lhs_grad_status.value();
                            cuda_resolutor_arg.rhs_logit_ptr    = dg::network_vmamap::get_cuda_ptr(rhs_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.rhs_grad_ptr     = dg::network_vmamap::get_cuda_ptr(rhs_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.rhs_grad_status  = rhs_grad_status.value();
                            cuda_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_cuda_ptr(dst_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            //compiler's hint
                            cuda_ptr_t cuda_dispatch_buf[3];
                            cuda_dispatch_buf[0]                = cuda_resolutor_arg.rhs_logit_ptr;
                            cuda_dispatch_buf[1]                = cuda_resolutor_arg.lhs_logit_ptr;
                            cuda_dispatch_buf[2]                = dg::pointer_limits<cuda_ptr_t>::null_value();

                            if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_RIGHT){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_dispatch_buf[0], cuda_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_LEFT){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_dispatch_buf[1], cuda_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_MIXED){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_mixed_delivery_handle.get(), cuda_dispatch_buf[2], cuda_resolutor_arg);
                            } else{
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.lhs_logit_ptr    = dg::network_vmamap::get_host_ptr(lhs_logit_vmamap_reacquirer);
                            host_resolutor_arg.lhs_grad_ptr     = dg::network_vmamap::get_host_ptr(lhs_grad_vmamap_reacquirer);
                            host_resolutor_arg.lhs_grad_status  = lhs_grad_status.value();
                            host_resolutor_arg.rhs_logit_ptr    = dg::network_vmamap::get_host_ptr(rhs_logit_vmamap_reacquirer);
                            host_resolutor_arg.rhs_grad_ptr     = dg::network_vmamap::get_host_ptr(rhs_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.rhs_grad_status  = rhs_grad_status.value();
                            host_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            //compiler's hint
                            host_ptr_t host_dispatch_buf[3];
                            host_dispatch_buf[0]                = host_resolutor_arg.rhs_logit_ptr;
                            host_dispatch_buf[1]                = host_resolutor_arg.lhs_logit_ptr;
                            host_dispatch_buf[2]                = dg::pointer_limits<host_ptr_t>::null_value(); 

                            if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_RIGHT){
                                dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_dispatch_buf[0], host_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_LEFT){
                                dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_dispatch_buf[1], host_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_MIXED){
                                dg::network_producer_consumer::delvrsrv_deliver(host_mixed_delivery_handle.get(), host_dispatch_buf[2], host_resolutor_arg);
                            } else{
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable(); 
                                }
                            }
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_pair_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                        exception_t lhs_gradstat_set_err = dg::network_tile_member_getsetter::set_tile_grad_status(lhs, TILE_GRAD_STATUS_HAS_VALUE);

                        if (dg::network_exception::is_failed(lhs_gradstat_set_err)){
                            (void) lhs_gradstat_set_err;
                            // dg::network_log_stackdump::error_fast(dg::network_exception::verbose(lhs_gradstat_set_err));
                        }

                        exception_t rhs_gradstat_set_err = dg::network_tile_member_getsetter::set_tile_grad_status(rhs, TILE_GRAD_STATUS_HAS_VALUE);

                        if (dg::network_exception::is_failed(rhs_gradstat_set_err)){
                            (void) rhs_gradstat_set_err;
                            // dg::network_log_stackdump::error_fast(dg::network_exception::verbose(rhs_gradstat_set_err));
                        }

                        if (!signal_smph_addr.has_value()){
                            auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(lhs, expected_ops_id));
                            auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(rhs, expected_ops_id));  

                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));
                        } else{
                            auto sigagg_1               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_backward_do_signal(signal_smph_addr.value(), lhs, expected_ops_id));
                            auto sigagg_2               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_backward_do_signal(signal_smph_addr.value(), rhs, expected_ops_id));
                            auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_1));
                            auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_2));
                            
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));
                        }
                    }
                }
            };
    };


    //alright, the reason we'd want to have poly after we implemented immu + leaf + mono + pair is that we'd want to expose the users to the concepts of what those would do
    //and certain polymorphic tile of the poly would disable certain features, like initialized + immu -> no backward
    //or immu + get_backward_operatable_id -> unexpected
    //the problem is that we'd use those "interfaces" of backward + forward contract (of a tile having a certain getsetting method)
    //poly is an all round solution for that

    class BackwardDoPolySignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;

        public:

            BackwardDoPolySignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                          std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                          std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                          size_t request_delivery_capacity,
                                          size_t radxfetch_vectorization_sz,
                                          size_t region_vectorization_sz,
                                          size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                      cuda_async_device(std::move(cuda_async_device)),
                                                                                      host_async_device(std::move(host_async_device)),
                                                                                      request_delivery_capacity(request_delivery_capacity),
                                                                                      radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                      region_vectorization_sz(region_vectorization_sz),
                                                                                      backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_poly_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = 2u;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};
                    
                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fecther, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_poly_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = AddressFetchArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->backward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> lhs_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->lhs);
                        std::expected<uma_ptr_t, exception_t> rhs_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->rhs);

                        if (!lhs_rcu_addr.has_value() || !rhs_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr              = dg::network_tile_member_getsetter::get_poly_rcu_addr_nothrow(event_arr[i].dst);
                        
                        auto resolutor_key                  = ResolutorKeyArgument{};
                        resolutor_key.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key.lhs_region_rcu_addr   = dg::memult::region(lhs_rcu_addr.value(), lck_region_sz);
                        resolutor_key.rhs_region_rcu_addr   = dg::memult::region(rhs_rcu_addr.value(), lck_region_sz); 
                        resolutor_key.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key.lhs_logit_vd_id       = dispatch_radix_arg_arr[i]->lhs_logit_vd_id;
                        resolutor_key.lhs_grad_vd_id        = dispatch_radix_arg_arr[i]->lhs_grad_vd_id;
                        resolutor_key.rhs_logit_vd_id       = dispatch_radix_arg_arr[i]->rhs_logit_vd_id;
                        resolutor_key.rhs_grad_vd_id        = dispatch_radix_arg_arr[i]->rhs_grad_vd_id;
                        resolutor_key.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val                  = ResolutorValueArgument{};
                        resolutor_val.dst                   = eventr_arr[i].dst;
                        resolutor_val.lhs                   = dispattch_radix_arg_arr[i]->lhs;
                        resolutor_val.rhs                   = dispattch_radix_arg_arr[i]->rhs;
                        resolutor_val.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key, resolutor_val);
                    }
                }
            }
        
        private:
            
            struct DispatchRadixArgument{
                uma_ptr_t lhs;
                uma_ptr_t rhs;
                device_id_t dst_grad_vd_id;
                device_id_t lhs_logit_vd_id;
                device_id_t lhs_grad_vd_id;
                device_id_t rhs_logit_vd_id;
                device_id_t rhs_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    //this is very complicated

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status           = dg::network_tile_member_getsetter::get_poly_init_status_nothrow(data_arr[i].root);
                        operatable_id_set_t current_ops_id  = dg::network_tile_member_getsetter::get_poly_operatable_memevent_id_set_nothrow(data_arr[i].root);
                        poly_tile_t poly_type               = dg::network_tile_member_getsetter::get_poly_poly_type_nothrow(data_arr[i].root); 

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (!is_subset_id(data_arr[i].expected_ops_id, current_ops_id))[
                                    break;
                                ]

                                switch (poly_type){
                                    case POLY_TILE_LEAF: [[fallthrough]]
                                    case POLY_TILE_IMMU:
                                    {
                                        break;
                                    }
                                    case POLY_TILE_PAIR:
                                    {
                                        auto dispatch_radix                 = DispatchRadixArgument{};
                                        auto dispatch_control               = dg::network_tile_member_getsetter::get_poly_backward_dispatch_control_nothrow(data_arr[i].root);
                                        dispatch_radix.lhs                  = dg::network_tile_member_getsetter::get_poly_left_descendant_nothrow(data_arr[i].root);
                                        dispatch_radix.rhs                  = dg::network_tile_member_getsetter::get_poly_right_descendant_nothrow(data_arr[i].root);
                                        auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_backward_polypair_dispatch(dispatch_control));
                                        dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                        dispatch_radix.lhs_logit_vd_id      = dispatch_info.lhs_logit_vd_id;
                                        dispatch_radix.lhs_grad_vd_id       = dispatch_info.lhs_grad_vd_id;
                                        dispatch_radix.rhs_logit_vd_id      = dispatch_info.rhs_logit_vd_id;
                                        dispatch_radix.rhs_grad_vd_id       = dispatch_info.rhs_grad_vd_id;
                                        dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                        *data_arr[i].fetching_addr          = dispatch_radix;
                                        break;
                                    }
                                    default:
                                    {
                                        if constexpr(DEBUG_MODE_FLAG){
                                            dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                            std::abort();
                                        } else{
                                            std::unreachable();
                                        }
                                    }
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t lhs_logit_ptr;
                cuda_ptr_t lhs_grad_ptr;
                grad_status_t lhs_grad_status;
                cuda_ptr_t rhs_logit_ptr;
                cuda_ptr_t rhs_grad_ptr;
                grad_status_t rhs_grad_status;
                cuda_ptr_t dst_grad_ptr;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;
    
                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 5;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = 0u;
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 5]     = data_arr[i].lhs_logit_ptr;
                        cuda_ptr_arr[i * 5 + 1] = data_arr[i].lhs_grad_ptr;
                        cuda_ptr_arr[i * 5 + 2] = data_arr[i].rhs_logit_ptr;
                        cuda_ptr_arr[i * 5 + 3] = data_arr[i].rhs_grad_ptr;
                        cuda_ptr_arr[i * 5 + 4] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_polypair_backward_dispatch(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_polypair(e.lhs_logit_ptr, e.lhs_grad_ptr,
                                                                                                                        e.rhs_logit_ptr, e.rhs_grad_ptr,
                                                                                                                        e.dst_grad_ptr, e.dispatch_control,
                                                                                                                        convert_grad_status_to_cuda_write_option(e.lhs_grad_status),
                                                                                                                        convert_grad_status_to_cuda_write_option(e.rhs_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(std::move(work_order)));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t lhs_logit_ptr;
                host_ptr_t lhs_grad_ptr;
                grad_status_t lhs_grad_status;
                host_ptr_t rhs_logit_ptr;
                host_ptr_t rhs_grad_ptr;
                grad_status_t rhs_grad_status;
                host_ptr_t dst_grad_ptr;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 5;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = 0u;
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 5]     = data_arr[i].lhs_logit_ptr;
                        host_ptr_arr[i * 5 + 1] = data_arr[i].lhs_grad_ptr;;
                        host_ptr_arr[i * 5 + 2] = data_arr[i].rhs_logit_ptr;
                        host_ptr_arr[i * 5 + 3] = data_arr[i].rhs_grad_ptr;
                        host_ptr_arr[i * 5 + 4] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_polypair_backward_dispatch(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_polypair(e.lhs_logit_ptr, e.lhs_grad_ptr,
                                                                                                                        e.rhs_logit_ptr, e.rhs_grad_ptr,
                                                                                                                        e.dst_grad_ptr, e.dispatch_control,
                                                                                                                        convert_grad_status_to_host_write_option(e.lhs_grad_status),
                                                                                                                        convert_grad_status_to_host_write_option(e.rhs_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(std::move(work_order)));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t lhs_region_rcu_addr;
                uma_ptr_t rhs_region_rcu_addr;
                device_id_t dst_grad_vd_id;
                device_id_t lhs_logit_vd_id;
                device_id_t lhs_grad_vd_id;
                device_id_t rhs_logit_vd_id;
                device_id_t rhs_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr, dst_grad_vd_id, lhs_logit_vd_id, lhs_grad_vd_id, rhs_logit_vd_id, rhs_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr, dst_grad_vd_id, lhs_logit_vd_id, lhs_grad_vd_id, rhs_logit_vd_id, rhs_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, lhs_region_rcu_addr, rhs_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t lhs;
                uma_ptr_t rhs;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.lhs_region_rcu_addr, key.rhs_region_rcu_addr);
                    
                    auto umamap_reacquirer                              = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 5u>{}));
                    auto lhs_logit_vmamap_reacquirer                    = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto lhs_grad_vmamap_reacquirer                     = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto rhs_logit_vmamap_reacquirer                    = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto rhs_grad_vmamap_reacquirer                     = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto dst_grad_vmamap_reacquirer                     = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    
                    auto cuda_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                        = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device                = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer                = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer       = &cuda_restrict_synchronizer;

                    auto host_synchronizer                              = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                     = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                        = InternalHostResolutor{};
                    host_internal_resolutor.async_device                = this->host_async_device;
                    host_internal_resolutor.synchronizer                = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer       = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_cuda_mixed_vectorization_sz          = std::min(this->vectorization_sz, sz);
                    size_t cmdh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_mixed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cmdh_mem(cmdh_allocation_cost);
                    auto cuda_mixed_delivery_handle                     = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_mixed_vectorization_sz, cmdh_mem.get()));

                    size_t trimmed_host_vectorization_sz                = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                          = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    size_t trimmed_host_mixed_vectorization_sz          = std::min(this->vectorization_sz, sz);
                    size_t hmdh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_mixed_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hmdh_mem(hmdh_allocation_cost);
                    auto host_mixed_delivery_handle                     = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_mixed_vectorization_sz, hmdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t dst_init_status   = dg::network_tile_member_getsetter::get_poly_init_status_nothrow(dst);

                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        poly_tile_t dst_poly_type       = dg::network_tile_member_getsetter::get_poly_poly_type_nothrow(dst);

                        if (dst_poly_type != POLY_TILE_PAIR){
                            continue;
                        }

                        uma_ptr_t dst_lhs                           = dg::network_tile_member_getsetter::get_poly_left_descendant_nothrow(dst);
                        uma_ptr_t dst_rhs                           = dg::network_tile_member_getsetter::get_poly_right_descendant_nothrow(dst);
                        operatable_id_set_t dst_operatable_id       = dg::network_tile_member_getsetter::get_poly_operatable_memevent_id_set_nothrow(dst);
                        operatable_id_t dst_bwd_operatable_id       = dg::network_tile_member_getsetter::get_poly_operatable_backward_id_nothrow(dst);
                        dispatch_control_t dispatch_control         = dg::network_tile_member_getsetter::get_poly_backward_dispatch_control_nothrow(dst);
                        grad_status_t dst_grad_status               = dg::network_tile_member_getsetter::get_poly_grad_status_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr                   = dg::network_tile_member_getsetter::get_poly_grad_addr_nothrow(dst);
                        dispatch_major_t dst_dispatch_major         = dg::network_tile_member_getsetter::get_poly_dispatch_major_nothrow(dst);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_poly_signal_smph_addr_nothrow(dst);
                        
                        std::expected<operatable_id_t, exception_t> lhs_bwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_backward_id(lhs);
                        std::expected<uma_ptr_t, exception_t> lhs_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(lhs);
                        std::expected<uma_ptr_t, exception_t> lhs_grad_umaptr               = dg::network_tile_member_getsetter::get_tile_grad_addr(lhs);
                        std::expected<init_status_t, exception_t> lhs_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(lhs);
                        std::expected<grad_status_t, exception_t> lhs_grad_status           = dg::network_tile_member_getsetter::get_tile_grad_status(lhs);

                        std::expected<operatable_id_t, exception_t> rhs_bwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_backward_id(rhs);
                        std::expected<uma_ptr_t, exception_t> rhs_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(rhs);
                        std::expected<uma_ptr_t, exception_t> rhs_grad_umaptr               = dg::network_tile_member_getsetter::get_tile_grad_addr(rhs);
                        std::expected<init_status_t, exception_t> rhs_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(rhs);
                        std::expected<grad_status_t, exception_t> rhs_grad_status           = dg::network_tile_member_getsetter::get_tile_grad_status(rhs);

                        if (!lhs_bwd_operatable_id.has_value() || !lhs_logit_umaptr.has_value() || !lhs_grad_umaptr.has_value() || !lhs_init_status.has_value() || !lhs_grad_status.has_value()
                            || !rhs_bwd_operatable_id.has_value() || !rhs_logit_umaptr.has_value() || !rhs_grad_umaptr.has_value() || !rhs_init_status.has_value() || !rhs_grad_status.has_value()){
                            
                            continue;
                        }

                        if (lhs_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (rhs_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (!is_subset_id(expected_ops_id, dst_operatable_id)){ //
                            continue;
                        }

                        if (dst_lhs != lhs){
                            continue;
                        }

                        if (dst_rhs != rhs){
                            continue;
                        }

                        if (dst_bwd_operatable_id != lhs_bwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_bwd_operatable_id != rhs_bwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_polypair_backward_control(dispatch_control));

                        if (dispatch_info.lhs_logit_vd_id != key.lhs_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.lhs_grad_vd_id != key.lhs_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.rhs_logit_vd_id != key.rhs_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.rhs_grad_vd_id != key.rhs_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_reacquire_nothrow(umamap_reacquirer, {{lhs_logit_umaptr.value(), dispatch_info.lhs_logit_vd_id}, 
                                                                                                 {lhs_grad_umaptr.value(), dispatch_info.lhs_grad_vd_id}, 
                                                                                                 {rhs_logit_umaptr.value(), dispatch_info.rhs_logit_vd_id}, 
                                                                                                 {rhs_grad_umaptr.value(), dispatch_info.rhs_grad_vd_id}, 
                                                                                                 {dst_grad_umaptr, dispatch_info.dst_grad_vd_id}});

                        vma_ptr_t lhs_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t lhs_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t rhs_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});
                        vma_ptr_t rhs_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 3u>{});
                        vma_ptr_t dst_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 4u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(lhs_logit_vmamap_reacquirer, lhs_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(lhs_grad_vmamap_reacquirer, lhs_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(rhs_logit_vmamap_reacquirer, rhs_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(rhs_grad_vmamap_reacquirer, rhs_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dst_grad_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.lhs_logit_ptr    = dg::network_vmamap::get_cuda_ptr(lhs_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.lhs_grad_ptr     = dg::network_vmamap::get_cuda_ptr(lhs_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.lhs_grad_status  = lhs_grad_status.value();
                            cuda_resolutor_arg.rhs_logit_ptr    = dg::network_vmamap::get_cuda_ptr(rhs_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.rhs_grad_ptr     = dg::network_vmamap::get_cuda_ptr(rhs_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.rhs_grad_status  = rhs_grad_status.value();
                            cuda_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_cuda_ptr(dst_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            //compiler's hint
                            cuda_ptr_t cuda_dispatch_buf[3];
                            cuda_dispatch_buf[0]                = cuda_resolutor_arg.rhs_logit_ptr;
                            cuda_dispatch_buf[1]                = cuda_resolutor_arg.lhs_logit_ptr;
                            cuda_dispatch_buf[2]                = dg::pointer_limits<cuda_ptr_t>::null_value();

                            if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_RIGHT){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_dispatch_buf[0], cuda_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_LEFT){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_dispatch_buf[1], cuda_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_MIXED){
                                dg::network_producer_consumer::delvrsrv_deliver(cuda_mixed_delivery_handle.get(), cuda_dispatch_buf[2], cuda_resolutor_arg);
                            } else{
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.lhs_logit_ptr    = dg::network_vmamap::get_host_ptr(lhs_logit_vmamap_reacquirer);
                            host_resolutor_arg.lhs_grad_ptr     = dg::network_vmamap::get_host_ptr(lhs_grad_vmamap_reacquirer);
                            host_resolutor_arg.lhs_grad_status  = lhs_grad_status.value();
                            host_resolutor_arg.rhs_logit_ptr    = dg::network_vmamap::get_host_ptr(rhs_logit_vmamap_reacquirer);
                            host_resolutor_arg.rhs_grad_ptr     = dg::network_vmamap::get_host_ptr(rhs_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.rhs_grad_status  = rhs_grad_status.value();
                            host_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            //compiler's hint
                            host_ptr_t host_dispatch_buf[3];
                            host_dispatch_buf[0]                = host_resolutor_arg.rhs_logit_ptr;
                            host_dispatch_buf[1]                = host_resolutor_arg.lhs_logit_ptr;
                            host_dispatch_buf[2]                = dg::pointer_limits<host_ptr_t>::null_value(); 

                            if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_RIGHT){
                                dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_dispatch_buf[0], host_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_LEFT){
                                dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_dispatch_buf[1], host_resolutor_arg);
                            } else if (dst_dispatch_major == PAIR_DISPATCH_MAJOR_MIXED){
                                dg::network_producer_consumer::delvrsrv_deliver(host_mixed_delivery_handle.get(), host_dispatch_buf[2], host_resolutor_arg);
                            } else{
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable(); 
                                }
                            }
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_poly_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                        exception_t lhs_gradstat_set_err = dg::network_tile_member_getsetter::set_tile_grad_status(lhs, TILE_GRAD_STATUS_HAS_VALUE);

                        if (dg::network_exception::is_failed(lhs_gradstat_set_err)){
                            (void) lhs_gradstat_set_err;
                            // dg::network_log_stackdump::error_fast(dg::network_exception::verbose(lhs_gradstat_set_err));
                        }

                        exception_t rhs_gradstat_set_err = dg::network_tile_member_getsetter::set_tile_grad_status(rhs, TILE_GRAD_STATUS_HAS_VALUE);

                        if (dg::network_exception::is_failed(rhs_gradstat_set_err)){
                            (void) rhs_gradstat_set_err;
                            // dg::network_log_stackdump::error_fast(dg::network_exception::verbose(rhs_gradstat_set_err));
                        }

                        if (!signal_smph_addr.has_value()){
                            auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(lhs, expected_ops_id));
                            auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(rhs, expected_ops_id));  

                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));
                        } else{
                            auto sigagg_1               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_backward_do_signal(signal_smph_addr.value(), lhs, expected_ops_id));
                            auto sigagg_2               = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_backward_do_signal(signal_smph_addr.value(), rhs, expected_ops_id));
                            auto decay_signal_event_1   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_1));
                            auto decay_signal_event_2   = dg::network_memcommit_factory::virtualize_event(std::move(sigagg_2));
                            
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_1));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event_2));
                        }
                    }
                }
            };
    };

    class BackwardDoUACMSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;

        public:

            BackwardDoUACMSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                          std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                          std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                          size_t request_delivery_capacity,
                                          size_t radxfetch_vectorization_sz,
                                          size_t region_vectorization_sz,
                                          size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                      cuda_async_device(std::move(cuda_async_device)),
                                                                                      host_async_device(std::move(host_async_device)),
                                                                                      request_delivery_capacity(request_delivery_capacity),
                                                                                      radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                      region_vectorization_sz(region_vectorization_sz),
                                                                                      backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                // constexpr size_t LCK_ADDR_SZ_PER_DISPATCH   = UACM_ACM_SZ + 1u;

                // dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> descendant_arr(sz * UACM_ACM_SZ);
                // dg::networK_stack_allocation::NoExceptAllocation<bool[]> validation_arr(sz);
                // std::fill(validation_arr.get(), std::next(validation_arr.get(), sz), false);
                // dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> lck_addr_arr(sz * LCK_ADDR_SZ_PER_DISPATCH); 

                // const size_t EVENT_SCALE_FACTOR             = UACM_ACM_SZ;
                // size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                // size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                // size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                // dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                // auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                // {
                //     InternalDescendantAddressFetcher fetcher    = {};

                //     size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                //     size_t vdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                //     dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                //     auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_kv_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                //     for (size_t i = 0u; i < sz; ++i){
                //         if constexpr(DEBUG_MODE_FLAG){
                //             std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_uacm_ptr_access(event_arr[i].dst);

                //             if (!ptrchk.has_value()){
                //                 dg::network_log_stackdump::critical(dg::network_exception::verbose(ptrchk.error()));
                //                 std::abort();
                //             }
                //         }

                //         uma_ptr_t rcu_addr                  = dg::network_tile_member_getsetter::get_uacm_rcu_addr_nothrow(event_arr[i].dst);
                //         uma_ptr_t lck_addr                  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                //         auto fetch_arg                      = AddressFetchArgument{};
                //         fetch_arg.root                      = event_arr[i].dst;
                //         fetch_arg.expected_ops_id           = event_arr[i].operatable_id;
                //         fetch_arg.fetching_addr             = std::next(descendant_arr.get(), i * UACM_ACM_SZ);
                //         fetch_arg.fetching_validation_addr  = std::next(validation_arr.get(), i);

                //         dg::network_producer_consumer::delvrsrv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                //     }
                // }

                // {
                //     auto internal_resolutor                     = InternalResolutor{};
                //     internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                //     internal_resolutor.host_async_device        = this->host_async_device.get();
                //     internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                //     internal_resolutor.vectorization_sz         = this->backward_vectorization_sz;

                //     size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                //     size_t vdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                //     dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                //     auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_kv_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                //     for (size_t i = 0u; i < sz; ++i){
                //         if (!validation_arr[i]){
                //             continue;
                //         }

                //         size_t lck_region_sz            = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                //         uma_ptr_t * cur_descendant_arr  = std::next(descendant_arr.get(), i * UACM_ACM_SZ);
                //         uma_ptr_t * cur_lck_addr        = std::next(lck_addr_arr.get(), i * LCK_ADDR_SZ_PER_DISPATCH);
                //         bool validation_flag            = true;
                //         cur_lck_addr[0u]                = dg::memult::region(dg::network_tile_member_getsetter::get_uacm_rcu_addr_nothrow(event_arr[i].dst), lck_region_sz);

                //         for (size_t j = 0u; j < UACM_ACM_SZ; ++j){
                //             std::expected<uma_ptr_t, exception_t> rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(cur_descendant_arr[j]);

                //             if (!rcu_addr.has_value()){
                //                 validation_flag = false;
                //                 break;
                //             }

                //             cur_lck_addr[j + 1] = dg::memult::region(rcu_addr.value(), lck_region_sz);
                //         }

                //         if (!validation_flag){
                //             continue;
                //         }

                //         auto key                        = dg::vector_view<uma_ptr_t, LCK_ADDR_SZ_PER_DISPATCH>(cur_lck_addr);
                //         auto resolutor_arg              = ResolutorArgument{};
                //         resolutor_arg.root              = event_arr[i].dst;
                //         resolutor_arg.expected_ops_id   = event_arr[i].operatable_id;
                //         resolutor_arg.descendant        = cur_descendant_arr;  

                //         dg::network_producer_consumer::delvrsrv_deliver(vectorized_delivery_handle.get(), key, resolutor_arg);
                //     }
                // }
            }

        private:

            struct DispatchRadixArgument{
                dg::array_view<uma_ptr_t, UACM_ACM_SZ> src;
                device_id_t dst_grad_vd_id;
                dg::array_view<device_id_t, UACM_ACM_SZ> src_grad_vd_id;
                dg::array_view<device_id_t, UACM_ACM_SZ> src_logit_vd_id;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                DispatchRadixArgument * fetching_addr;
                bool * validation_bit;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_uacm_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_uacm_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    *data_arr[i].validation_bit = true;
                                    dg::network_tile_member_getsetter::get_uacm_descendant_nothrow(data_arr[i].root, data_arr[i].fetching_addr->src.data());

                                    size_t dispatch_control_bsz = dg::network_tile_member_getsetter::get_uacm_backward_dispatch_control_byte_size_nothrow(dst);
                                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> dispatch_control_buf(dispatch_control_bsz);
                                    dg::network_tile_member_getsetter::get_uacm_backward_dispatch_control_nothrow(dst, dispatch_control_buf.get());

                                    dg::network_dispatch_control::read_uacm_backward_dispatch_src_grad_virtual_device_id(dispatch_control_buf.get(), data_arr[i].fetching_addr->src_grad_vd_id.data());
                                    dg::network_dispatch_control::read_uacm_backward_dispatch_src_logit_virtual_device_id(dispatch_control_buf.get(), data_arr[i].fetching_addr->src_logit_vd_id.data());
                                    dg::network_dispatch_control::read_uacm_backward_dispatch_root_virtual_device_id(dispatch_control_buf.get(), &data_arr[i].fetching_addr->dst_grad_vd_id);
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                dg::array_view<cuda_ptr_t, UACM_ACM_SZ> src_grad;
                dg::array_view<cuda_ptr_t, UACM_ACM_SZ> src_logit;
                cuda_ptr_t dst_grad;
                dg::array_view<grad_status_t, UACM_ACM_SZ> src_grad_status;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    const size_t DISPATCH_ARR_SZ    = UACM_ACM_SZ + UACM_ACM_SZ + 1u;
                    size_t cuda_ptr_arr_sz          = sz * DISPATCH_ARR_SZ;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity         = {};
                    auto virtual_wo_vec             = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        auto cpy_ptr                = std::copy(data_arr[i].src_grad.begin(), data_arr[i].src_grad.end(), std::next(cuda_ptr_arr.get(), i * DISPATCH_ARR_SZ));
                        cpy_ptr                     = std::copy(data_arr[i].src_logit.begin(), data_arr[i].src_logit.end(), cpy_ptr);
                        *cpy_ptr                    = data_arr[i].dst_grad;

                        auto src_grad_arr           = dg::network_exception_handler::nothrow_log(dg::network_allocation::cstyle_make_unique<cuda_ptr_t[]>(UACM_ACM_SZ));
                        std::copy(data_arr[i].src_grad.begin(), data_arr[i].src_grad.end(), src_grad_arr->begin());

                        auto src_logit_arr          = dg::network_exception_handler::nothrow_log(dg::network_allocation::cstyle_make_unique<cuda_ptr_t[]>(UACM_ACM_SZ));
                        std::copy(data_arr[i].src_logit.begin(), data_arr[i].src_logit.end(), src_logit_arr->begin());

                        auto src_grad_wop           = dg::network_exception_handler::nothrow_log(dg::network_allocation::cstyle_make_unique<cuda_write_option_t[]>(UACM_ACM_SZ));
                        std::transform(data_arr[i].src_grad_status.begin(), data_arr[i].src_grad_status.end(), src_grad_wop->begin(), convert_grad_status_to_cuda_write_option_lambda);

                        total_complexity            += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_uacm_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;

                        auto work_order = [src_grad_arr_cpy     = std::move(src_grad_arr), 
                                           src_logit_arr_cpy    = std::move(src_logit_arr), 
                                           dst_grad             = data_arr[i].dst_grad,
                                           src_grad_wop_cpy     = std::move(src_grad_wop),
                                           dispatch_control     = data_arr[i].dispatch_control]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_uacm(src_grad_arr_cpy->data(), src_logit_arr_cpy->data(), src_grad_wop_cpy->data(), 
                                                                                                                    dst_grad, dispatch_control));
                        };

                        auto virtual_wo             = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                dg::array_view<host_ptr_t, UACM_ACM_SZ> src_grad;
                dg::array_view<host_ptr_t, UACM_ACM_SZ> src_logit;
                host_ptr_t dst_grad;
                dg::array_view<grad_status_t, UACM_ACM_SZ> src_grad_status;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    const size_t DISPATCH_ARR_SZ    = UACM_ACM_SZ + UACM_ACM_SZ + 1u;
                    size_t host_ptr_arr_sz          = sz * DISPATCH_ARR_SZ;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity         = {};
                    auto virtual_wo_vec             = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        auto cpy_ptr                = std::copy(data_arr[i].src_grad.begin(), data_arr[i].src_grad.end(), std::next(host_ptr_arr.get(), i * DISPATCH_ARR_SZ));
                        cpy_ptr                     = std::copy(data_arr[i].src_logit.begin(), data_arr[i].src_logit.end(), cpy_ptr);
                        *cpy_ptr                    = data_arr[i].dst_grad;

                        auto src_grad_arr           = dg::network_exception_handler::nothrow_log(dg::network_allocation::cstyle_make_unique<host_ptr_t[]>(UACM_ACM_SZ));
                        std::copy(data_arr[i].src_grad.begin(), data_arr[i].src_grad.end(), src_grad_arr->begin());

                        auto src_logit_arr          = dg::network_exception_handler::nothrow_log(dg::network_allocation::cstyle_make_unique<host_ptr_t[]>(UACM_ACM_SZ));
                        std::copy(data_arr[i].src_logit.begin(), data_arr[i].src_logit.end(), src_logit_arr->begin());

                        auto src_grad_wop           = dg::network_exception_handler::nothrow_log(dg::network_allocation::cstyle_make_unique<host_write_option_t[]>(UACM_ACM_SZ));
                        std::transform(data_arr[i].src_grad_status.begin(), data_arr[i].src_grad_status.end(), src_grad_wop->begin(), convert_grad_status_to_host_write_option_lambda);

                        total_complexity            += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_uacm_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;

                        auto work_order = [src_grad_arr_cpy     = std::move(src_grad_arr),
                                           src_logit_arr_cpy    = std::move(src_logit_arr),
                                           dst_grad             = data_arr[i].dst_grad,
                                           src_grad_wop_cpy     = std::move(src_grad_wop),
                                           dispatch_control     = data_arr[i].dispatch_control]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_uacm(src_grad_arr_cpy->data(), src_logit_arr_cpy->data(), src_grad_wop_cpy->data(), 
                                                                                                                    dst_grad, dispatch_control));
                        };

                        auto virtual_wo             = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard_range mem_grd(key.lck_addr.begin(), key.lck_addr.end());

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    //alright - this might compromise the designs yet we want to have the first cut by next week - it's been dragging for too long now
                    //we have roughly at least 1 thousand lines of code to write everyday - we started 2025 on the bad foot
                    //things are harder than it appears - very hard - we dont have a way to do efficient array fetching just yet - we'll come up with a way soon - we'll be working on other components for now 

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (std::memcmp(src_init_status.data(), expecting_src_init_status.data(), static_cast<size_t>(UACM_ACM_SZ) * sizeof(init_status_t)) != 0){
                            continue;
                        }

                        if (std::memcmp(dst_src.data(), src.data(), static_cast<size_t>(UACM_ACM_SZ) * sizeof(uma_ptr_t)) != 0){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (std::memcmp(src_bwd_operatable_id.data(), expecting_src_bwd_operatable_id.data(), static_cast<size_t>(UACM_ACM_SZ) * sizeof(operatable_id_t)) != 0){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        dg::network_dispatch_control::read_uacm_backward_dispatch_src_grad_virtual_device_id(dispatch_control_buf.get(), src_grad_vd_id.data()); 
                        dg::network_dispatch_control::read_uacm_backward_dispatch_src_logit_virtual_device_id(dispatch_control_buf.get(), src_logit_vd_id.data());
                        dg::network_dispatch_control::read_uacm_backward_dispatch_root_grad_virtual_device_id(dispatch_control_buf.get(), &dst_grad_vd_id);
                        dg::network_dispatch_control::read_uacm_backward_dispatch_dispatch_platform(dispatch_control_buf.get(), &dispatch_platform);

                        if (std::memcmp(src_grad_vd_id.data(), key.src_grad_vd_id.data(), static_cast<size_t>(UACM_ACM_SZ) * sizeof(device_id_t)) != 0){
                            continue;
                        }

                        if (std::memcmp(src_logit_vd_id.data(), key.src_logit_vd_id.data(), static_cast<size_t>(UACM_ACM_SZ) * sizeof(device_id_t)) != 0){
                            continue;
                        }

                        if (dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_platform)){
                            auto cuda_resolutor_arg = CudaResolutorArgument{};

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_platform)){
                            auto host_resolutor_arg = HostResolutorArgument{};

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        for (size_t j = 0u; j < UACM_ACM_SZ; ++j){
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(src[j], expected_ops_id)));
                            exception_t set_gradstat_err = dg::network_tile_member_getsetter::set_tile_grad_status(src[j], TILE_GRAD_STATUS_HAS_VALUE);

                            if (dg::network_exception::is_failed(set_gradstat_err)){
                                (void) set_gradstat_err;
                            }
                        }

                        dg::network_tile_member_getsetter::set_uacm_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                    }
                }
            };
    };

    class BackwardDoPACMSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;

        public:

            BackwardDoPACMSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                          std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                          std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                          size_t request_delivery_capacity,
                                          size_t radxfetch_vectorization_sz,
                                          size_t region_vectorization_sz,
                                          size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                      cuda_async_device(std::move(cuda_async_device)),
                                                                                      host_async_device(std::move(host_async_device)),
                                                                                      request_delivery_capacity(request_delivery_capacity),
                                                                                      radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                      region_vectorization_sz(region_vectorization_sz),
                                                                                      backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                // constexpr size_t LCK_ADDR_SZ_PER_DISPATCH       = PACM_ACM_SZ + PACM_ACM_SZ + 1u;

                // dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> left_descendant_arr(sz * PACM_ACM_SZ);
                // dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> right_descendant_arr(sz * PACM_ACM_SZ);
                // dg::network_stack_allocation::NoExceptAllocation<bool[]> validation_arr(sz);
                // std::fill(validation_arr.get(), std::next(validation_arr.get(), sz), false);
                // dg::network_stack_allocation::NoExceptAllocation<uma_ptr_t[]> lck_addr_arr(sz * LCK_ADDR_SZ_PER_DISPATCH);

                // const size_t EVENT_SCALE_FACTOR                 = PACM_ACM_SZ + PACM_ACM_SZ;
                // size_t max_possible_event_sz                    = sz * EVENT_SCALE_FACTOR;
                // size_t trimmed_request_delivery_capacity        = std::min(this->request_delivery_capacity, max_possible_event_sz);
                // size_t rdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                // dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                // auto request_delivery_handle                    = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                // {
                //     InternalDescendantAddressFetcher fetcher    = {};

                //     size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                //     size_t vdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                //     dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                //     auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_kv_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                //     for (size_t i = 0u; i < sz; ++i){
                //         if constexpr(DEBUG_MODE_FLAG){
                //             std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_pacm_ptr_access(event_arr[i].dst);

                //             if (!ptrchk.has_value()){
                //                 dg::network_log_stackdump::critical(dg::network_exception::verbose(ptrchk.error()));
                //                 std::abort();
                //             }
                //         }

                //         uma_ptr_t rcu_addr                  = dg::network_tile_member_getsetter::get_pacm_rcu_addr_nothrow(event_arr[i].dst);
                //         uma_ptr_t lck_addr                  = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                //         auto fetch_arg                      = AddressFetchArgument{};
                //         fetch_arg.root                      = event_arr[i].dst;
                //         fetch_arg.expected_ops_id           = event_arr[i].operatable_id;
                //         fetch_arg.fetching_lhs_addr         = std::next(left_descendant_arr.get(), i * PACM_ACM_SZ);
                //         fetch_arg.fetching_rhs_addr         = std::next(right_descendant_arr.get(), i * PACM_ACM_SZ);
                //         fetch_arg.fetching_validation_addr  = std::next(validation_arr.get(), i);

                //         dg::network_producer_consumer::delvrsrv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                //     }
                // }

                // {
                //     auto internal_resolutor                     = InternalResolutor{};
                //     internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                //     internal_resolutor.host_async_device        = this->host_async_device.get();
                //     internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                //     internal_resolutor.vectorization_sz         = this->backward_vectorization_sz;

                //     size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                //     size_t vdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                //     dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                //     auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_kv_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                //     for (size_t i = 0u; i < sz; ++i){
                //         if (!validation_arr[i]){
                //             continue;
                //         }

                //         size_t lck_region_sz                = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                //         uma_ptr_t * lck_addr_ptr            = std::next(lck_addr_arr.get(), i * LCK_ADDR_SZ_PER_DISPATCH);
                //         lck_addr_ptr[0u]                    = dg::memult::region(dg::network_tile_member_getsetter::get_pacm_rcu_addr_nothrow(event_arr[i].dst), lck_region_sz); 
                //         bool validation_flag                = true;
                //         uma_ptr_t * left_descendant_ptr     = std::next(left_descendant_arr.get(), i * PACM_ACM_SZ);
                //         uma_ptr_t * right_descendant_ptr    = std::next(right_descendant_arr.get(), i * PACM_ACM_SZ);

                //         for (size_t j = 0u; j < PACM_ACM_SZ; ++j){
                //             std::expected<uma_ptr_t, exception_t> lhs_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(left_descendant_ptr[j]);
                //             std::expected<uma_ptr_t, exception_t> rhs_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(right_descendant_ptr[j]);

                //             if (!lhs_rcu_addr.has_value() || !rhs_rcu_addr.has_value()){
                //                 validation_flag = false;
                //                 break;
                //             }

                //             lck_addr_ptr[j * 2 + 1] = dg::memult::region(lhs_rcu_addr.value(), lck_region_sz);
                //             lck_addr_ptr[j * 2 + 2] = dg::memult::region(rhs_rcu_addr.value(), lck_region_sz);
                //         }

                //         if (!validation_flag){
                //             continue;
                //         }

                //         auto key                        = dg::vector_view<uma_ptr_t, LCK_ADDR_SZ_PER_DISPATCH>(lck_addr_ptr);
                //         auto resolutor_arg              = ResolutorArgument{};
                //         resolutor_arg.root              = event_arr[i].dst;
                //         resolutor_arg.expected_ops_id   = event_arr[i].operatable_id;
                //         resolutor_arg.left_descendant   = left_descendant_ptr;
                //         resolutor_arg.right_descendant  = right_descendant_ptr;

                //         dg::network_producer_consumer::delvrsrv_deliver(vectorized_delivery_handle.get(), key, resolutor_arg);
                //     }
                // }
            }

        private:

            struct DispatchRadixArgument{
                dg::array_view<uma_ptr_t, PACM_ACM_SZ> lhs;
                dg::array_view<uma_ptr_t, PACM_ACM_SZ> rhs;
                device_id_t dst_grad_vd_id;
                dg::array_view<device_id_t, PACM_ACM_SZ> lhs_grad_vd_id;
                dg::array_view<device_id_t, PACM_ACM_SZ> lhs_logit_vd_id;
                dg::array_view<device_id_t, PACM_ACM_SZ> rhs_grad_vd_id;
                dg::array_view<device_id_t, PACM_ACM_SZ> rhs_logit_vd_id;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                DispatchRadixArgument * fetching_addr;
                bool * validation_bit;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_pacm_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_pacm_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    *data_arr[i].validation_bit = true;

                                    dg::network_tile_member_getsetter::get_pacm_left_descendant_nothrow(data_arr[i].root, data_arr[i].fetching_addr->lhs.data());
                                    dg::network_tile_member_getsetter::get_pacm_right_descendant_nothrow(data_arr[i].root, data_arr[i].fetching_addr->rhs.data());

                                    size_t dispatch_control_bsz = dg::network_tile_member_getsetter::get_pacm_backward_dispatch_control_byte_size_nothrow(data_arr[i].root);
                                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> dispatch_control_buf(dispatch_control_bsz);
                                    dg::network_tile_member_getsetter::get_pacm_backward_dispatch_control_nothrow(data_arr[i].root, dispatch_control_buf.get());

                                    dg::network_dispatch_control::read_pacm_backward_dispatch_root_grad_virtual_device_id_nothrow(dispatch_control_buf.get(), &data_arr[i].fetching_addr->dst_grad_vd_id);
                                    dg::network_dispatch_control::read_pacm_backward_dispatch_lhs_grad_virtual_device_id_nothrow(dispatch_control_buf.get(), data_arr[i].fetching_addr->lhs_grad_vd_id.data());
                                    dg::network_dispatch_control::read_pacm_backward_dispatch_lhs_logit_virtual_device_id_nothrow(dispatch_control_buf.get(), data_arr[i].fetching_addr->lhs_logit_vd_id.data());
                                    dg::network_dispatch_control::read_pacm_backward_dispatch_rhs_grad_virtual_device_id_nothrow(dispatch_control_buf.get(), data_arr[i].fetching_addr->rhs_grad_vd_id.data());
                                    dg::network_dispatch_control::read_pacm_backward_dispatch_rhs_logit_virtual_device_id_nothrow(dispatch_control_buf.get(), data_arr[i].fetching_addr->rhs_logit_vd_id.data());
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };
            
            struct CudaResolutorArgument{
                dg::array_view<cuda_ptr_t, PACM_ACM_SZ> lhs_grad;
                dg::array_view<cuda_ptr_t, PACM_ACM_SZ> lhs_logit;
                dg::array_view<grad_status_t, PACM_ACM_SZ> lhs_grad_status;
                dg::array_view<cuda_ptr_t, PACM_ACM_SZ> rhs_grad;
                dg::array_view<cuda_ptr_t, PACM_ACM_SZ> rhs_logit;
                dg::array_view<grad_status_t, PACM_ACM_SZ> rhs_grad_status;
                cuda_ptr_t dst_grad;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;
                dg::network_allocation::ArenaAllocatorInterface * allocator;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    const size_t DISPATCH_ARR_SZ    = PACM_ACM_SZ + PACM_ACM_SZ + PACM_ACM_SZ + PACM_ACM_SZ + 1u; 
                    size_t cuda_ptr_arr_sz          = sz * DISPATCH_ARR_SZ;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity         = {};

                    size_t virtual_wo_vec_bsz       = dg::network_cuda_controller::get_preallocated_virtual_sequential_container_size(sz);
                    char * virtual_wo_vec_buf       = dg::network_exception_handler::nothrow_log(this->allocator->malloc(virtual_wo_vec_bsz));
                    auto virtual_wo_vec             = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_preallocated_virtual_sequential_container(sz, virtual_wo_vec_buf));

                    for (size_t i = 0u; i < sz; ++i){
                        auto cpy_ptr            = std::copy(data_arr[i].lhs_grad.begin(), data_arr[i].lhs_grad.end(), std::next(cuda_ptr_arr.get(), i * DISPATCH_ARR_SZ));
                        cpy_ptr                 = std::copy(data_arr[i].lhs_logit.begin(), data_arr[i].lhs_logit.end(), cpy_ptr);
                        cpy_ptr                 = std::copy(data_arr[i].rhs_grad.begin(), data_arr[i].rhs_grad.end(), cpy_ptr);
                        cpy_ptr                 = std::copy(data_arr[i].rhs_logit.begin(), data_arr[i].rhs_logit.end(), cpy_ptr);
                        *cpy_ptr                = data_arr[i].dst_grad;

                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_pacm_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;

                        size_t lhs_grad_bsz     = dg::network_allocation::get_preallocated_array_size<cuda_ptr_t>(PACM_ACM_SZ);
                        char * lhs_grad_buf     = dg::network_exception_handler::nothrow_log(this->allocator->malloc(lhs_grad_bsz));
                        auto lhs_grad           = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<cuda_ptr_t>(PACM_ACM_SZ, lhs_grad_buf));
                        std::copy(data_arr[i].lhs_grad.begin(), data_arr[i].lhs_grad.end(), lhs_grad->begin());

                        size_t lhs_logit_bsz    = dg::network_allocation::get_preallocated_array_size<cuda_ptr_t>(PACM_ACM_SZ);
                        char * lhs_logit_buf    = dg::network_exception_handler::nothrow_log(this->allocator->malloc(lhs_logit_bsz));
                        auto lhs_logit          = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<cuda_ptr_t>(PACM_ACM_SZ, lhs_logit_buf));
                        std::copy(data_arr[i].lhs_logit.begin(), data_arr[i].lhs_logit.end(), lhs_logit->begin());

                        size_t lhs_grad_wop_bsz = dg::network_allocation::get_preallocated_array_size<cuda_write_option_t>(PACM_ACM_SZ);
                        char * lhs_grad_wop_buf = dg::network_exception_handler::nothrow_log(this->allocator->malloc(lhs_grad_wop_bsz));
                        auto lhs_grad_wop       = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<cuda_write_option_t>(PACM_ACM_SZ, lhs_grad_wop_buf));
                        std::transform(data_arr[i].lhs_grad_status.begin(), data_arr[i].lhs_grad_status.end(), lhs_grad_wop->begin(), convert_grad_status_to_cuda_write_option_lambda);

                        size_t rhs_grad_bsz     = dg::network_allocation::get_preallocated_array_size<cuda_ptr_t>(PACM_ACM_SZ);
                        char * rhs_grad_buf     = dg::network_exception_handler::nothrow_log(this->allocator->malloc(rhs_grad_bsz));
                        auto rhs_grad           = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<cuda_ptr_t>(PACM_ACM_SZ, rhs_grad_buf));
                        std::copy(data_arr[i].rhs_grad.begin(), data_arr[i].rhs_grad.end(), rhs_grad->begin());

                        size_t rhs_logit_bsz    = dg::network_allocation::get_preallocated_array_size<cuda_ptr_t>(PACM_ACM_SZ);
                        char * rhs_logit_buf    = dg::network_exception_handler::nothrow_log(this->allocator->malloc(rhs_logit_bsz));
                        auto rhs_logit          = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<cuda_ptr_t>(PACM_ACM_SZ, rhs_logit_buf));
                        std::copy(data_arr[i].rhs_logit.begin(), data_arr[i].rhs_logit.end(), rhs_logit->begin());

                        size_t rhs_grad_wop_bsz = dg::network_allocation::get_preallocated_array_size<cuda_write_option_t>(PACM_ACM_SZ);
                        char * rhs_grad_wop_buf = dg::network_exception_handler::nothrow_log(this->allocator->malloc(rhs_grad_wop_bsz));
                        auto rhs_grad_wop       = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<cuda_write_option_t>(PACM_ACM_SZ, rhs_grad_wop_buf));
                        std::transform(data_arr[i].rhs_grad_status.begin(), data_arr[i].rhs_grad_status.end(), rhs_grad_wop->begin(), convert_grad_status_to_cuda_write_option_lambda);

                        auto work_order = [lhs_grad_cpy     = std::move(lhs_grad),
                                           lhs_logit_cpy    = std::move(lhs_logit),
                                           lhs_grad_wop_cpy = std::move(lhs_grad_wop),
                                           rhs_grad_cpy     = std::move(rhs_grad),
                                           rhs_logit_cpy    = std::move(rhs_logit),
                                           rhs_grad_wop_cpy = std::move(rhs_grad_wop),
                                           dst              = data_arr[i].dst_grad,
                                           dispatch_control = data_arr[i].dispatch_control]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_pacm(lhs_grad_cpy->data(), lhs_logit_cpy->data(), lhs_grad_wop_cpy->data(), 
                                                                                                                    rhs_grad_cpy->data(), rhs_logit_cpy->data(), rhs_grad_wop_cpy->data(), //we might want to use array_view for clarity
                                                                                                                    dst, dispatch_control)); //
                        };

                        size_t virtual_wo_bsz   = dg::network_cuda_controller::get_preallocated_virtual_async_task_size(work_order);
                        char * virtual_wo_buf   = dg::network_exception_handler::nothrow_log(this->allocator->malloc(virtual_wo_bsz));
                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_preallocated_virtual_async_task(work_order, virtual_wo_buf));

                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                dg::array_view<host_ptr_t, PACM_ACM_SZ> lhs_grad;
                dg::array_view<host_ptr_t, PACM_ACM_SZ> lhs_logit;
                dg::array_view<grad_status_t, PACM_ACM_SZ> lhs_grad_status;
                dg::array_view<host_ptr_t, PACM_ACM_SZ> rhs_grad;
                dg::array_view<host_ptr_t, PACM_ACM_SZ> rhs_logit;
                dg::array_view<grad_status_t, PACM_ACM_SZ> rhs_grad_status;
                host_ptr_t dst_grad;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{
                
                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;
                dg::network_allocation::ArenaAllocatorInterface * allocator;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    const size_t DISPATCH_ARR_SZ    = PACM_ACM_SZ + PACM_ACM_SZ + PACM_ACM_SZ + PACM_ACM_SZ + 1u;
                    size_t host_ptr_arr_sz          = sz * DISPATCH_ARR_SZ;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity         = {};

                    size_t virtual_wo_vec_bsz       = dg::network_host_asynchronous::get_preallocated_virtual_sequential_container_size(sz);
                    char * virtual_wo_vec_buf       = dg::network_exception_handler::nothrow_log(this->allocator->malloc(virtual_wo_vec_bsz));
                    auto virtual_wo_vec             = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_preallocated_virtual_sequential_container(sz, virtual_wo_vec_buf));

                    for (size_t i = 0u; i < sz; ++i){
                        auto cpy_ptr            = std::copy(data_arr[i].lhs_grad.begin(), data_arr[i].lhs_grad.end(), std::next(host_ptr_arr.get(), i * DISPATCH_ARR_SZ));
                        cpy_ptr                 = std::copy(data_arr[i].lhs_logit.begin(), data_arr[i].lhs_logit.end(), cpy_ptr);
                        cpy_ptr                 = std::copy(data_arr[i].rhs_grad.begin(), data_arr[i].rhs_grad.end(), cpy_ptr);
                        cpy_ptr                 = std::copy(data_arr[i].rhs_logit.begin(), data_arr[i].rhs_logit.end(), cpy_ptr);
                        *cpy_ptr                = data_arr[i].dst_grad;

                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_pacm_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;

                        size_t lhs_grad_bsz     = dg::network_allocation::get_preallocated_array_size<host_ptr_t>(PACM_ACM_SZ);
                        char * lhs_grad_buf     = dg::network_exception_handler::nothrow_log(this->allocator->malloc(lhs_grad_bsz));
                        auto lhs_grad           = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<host_ptr_t>(PACM_ACM_SZ, lhs_grad_buf));
                        std::copy(data_arr[i].lhs_grad.begin(), data_arr[i].lhs_grad.end(), lhs_grad->begin());

                        size_t lhs_logit_bsz    = dg::network_allocation::get_preallocated_array_size<host_ptr_t>(PACM_ACM_SZ);
                        char * lhs_logit_buf    = dg::network_exception_handler::nothrow_log(this->allocator->malloc(lhs_logit_bsz));
                        auto lhs_logit          = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<host_ptr_t>(PACM_ACM_SZ, lhs_logit_buf));
                        std::copy(data_arr[i].lhs_logit.begin(), data_arr[i].lhs_logit.end(), lhs_logit->begin());

                        size_t lhs_grad_wop_bsz = dg::network_allocation::get_preallocated_array_size<host_write_option_t>(PACM_ACM_SZ);
                        char * lhs_grad_wop_buf = dg::network_exception_handler::nothrow_log(this->allocator->malloc(lhs_grad_wop_bsz));
                        auto lhs_grad_wop       = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<host_write_option_t>(PACM_ACM_SZ, lhs_grad_wop_buf));
                        std::tranform(data_arr[i].lhs_grad_status.begin(), data_arr[i].lhs_grad_status.end(), lhs_grad_wop->begin(), convert_grad_status_to_host_write_option_lambda);

                        size_t rhs_grad_bsz     = dg::network_allocation::get_preallocated_array_size<host_ptr_t>(PACM_ACM_SZ);
                        char * rhs_grad_buf     = dg::network_exception_handler::nothrow_log(this->allocator->malloc(rhs_grad_bsz));
                        auto rhs_grad           = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<host_ptr_t>(PACM_ACM_SZ, rhs_grad_buf));
                        std::copy(data_arr[i].rhs_grad.begin(), data_arr[i].rhs_grad.end(), rhs_grad->begin());

                        size_t rhs_logit_bsz    = dg::network_allocation::get_preallocated_array_size<host_ptr_t>(PACM_ACM_SZ);
                        char * rhs_logit_buf    = dg::network_exception_handler::nothrow_log(this->allocator->malloc(rhs_logit_bsz));
                        auto rhs_logit          = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<host_ptr_t>(PACM_ACM_SZ, rhs_logit_buf));
                        std::copy(data_arr[i].rhs_logit.begin(), data_arr[i].rhs_logit.end(), rhs_logit->begin());

                        size_t rhs_grad_wop_bsz = dg::network_allocation::get_preallocated_array_size<host_write_option_t>(PACM_ACM_SZ);
                        char * rhs_grad_wop_buf = dg::network_exception_handler::nothrow_log(this->allocator->malloc(rhs_grad_wop_bsz));
                        auto rhs_grad_wop       = dg::network_exception_handler::nothrow_log(dg::network_allocation::make_preallocated_array<host_write_option_t>(PACM_ACM_SZ, rhs_grad_wop_buf));
                        std::transform(data_arr[i].rhs_grad_status.begin(), data_arr[i].rhs_grad_status.end(), rhs_grad_wop->begin(), convert_grad_status_to_host_write_option_lambda); 

                        auto work_order = [lhs_grad_cpy     = std::move(lhs_grad),
                                           lhs_logit_cpy    = std::move(lhs_logit),
                                           lhs_grad_wop_cpy = std::move(lhs_grad_wop),
                                           rhs_grad_cpy     = std::move(rhs_grad),
                                           rhs_logit_cpy    = std::move(rhs_logit),
                                           rhs_grad_wop_cpy = std::move(rhs_grad_wop),
                                           dst              = data_arr[i].dst_grad,
                                           dispatch_control = data_arr[i].dispatch_control]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_pacm(lhs_grad_cpy->data(), lhs_logit_cpy->data(), lhs_grad_wop_cpy->data(),
                                                                                                                    rhs_grad_cpy->data(), rhs_logit_cpy->data(), rhs_grad_wop_cpy->data(),
                                                                                                                    dst, dispatch_control)); //
                        };
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{

            };
            
            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                dg::network_allocation::ArenaAllocatorInterface * allocator;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard_range mem_grd(key.lck_addr.begin(), key.lck_addr.end());

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;
                    cuda_internal_resolutor.allocator               = this->allocator;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;
                    host_internal_resolutor.allocator               = this->allocator;

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (std::memcmp(lhs_init_status.data(), expecting_lhs_init_status.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(init_status_t)) != 0){
                            continue;
                        }

                        if (std::memcmp(rhs_init_status.data(), expecting_rhs_init_status.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(init_status_t)) != 0){
                            continue;
                        }

                        if (std::memcmp(lhs.data(), dst_lhs.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(uma_ptr_t)) != 0){
                            continue;
                        }

                        if (std::memcmp(rhs.data(), dst_rhs.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(uma_ptr_t)) != 0){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (std::memcmp(lhs_bwd_operatable_id.data(), expecting_lhs_bwd_operatable_id.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(operatable_id_t)) != 0){
                            continue;
                        }

                        if (std::memcmp(rhs_bwd_operatable_id.data(), expecting_rhs_bwd_operatable_id.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(operatable_id_t)) != 0){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        dg::network_dispatch_control::read_pacm_backward_dispatch_root_grad_virtual_device_id(dispatch_control_buf.get(), &dst_grad_vd_id);
                        dg::network_dispatch_control::read_pacm_backward_dispatch_lhs_grad_virtual_device_id(dispatch_control_buf.get(), lhs_grad_vd_id.data());
                        dg::network_dispatch_control::read_pacm_backward_dispatch_lhs_logit_virtual_device_id(dispatch_control_buf.get(), lhs_logit_vd_id.data());
                        dg::network_dispatch_control::read_pacm_backward_dispatch_rhs_grad_virtual_device_id(dispatch_control_buf.get(), rhs_grad_vd_id.data());
                        dg::network_dispatch_control::read_pacm_backward_dispatch_rhs_logit_virtual_device_id(dispatch_control_buf.get(), rhs_logit_vd_id.data());
                        dg::network_dispatch_control::read_pacm_backward_dispatch_dispatch_platform(dispatch_control_buf.get(), &dispatch_platform);

                        if (std::memcmp(lhs_grad_vd_id.data(), key.lhs_grad_vd_id.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(device_id_t)) != 0){
                            continue;
                        }

                        if (std::memcmp(lhs_logit_vd_id.data(), key.lhs_logit_vd_id.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(device_id_t)) != 0){
                            continue;
                        }

                        if (std::memcmp(rhs_grad_vd_id.data(), key.rhs_grad_vd_id.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(device_id_t)) != 0){
                            continue;
                        }

                        if (std::memcmp(rhs_logit_vd_id.data(), key.rhs_logit_vd_id.data(), static_cast<size_t>(PACM_ACM_SZ) * sizeof(device_id_t)) != 0){
                            continue;
                        }

                        if (dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_platform)){
                            auto cuda_resolutor_arg = CudaResolutorArgument{};

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg);
                        } else if(dg::network_dispatch_control::is_host_dispatch(dispatch_platform)){
                            auto host_resolutor_arg = HostResolutorArgument{};

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        for (size_t j = 0u; j < PACM_ACM_SZ; ++j){
                            auto lhs_gradset_err = dg::network_tile_member_getsetter::set_tile_grad_status(lhs[j], TILE_GRAD_STATUS_HAS_VALUE);

                            if (dg::network_exception::is_failed(lhs_gradset_err)){
                                (void) lhs_gradset_err;
                            }

                            auto rhs_gradset_err = dg::network_tile_member_getsetter::set_tile_grad_status(rhs[j], TILE_GRAD_STATUS_HAS_VALUE);

                            if (dg::network_exception::is_failed(rhs_gradset_err)){
                                (void) rhs_gradset_err;
                            }

                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(lhs[j], expected_ops_id)));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(rhs[j], expected_ops_id)));
                        }

                        dg::network_tile_member_getsetter::set_pacm_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                    }

                }
            };
    };

    //clear
    class BackwardDoCritSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;

        public:

            BackwardDoCritSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                          std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                          std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                          size_t request_delivery_capacity,
                                          size_t radxfetch_vectorization_sz,
                                          size_t region_vectorization_sz,
                                          size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                      cuda_async_device(std::move(cuda_async_device)),
                                                                                      host_async_device(std::move(host_async_device)),
                                                                                      request_delivery_capacity(request_delivery_capacity),
                                                                                      radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                      region_vectorization_sz(region_vectorization_sz),
                                                                                      backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_crit_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = 1u;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_crit_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->backward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr              = dg::network_tile_member_getsetter::get_crit_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key                  = ResolutorKeyArgument{};
                        resolutor_key.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key.src_grad_vd_id        = dispatch_radix_arg_arr[i]->src_grad_vd_id; 
                        resolutor_key.src_logit_vd_id       = dispatch_radix_arg_arr[i]->src_logit_vd_id;
                        resolutor_key.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val                  = ResolutorValueArgument{};
                        resolutor_val.dst                   = event_arr[i].dst;
                        resolutor_val.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key, resolutor_val);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t lck_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(lck_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_crit_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_crit_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_crit_backward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_crit_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_crit_backward_dispatch(data_arr[i].root)); 
                                    dispatch_radix.src_grad_vd_id       = dispatch_info.src_grad_vd_id; 
                                    dispatch_radix.src_logit_vd_id      = dispatch_info.src_logit_vd_id;
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t src_grad_ptr;
                cuda_ptr_t src_logit_ptr;
                cuda_ptr_t dst_grad_ptr;
                grad_status_t src_grad_status;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 3]     = data_arr[i].src_grad_ptr;
                        cuda_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_ptr;
                        cuda_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_crit_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_crit(e.src_grad_ptr, e.src_logit_ptr, e.dst_grad_ptr,
                                                                                                                    e.dispatch_control, convert_grad_status_to_cuda_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t src_grad_ptr;
                host_ptr_t src_logit_ptr;
                host_ptr_t dst_grad_ptr;
                grad_status_t src_grad_status;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {}; 
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 3]     = data_arr[i].src_grad_ptr;
                        host_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_ptr;
                        host_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_crit_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_crit(e.src_grad_ptr, e.src_logit_ptr, e.dst_grad_ptr,
                                                                                                                    e.dispatch_control, convert_grad_status_to_host_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 3u>{}));
                    auto src_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_logit_vmamap_reacquirer                = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto dst_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get())); 

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]            = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                           = dg::network_tile_member_getsetter::get_crit_descendant_nothrow(dst);
                        operatable_id_t dst_bwd_operatable_id       = dg::network_tile_member_getsetter::get_crit_operatable_backward_id_nothrow(dst);
                        operatable_id_t dst_operatable_id           = dg::network_tile_member_getsetter::get_crit_operatable_memevent_id_nothrow(dst);
                        init_status_t dst_init_status               = dg::network_tile_member_getsetter::get_crit_init_status_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr                   = dg::network_tile_member_getsetter::get_crit_grad_addr_nothrow(dst);
                        uma_ptr_t dst_crit_umaptr                   = dg::network_tile_member_getsetter::get_crit_crit_addr_nothrow(dst);
                        uma_ptr_t dst_grad_status                   = dg::network_tile_member_getsetter::get_crit_grad_status_nothrow(dst);
                        dispatch_control_t dispatch_control         = dg::network_tile_member_getsetter::get_crit_backward_dispatch_control_nothrow(dst);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_crit_signal_smph_addr_nothrow(dst);

                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<operatable_id_t, exception_t> src_bwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_backward_id(src);
                        std::expected<uma_ptr_t, exception_t> src_grad_umaptr               = dg::network_tile_member_getsetter::get_tile_grad_addr(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src);
                        std::expected<grad_status_t, exception_t> src_grad_status           = dg::network_tile_member_getsetter::get_tile_grad_status(src);

                        if (!src_init_status.has_value() || !src_bwd_operatable_id.has_value() || !src_grad_umaptr.has_value() 
                            || !src_logit_umaptr.has_value() || !src_grad_status.has_value()){

                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_bwd_operatable_id != src_bwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_crit_backward_dispatch(dispatch_control));

                        if (dispatch_info.src_grad_vd_id != key.src_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_logit_vd_id != key.src_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        } 

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_umamap::region_reacquirer_reacquire_nothrow(umamap_reacquirer, {{src_grad_umaptr.value(), dispatch_info.src_grad_vd_id},
                                                                                                    {src_logit_umaptr.value(), dispatch_info.src_logit_vd_id},
                                                                                                    {dst_grad_umaptr, dispatch_info.dst_grad_vd_id}});

                        vma_ptr_t src_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t dst_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(src_grad_vmamap_reacquirer, src_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dst_grad_vmaptr);

                        if (dg::dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.src_grad_ptr     = dg::network_vmamap::get_cuda_ptr(src_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_logit_ptr    = dg::network_vmamap::get_cuda_ptr(src_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_cuda_ptr(dst_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_grad_status  = src_grad_status.value();
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg.src_logit_ptr, cuda_resolutor_arg);
                        } else if (dg::dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.src_grad_ptr     = dg::network_vmamap::get_host_ptr(src_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_logit_ptr    = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_grad_status  = src_grad_status.value();
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg.src_logit_ptr, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_crit_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                        exception_t src_gradset_err = dg::network_tile_member_getsetter::set_tile_grad_status(src, TILE_GRAD_STATUS_HAS_VALUE);

                        if (dg::network_exception::is_failed(src_gradset_err)){
                            (void) src_gradset_err;
                        }

                        if (!signal_smph_addr.has_value()){
                            auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(src, expected_ops_id));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        } else{
                            auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_backward_do_signal(signal_smph_addr.value(), src, expected_ops_id));
                            auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        }
                    }
                }
            };
    };

    //clear
    class BackwardDoImmuSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_immu_ptr_access(event.dst);
                
                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    //clear
    class BackwardDoExtnSrcSignalResolutor: public virtual dg::network_produer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;

        public:

            BackwardDoExtnSrcSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                             std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                             std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                             size_t request_delivery_capacity,
                                             size_t radxfetch_vectorization_sz,
                                             size_t region_vectorization_sz,
                                             size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                         cuda_async_device(std::move(cuda_async_device)),
                                                                                         host_async_device(std::move(host_async_device)),
                                                                                         request_delivery_capacity(request_delivery_capacity),
                                                                                         radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                         region_vectorization_sz(region_vectorization_sz),
                                                                                         backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrc_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = 1u;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_extnsrc_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = AddressFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->backward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr  = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;                            
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_extnsrc_rcu_addr_nothrow(event_arr[i].dst); 

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.src_grad_vd_id        = dispatch_radix_arg_arr[i]->src_grad_vd_id;
                        resolutor_key_arg.src_logit_vd_id       = dispatch_radix_arg_arr[i]->src_logit_vd_id;
                        resolutor_key_arg.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDescendantAddressFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, AddressFetcherArgument * data_arr, size_t sz){

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_extnsrc_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_extnsrc_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_extnsrc_backward_dispatch_control_nothrow(data_arr[i].root); 
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_extnsrc_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extnsrc_backward_dispatch(dispatch_control));
                                    dispatch_radix.src_grad_vd_id       = dispatch_info.src_grad_vd_id;
                                    dispatch_radix.src_logit_vd_id      = dispatch_info.src_logit_vd_id;
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t src_grad_ptr;
                cuda_ptr_t src_logit_ptr;
                cuda_ptr_t dst_grad_ptr;
                cuda_tileops_dispatch_control_t dispatch_control;
                grad_status_t src_grad_status;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz)); 

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 3]     = data_arr[i].src_grad_ptr;
                        cuda_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_ptr;
                        cuda_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_mono(e.src_grad_ptr, e.src_logit_ptr, e.dst_grad_ptr, 
                                                                                                                    e.dispatch_control, convert_grad_status_to_cuda_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo))); 
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t src_grad_ptr;
                host_ptr_t src_logit_ptr;
                host_ptr_t dst_grad_ptr;
                host_tileops_dispatch_control_t dispatch_control;
                grad_status_t src_grad_status;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 3]     = data_arr[i].src_grad_ptr;
                        host_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_ptr;
                        host_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_mono(e.src_grad_ptr, e.src_logit_ptr, e.dst_grad_ptr, 
                                                                                                                    e.dispatch_control, convert_grad_status_to_host_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 3u>{}));
                    auto src_logit_vmamap_reacquirer                = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize()); 
                    auto dst_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer)); 
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get())); 

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src expected_ops_id]             = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);

                        uma_ptr_t dst_src                           = dg::network_tile_member_getsetter::get_extnsrc_descendant_nothrow(dst);
                        operatable_id_t dst_operatable_id           = dg::network_tile_member_getsetter::get_extnsrc_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_bwd_operatable_id       = dg::network_tile_member_getsetter::get_extnsrc_operatable_backward_id_nothrow(dst);
                        init_status_t dst_init_status               = dg::network_tile_member_getsetter::get_extnsrc_init_status_nothrow(dst);
                        dispatch_control_t dispatch_control         = dg::network_tile_member_getsetter::get_extnsrc_backward_dispatch_control_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr                   = dg::network_tile_member_getsetter::get_extnsrc_grad_addr_nothrow(dst);
                        grad_status_t dst_grad_status               = dg::network_tile_member_getsetter::get_extnsrc_grad_status_nothrow(dst);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_extnsrc_signal_smph_addr_nothrow(dst);

                        std::expected<operatable_id_t, exception_t> src_bwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_backward_id(src);
                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<uma_ptr_t, exception_t> src_grad_umaptr               = dg::network_tile_member_getsetter::get_tile_grad_addr(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src);
                        std::expected<grad_status_t, exception_t> src_grad_status           = dg::network_tile_member_getsetter::get_tile_grad_status(src);

                        if (!src_bwd_operatable_id.has_value() || !src_init_status.has_value() || !src_grad_umaptr.has_value() 
                            || !src_logit_umaptr.has_value() || !src_grad_status.has_value()){

                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_bwd_operatable_id != src_bwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extnsrc_backward_dispatch(dispatch_control));

                        if (dispatch_info.src_grad_vd_id != key.src_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_logit_vd_id != key.src_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_reacquire_nothrow(umamap_reacquirer, {{src_grad_umaptr.value(), dispatch_info.src_grad_vd_id},
                                                                                                 {src_logit_umaptr.value(), dispatch_info.src_logit_vd_id},
                                                                                                 {dst_grad_umaptr, dispatch_info.dst_grad_vd_id}});

                        vma_ptr_t src_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t dst_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(src_grad_vmamap_reacquirer, src_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dst_grad_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg                 = CudaResolutorArgument{};
                            cuda_resolutor_arg.src_grad_ptr         = dg::network_vmamap::get_cuda_ptr(src_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_logit_ptr        = dg::network_vmamap::get_cuda_ptr(src_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.dst_grad_ptr         = dg::network_vmamap::get_cuda_ptr(dst_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.dispatch_control     = dispatch_info.tileops_cuda_dispatch_control;
                            cuda_resolutor_arg.src_grad_status      = src_grad_status.value();

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg.src_logit_ptr, cuda_resolutor_arg);                
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg                 = HostResolutorArgument{};
                            host_resolutor_arg.src_grad_ptr         = dg::network_vmamap::get_host_ptr(src_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_logit_ptr        = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.dst_grad_ptr         = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.dispatch_control     = dispatch_info.tileops_host_dispatch_control;
                            host_resolutor_arg.src_grad_status      = src_grad_status.value();

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg.src_logit_ptr, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_extnsrc_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                        exception_t src_gradstat_set_err = dg::network_tile_member_getsetter::set_tile_grad_status(src, TILE_GRAD_STATUS_HAS_VALUE);

                        if (dg::network_exception::is_failed(src_gradstat_set_err)){
                            (void) src_gradstat_set_err;
                            //
                        }

                        if (!signal_smph_addr.has_value()){
                            auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(src, expected_ops_id));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        } else{
                            auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_backward_do_signal(signal_smph_addr.value(), src, expected_ops_id));
                            auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        }
                    }
                }
            };
    };

    //clear
    class BackwardDoExtnSrxSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        public:

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrx_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                (void) event_arr;
            }
    };

    //clear
    class BackwardDoExtnDstSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<Request<external_virtual_memory_event_t>>> request_box; //alrights - we need to do acked request + log 
            const std::shared_ptr<UnifiedMemoryIPRetrieverInterface> uma_ip_retriever;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t gradmove_vectorization_sz;

        public:

            BackwardDoExtnDstSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<Request<external_virtual_memory_event_t>>> request_box,
                                             std::shared_ptr<UnifiedMemoryIPRetrieverInterface> uma_ip_retriever,
                                             std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                             size_t request_delivery_capacity,
                                             size_t radxfetch_vectorization_sz,
                                             size_t region_vectorization_sz,
                                             size_t gradmove_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                         uma_ip_retriever(std::move(uma_ip_retriever)),
                                                                                         host_async_device(std::move(host_async_device)),
                                                                                         request_delivery_capacity(request_delivery_capacity),
                                                                                         radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                         region_vectorization_sz(region_vectorization_sz),
                                                                                         gradmove_vectorization_sz(gradmove_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndst_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = 1u;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get());

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr              = dg::network_tile_member_getsetter::get_extndst_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr              = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetching_arg               = RadixFetcherArgument{};
                        fetching_arg.root               = event_arr[i].dst;
                        fetching_arg.expected_ops_id    = event_arr[i].operatable_id;
                        fetching_arg.fetching_addr      = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetching_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.host_ip_retriever        = this->host_ip_retriever.get();
                    internal_resolutor.uma_ip_retriever         = this->uma_ip_retriever.get();
                    internal_resolutor.vectorization_sz         = this->gradmove_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get())); 

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size())); 
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_extndst_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id; 
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct DispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_extndst_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_extndst_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_extndst_backport_dispatch_control_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extndst_backport_dispatch(dispatch_control));
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;
 
                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct HostResolutorArgument{
                host_ptr_t dst_grad;
                host_ptr_t src_grad;
                size_t cpy_sz; 
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 2;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 2]     = data_arr[i].dst_grad;
                        host_ptr_arr[i * 2 + 1] = data_arr[i].src_grad;
                        total_complexity        += data_arr[i].cpy_sz + data_arr[i].cpy_sz;
                        size_t work_order       = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_memops_clib::memcpy_host_to_host(e.dst_grad, e.src_grad, e.cpy_sz));
                            dg::network_exception_handler::nothrow_log(dg::network_memops_clib::memset(e.src_grad, 0, e.cpy_sz));
                            // dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::grad_move(e.dst, e.src, e.dispatch_control)); //i'm tempted to zero_grad yet we have to assume universal zero-buffer format - this is debatable - we'll move with the obvious, non-ambigous approach for now - sometimes its better to break good practices
                        };

                        auto async_task         = dg::network_host_asynchronous::make_virtual_async_task(work_order);
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(async_task))); 
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<Request<external_virtual_memory_event_t>> * request_delivery_handle;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                UnifiedMemoryIPRetrieverInterface * uma_ip_retriever;
                size_t vectorization_sz; 

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr);

                    dg::network_stack_allocation::NoExceptAllocation<std::optional<ExtnDsxTile>[]> extndsx_arr(sz);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_raii_initialize());
                    auto dst_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
 
                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &restrict_synchronizer;

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hv_allocation_cost                       = dg::network_producer_consumer::delvrsrv_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hv_mem(hv_allocation_cost);
                    auto host_vectorizer                            = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hv_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, expected_ops_id]         = std::make_tuple(data_arr[i].dst, data_arr[i].expected_ops_id);
                        init_status_t dst_init_status       = dg::network_tile_member_getsetter::get_extndst_init_status_nothrow(dst);
                        operatable_id_t dst_operatable_id   = dg::network_tile_member_getsetter::get_extndst_operatable_memevent_id_nothrow(dst);
                        grad_status_t dst_grad_status       = dg::network_tile_member_getsetter::get_extndst_grad_status_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr           = dg::network_tile_member_getsetter::get_extndst_grad_addr_nothrow(dst);
                        dispatch_control_t dispatch_control = dg::network_tile_member_getsetter::get_extndst_backport_dispatch_control_nothrow(dst);  
                        size_t dst_grad_buf_sz              = dg::network_tile_member_getsetter::get_extndst_grad_buf_size_nothrow(dst);

                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extndst_backport_dispatch(dispatch_control)); 

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        extndsx_arr[i]          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<ExtnDsxTile>());
                        auto extndst_metadata   = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<ExtnDstMetadata>());
                        dg::network_tile_member_getsetter::burn_extndst_metadata_nothrow(dst, extndst_metadata);
                        static_cast<ExtnDsxMetadata&>(extndsx_arr[i].value()) = dg::network_tile_member_getsetter::extndst_metadata_to_extndsx_metadata_nothrow(extndst_metadata);

                        dg::network_uma::region_reacquirer_reacquire_nothrow(umamap_reacquirer, dst_grad_umaptr, dispatch_info.dst_grad_vd_id);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dg::network_vmamap::get_vma_ptr(umamap_reacquirer));

                        if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            extndsx_arr[i]->grad        = dg::string(dst_grad_buf_sz, ' '); //TODOs: optimizable - probably malloc with no data fetch 
                            auto host_resolutor_arg     = HostResolutorArgument{};
                            host_resolutor_arg.dst_grad = extndsx_arr[i]->grad.data(); 
                            host_resolutor_arg.src_grad = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.cpy_sz   = dst_grad_buf_sz;

                            dg::network_producer_consumer::delvrsrv_deliver(host_vectorizer.get(), host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else[
                                std::unreachable();
                            ]
                        }

                        dg::network_tile_member_getsetter::set_extndst_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                    }

                    dg::network_producer_consumer::delvrsrv_clear(host_vectorizer.get());
                    host_synchronizer.sync();

                    for (size_t i = 0u; i < sz; ++i){
                        if (!extndsx_arr[i].has_value()){
                            continue;
                        }

                        auto request = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<Request<external_virtual_memory_event_t>>());
                        std::expected<Address, exception_t> to_addr = this->uma_ip_retriever->ip(extndsx_arr[i]->backward_shadow);

                        if (!to_addr.has_value()){
                            dg::network_log::log_user_tile_error(extndsx_arr[i]->user_id, extndsx_arr[i]->backward_shadow, dg::network_exception::verbose(to_addr.error()));
                            continue;
                        }

                        request.requestee           = to_addr.value(); 
                        request.exception_handler   = dg::network_exception::make_exception_handler_from_lambda([user_id = extndsx_arr[i]->user_id, notifying_addr = extndsx_arr[i]->backward_shadow](exception_t err){
                            if (dg::network_exception::is_failed(err)){
                                dg::network_log::log_user_tile_error(user_id, notifying_addr, dg::network_exception::verbose(err));
                            }
                        });

                        auto serialized_tile    = dg::network_compact_serializer::serialize<dg::string>(extndsx_arr[i].value()); //TODOs: optimizable - we might use inplace_buffer - we've yet to know - we'll want to have a runnable debuggable version first
                        auto inject_event       = dg::network_exception_handler::nothrow_log(dg::network_external_memcommit_factory::make_event_shadow_injection(extndsx_arr[i]->backward_shadow, TILE_KIND_EXTNDSX, std::move(serialized_tile)));
                        auto signal_event       = dg::network_exception_handler::nothrow_log(dg::network_external_memcommit_factory::make_event_backward_do_signal(extndsx_arr[i]->backward_shadow, data_arr[i].expected_ops_id));
                        auto event              = dg::network_exception_handler::nothrow_log(dg::network_external_memcommit_factory::make_event_sequential(std::move(inject_event), std::move(signal_event))); 
                        request.content         = std::move(event);

                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(request));
                    }
                }
            };
    }; 

    //clear
    class BackwardDoExtnDsxSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;
        
        public:

            BackwardDoExtnDsxSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                             std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                             std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                             size_t request_delivery_capacity,
                                             size_t radxfetch_vectorization_sz,
                                             size_t region_vectorization_sz,
                                             size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                         host_async_device(std::move(host_async_device)),
                                                                                         cuda_async_device(std::move(cuda_async_device)),
                                                                                         request_delivery_capacity(request_delivery_capacity),
                                                                                         radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                         region_vectorization_sz(region_vectorization_sz),
                                                                                         backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extndsx_ptr_access(event_arr[i].dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = 1u;                
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_extndsx_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->backward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_extndsx_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.src_grad_vd_id        = dispatch_radix_arg_arr[i]->src_grad_vd_id;
                        resolutor_key_arg.src_logit_vd_id       = dispatch_radix_arg_arr[i]->src_logit_vd_id;
                        resolutor_key_arg.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    } 
                }
            }
        
        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_extndsx_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_extndsx_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_extndsx_backward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_extndsx_counterpart_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extndsx_backward_dispatch(dispatch_control));
                                    dispatch_radix.src_grad_vd_id       = dispatch_info.src_grad_vd_id;
                                    dispatch_radix.src_logit_vd_id      = dispatch_info.src_logit_vd_id;
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                            {
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                            }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t src_grad;
                cuda_ptr_t src_logit;
                cuda_ptr_t dst_grad;
                grad_status_t src_grad_status;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg;:network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 3]     = data_arr[i].src_grad;
                        cuda_ptr_arr[i * 3 + 1] = data_arr[i].src_logit;
                        cuda_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity; //future extension of dispatch - probably extndst - extnsrc uses different radix of compression
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_mono(e.src_grad, e.src_logit, e.dst_grad, 
                                                                                                                    e.dispatch_control, convert_grad_status_to_cuda_write_option(e.src_grad_status))); //
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                } 
            };

            struct HostResolutorArgument{
                host_ptr_t src_grad;
                host_ptr_t src_logit;
                host_ptr_t dst_grad;
                grad_status_t src_grad_status;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 3]     = data_arr[i].src_grad;
                        host_ptr_arr[i * 3 + 1] = data_arr[i].src_logit;
                        host_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_mono(e.src_grad, e.src_logit, e.dst_grad,
                                                                                                                    e.dispatch_control, convert_grad_status_to_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo))); 
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity));
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: word_size memcmp + has_unique_object_representations_v
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{
                    
                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 3u>{}));
                    auto src_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_logit_vmamap_reacquirer                = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto dst_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz, cdh_mem.get()));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz, hdh_mem.get())); 

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]    = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        
                        init_status_t dst_init_status       = dg::network_tile_member_getsetter::get_extndsx_init_status_nothrow(dst);
                        uma_ptr_t dst_src                   = dg::network_tile_member_getsetter::get_extndsx_counterpart_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr           = dg::network_tile_member_getsetter::get_extndsx_grad_addr_nothrow(dst);
                        operatable_id_t dst_operatable_id   = dg::network_tile_member_getsetter::get_extndsx_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_backward_ops_id = dg::network_tile_member_getsetter::get_extndsx_operatable_backward_id_nothrow(dst);
                        grad_status_t dst_grad_status       = dg::network_tile_member_getsetter::get_extndsx_grad_status_nothrow(dst);
                        dispatch_control_t dispatch_control = dg::network_tile_member_getsetter::get_extndsx_backward_dispatch_control_nothrow(dst);

                        std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_extnsrc_ptr_access(src);

                        if (!ptrchk.has_value()){
                            continue;
                        } 

                        init_status_t src_init_status       = dg::network_tile_member_getsetter::get_extnsrc_init_status_nothrow(src);
                        operatable_id_t src_backward_ops_id = dg::network_tile_member_getsetter::get_extnsrc_operatable_backward_id_nothrow(src);
                        uma_ptr_t src_grad_umaptr           = dg::network_tile_member_getsetter::get_extnsrc_grad_addr_nothrow(src);
                        uma_ptr_t src_logit_umaptr          = dg::network_tile_member_getsetter::get_extnsrc_logit_addr_nothrow(src);
                        grad_status_t src_grad_status       = dg::network_tile_member_getsetter::get_extnsrc_grad_status_nothrow(src);

                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (src_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_backward_ops_id != src_backward_ops_id){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_extndsx_backward_dispatch(dispatch_control));

                        if (dispatch_info.src_grad_vd_id != key.src_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_logit_vd_id != key.src_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_reacquire_nothrow(umamap_reacquirer, {{src_grad_umaptr, dispatch_info.src_grad_vd_id},
                                                                                                 {src_logit_umaptr, dispatch_info.src_logit_vd_id},
                                                                                                 {dst_grad_umaptr, dispatch_info.dst_grad_vd_id}});

                        vma_ptr_t src_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t dst_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(src_grad_vmamap_reacquirer, src_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dst_grad_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.src_grad         = dg::network_vmamap::get_cuda_ptr(src_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_logit        = dg::network_vmamap::get_cuda_ptr(src_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.dst_grad         = dg::network_vmamap::get_cuda_ptr(dst_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_grad_status  = src_grad_status;
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            dg::network_producer_consumer::delvsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg.src_logit, cuda_resolutor_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.src_grad         = dg::network_vmamap::get_host_ptr(src_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_logit        = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.dst_grad         = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_grad_status  = src_grad_status;
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg.src_logit, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_extndsx_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                        dg::network_tile_member_getsetter::set_extnsrc_grad_status_nothrow(src, TILE_GRAD_STATUS_HAS_VALUE);

                        dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(src, expected_ops_id)));
                    }
                }
            };
    };

    //clear
    class BackwardDoMsgrFwdSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device;
            const size_t request_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;  

        public:

            BackwardDoMsgrFwdSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                             std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                             std::shared_ptr<dg::network_cuda_controller::AsynchronousDeviceInterface> cuda_async_device,
                                             size_t request_delivery_capacity,
                                             size_t radxfetch_vectorization_sz,
                                             size_t region_vectorization_sz,
                                             size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                         host_async_device(std::move(host_async_device)),
                                                                                         cuda_async_device(std::move(cuda_async_device)),
                                                                                         request_delivery_capacity(request_delivery_capacity),
                                                                                         radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                         region_vectorization_sz(region_vectorization_sz),
                                                                                         backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrfwd_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t EVENT_SCALE_FACTOR             = 1u;
                size_t max_possible_event_sz                = sz * EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_event_sz); 
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost); 
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_msgrfwd_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = AddressFetcherArgument{};
                        fetch_arg.dst               = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                     = InternalResolutor{};
                    internal_resolutor.request_delivery_handle  = request_delivery_handle.get();
                    internal_resolutor.cuda_async_device        = this->cuda_async_device.get();
                    internal_resolutor.host_async_device        = this->host_async_device.get();
                    internal_resolutor.vectorization_sz         = this->backward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz      = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost); 
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_msgrfwd_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.src_grad_vd_id        = dispatch_radix_arg_arr[i]->src_grad_vd_id;
                        resolutor_key_arg.src_logit_vd_id       = dispatch_radix_arg_arr[i]->src_logit_vd_id;
                        resolutor_key_arg.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t dst;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVConsumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_msgrfwd_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_msgrfwd_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_msgrfwd_backward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_msgrfwd_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_msgrfwd_backward_dispatch(dispatch_control));
                                    dispatch_radix.src_grad_vd_id       = dispatch_info.src_grad_vd_id;
                                    dispatch_radix.src_logit_vd_id      = dispatch_info.src_logit_vd_id;
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t src_grad_ptr;
                cuda_ptr_t src_logit_ptr;
                cuda_ptr_t dst_grad_ptr;
                grad_status_t src_grad_status;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 3]     = data_arr[i].src_grad_ptr;
                        cuda_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_ptr;
                        cuda_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_mono(e.src_grad_ptr, e.src_logit_ptr, e.dst_grad_ptr, 
                                                                                                                    e.dispatch_control, convert_grad_status_to_cuda_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t src_grad_ptr;
                host_ptr_t src_logit_ptr;
                host_ptr_t dst_grad_ptr;
                grad_status_t src_grad_status;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 3]     = data_arr[i].src_grad_ptr;
                        host_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_ptr;
                        host_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_mono(e.src_grad_ptr, e.src_logit_ptr, e.dst_grad_ptr, 
                                                                                                                    e.dispatch_control, convert_grad_status_to_host_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: word_size cmp + has_unique_object_representations_v
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 3u>{}));
                    auto src_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_logit_vmamap_reacquirer                = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto dst_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                    = InternalCudaResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = InternalHostResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device;
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer; 

                    size_t trimmed_cuda_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t cdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cdh_mem(cdh_allocation_cost);
                    auto cuda_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorization_sz));

                    size_t trimmed_host_vectorization_sz            = std::min(this->vectorization_sz, sz);
                    size_t hdh_allocation_cost                      = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hdh_mem(hdh_allocation_cost);
                    auto host_delivery_handle                       = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorization_sz)); 

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]            = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                           = dg::network_tile_member_getsetter::get_msgrfwd_descendant_nothrow(dst);
                        operatable_id_t dst_bwd_operatable_id       = dg::network_tile_member_getsetter::get_msgrfwd_operatable_backward_id_nothrow(dst);
                        operatable_id_t dst_operatable_id           = dg::network_tile_member_getsetter::get_msgrfwd_operatable_memevent_id_nothrow(dst);
                        init_status_t dst_init_status               = dg::network_tile_member_getsetter::get_msgrfwd_init_status_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr                   = dg::network_tile_member_getsetter::get_msgrfwd_grad_addr_nothrow(dst);
                        grad_status_t dst_grad_status               = dg::network_tile_member_getsetter::get_msgrfwd_grad_status_nothrow(dst);
                        dispatch_control_t dispatch_control         = dg::network_tile_member_getsetter::get_msgrfwd_backward_dispatch_control_nothrow(dst);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_msgrfwd_signal_smph_addr_nothrow(dst);

                        std::expected<operatable_id_t, exception_t> src_bwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_backward_id(src);
                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<uma_ptr_t, exception_t> src_grad_umaptr               = dg::network_tile_member_getsetter::get_tile_grad_addr(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src);
                        std::expected<grad_status_t, exception_t> src_grad_status           = dg::network_tile_member_getsetter::get_tile_grad_status(src);

                        if (!src_bwd_operatable_id.has_value() || !src_init_status.has_value() || !src_grad_umaptr.has_value() 
                            || !src_logit_umaptr.has_value() || !src_grad_status.has_value()){

                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_bwd_operatable_id != src_bwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_msgrfwd_backward_dispatch(dispatch_control));

                        if (dispatch_info.src_grad_vd_id != key.src_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_logit_vd_id != key.src_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_umamap::region_reacquirer_reacquire_nothrow(umamap_reacquirer, {{src_grad_umaptr.value(), dispatch_info.src_grad_vd_id}, 
                                                                                                    {src_logit_umaptr.value(), dispatch_info.src_logit_vd_id},
                                                                                                    {dst_grad_umaptr, dispatch_info.dst_grad_vd_id}});

                        vma_ptr_t src_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{});
                        vma_ptr_t dst_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(src_grad_vmamap_reacquirer, src_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dst_grad_vmaptr);

                        if (dg::dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.src_grad_ptr     = dg::network_vmamap::get_cuda_ptr(src_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_logit_ptr    = dg::network_vmamap::get_cuda_ptr(src_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_cuda_ptr(dst_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_grad_status  = src_grad_status.value();
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_delivery_handle.get(), cuda_resolutor_arg.src_logit_ptr, cuda_resolutor_arg);
                        } else if (dg::dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.src_grad_ptr     = dg::network_vmamap::get_host_ptr(src_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_logit_ptr    = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_grad_status  = src_grad_status.value();
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_delivery_handle.get(), host_resolutor_arg.src_logit_ptr, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_msgrfwd_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                        exception_t src_gradset_err = dg::network_tile_member_getsetter::set_tile_grad_status(src, TILE_GRAD_STATUS_HAS_VALUE);

                        if (dg::network_exception::is_failed(src_gradset_err)){
                            (void) src_gradset_err;
                        }

                        if (!signal_smph_addr.has_value())[
                            auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(src, expected_ops_id));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        ] else{
                            auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_backward_do_signal(signal_smph_addr.value(), src, expected_ops_id));
                            auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        }
                    }
                }
            };
    };

    //clear
    class BackwardDoMsgrBwdSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box;
            const std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<EndUserPacket>> eu_packet_box;
            const std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device;
            const size_t request_delivery_capacity;
            const size_t eu_packet_delivery_capacity;
            const size_t radxfetch_vectorization_sz;
            const size_t region_vectorization_sz;
            const size_t backward_vectorization_sz;

        public:

            BackwardDoMsgrBwdSignalResolutor(std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<virtual_memory_event_t>> request_box,
                                             std::shared_ptr<dg::network_producer_consumer::ConsumerInterface<EndUserPacket>> eu_packet_box,
                                             std::shared_ptr<dg::network_host_asynchronous::AsynchronousDeviceInterface> host_async_device,
                                             size_t request_delivery_capacity,
                                             size_t eu_packet_delivery_capacity,
                                             size_t radxfetch_vectorization_sz,
                                             size_t region_vectorization_sz,
                                             size_t backward_vectorization_sz) noexcept: request_box(std::move(request_box)),
                                                                                         eu_packet_box(std::move(eu_packet_box)),
                                                                                         host_async_device(std::move(host_async_device)),
                                                                                         request_delivery_capacity(request_delivery_capacity),
                                                                                         eu_packet_delivery_capacity(eu_packet_delivery_capacity),
                                                                                         radxfetch_vectorization_sz(radxfetch_vectorization_sz),
                                                                                         region_vectorization_sz(region_vectorization_sz),
                                                                                         backward_vectorization_sz(backward_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<uma_ptr_t, exception_t> ptrchk = dg::network_tile_member_access::safecthrow_msgrbwd_ptr_access(event.dst);

                if (!ptrchk.has_value()){
                    return ptrchk.error();
                }

                return dg::network_exception::SUCCESS;
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                dg::network_stack_allocation::NoExceptAllocation<std::optional<DispatchRadixArgument>[]> dispatch_radix_arg_arr(sz);

                const size_t REQUEST_EVENT_SCALE_FACTOR     = 1u;
                size_t max_possible_request_event_sz        = sz * REQUEST_EVENT_SCALE_FACTOR;
                size_t trimmed_request_delivery_capacity    = std::min(this->request_delivery_capacity, max_possible_request_event_sz);
                size_t rdh_allocation_cost                  = dg::network_producer_consumer::delvrsrv_allocation_cost(this->request_box.get(), trimmed_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> rdh_mem(rdh_allocation_cost);
                auto request_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->request_box.get(), trimmed_request_delivery_capacity, rdh_mem.get()));

                const size_t EUPACKET_EVENT_SCALE_FACTOR    = 1u;
                size_t max_possible_eu_packet_event_sz      = sz * EUPACKET_EVENT_SCALE_FACTOR;
                size_t trimmed_eu_packet_delivery_capacity  = std::min(this->eu_packet_delivery_capacity, max_possible_eu_packet_event_sz);
                size_t epdh_allocation_cost                 = dg::network_producer_consumer::delvrsrv_allocation_cost(this->eu_packet_box.get(), trimmed_eu_packet_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> epdh_mem(epdh_allocation_cost); 
                auto eu_packet_delivery_handle              = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(this->eu_packet_box.get(), trimmed_eu_packet_delivery_capacity, epdh_mem.get()));

                {
                    auto fetcher                                = InternalDispatchRadixFetcher{};

                    size_t trimmed_radxfetch_vectorization_sz   = std::min(this->radxfetch_vectorization_sz, sz);
                    size_t vdh_allocation_cost                  = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&fetcher, trimmed_radxfetch_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle             = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&fetcher, trimmed_radxfetch_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if constexpr(DEBUG_MODE_FLAG){
                            if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                                std::abort();
                            }
                        }

                        uma_ptr_t rcu_addr          = dg::network_tile_member_getsetter::get_msgrbwd_rcu_addr_nothrow(event_arr[i].dst);
                        uma_ptr_t lck_addr          = dg::memult::region(rcu_addr, dg::network_memops_uma::memlock_region_size());
                        auto fetch_arg              = RadixFetcherArgument{};
                        fetch_arg.root              = event_arr[i].dst;
                        fetch_arg.expected_ops_id   = event_arr[i].operatable_id;
                        fetch_arg.fetching_addr     = std::next(dispatch_radix_arg_arr.get(), i);

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), lck_addr, fetch_arg);
                    }
                }

                {
                    auto internal_resolutor                         = InternalResolutor{};
                    internal_resolutor.request_delivery_handle      = request_delivery_handle.get();
                    internal_resolutor.eu_packet_delivery_handle    = eu_packet_delivery_handle.get();
                    internal_resolutor.host_async_device            = this->host_async_device.get();
                    internal_resolutor.allocator                    = &arena_allocator;
                    internal_resolutor.vectorization_sz             = this->backward_vectorization_sz;

                    size_t trimmed_region_vectorization_sz          = std::min(this->region_vectorization_sz, sz);
                    size_t vdh_allocation_cost                      = dg::network_memops_uma::delvrsrv_regionkv_allocation_cost(&internal_resolutor, trimmed_region_vectorization_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> vdh_mem(vdh_allocation_cost);
                    auto vectorized_delivery_handle                 = dg::network_exception_handler::nothrow_log(dg::network_memops_uma::delvrsrv_regionkv_open_preallocated_raiihandle(&internal_resolutor, trimmed_region_vectorization_sz, vdh_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        if (!dispatch_radix_arg_arr[i].has_value()){
                            continue;
                        }

                        std::expected<uma_ptr_t, exception_t> src_rcu_addr = dg::network_tile_member_getsetter::get_tile_rcu_addr(dispatch_radix_arg_arr[i]->src);

                        if (!src_rcu_addr.has_value()){
                            continue;
                        }

                        size_t lck_region_sz                    = std::min(static_cast<size_t>(dg::network_memops_uma::memlock_region_size()), static_cast<size_t>(dg::network_uma::memregion_size()));
                        uma_ptr_t dst_rcu_addr                  = dg::network_tile_member_getsetter::get_msgrbwd_rcu_addr_nothrow(event_arr[i].dst);

                        auto resolutor_key_arg                  = ResolutorKeyArgument{};
                        resolutor_key_arg.dst_region_rcu_addr   = dg::memult::region(dst_rcu_addr, lck_region_sz);
                        resolutor_key_arg.src_region_rcu_addr   = dg::memult::region(src_rcu_addr.value(), lck_region_sz);
                        resolutor_key_arg.src_grad_vd_id        = dispatch_radix_arg_arr[i]->src_grad_vd_id;
                        resolutor_key_arg.src_logit_vd_id       = dispatch_radix_arg_arr[i]->src_logit_vd_id;
                        resolutor_key_arg.dst_grad_vd_id        = dispatch_radix_arg_arr[i]->dst_grad_vd_id;
                        resolutor_key_arg.dispatch_platform     = dispatch_radix_arg_arr[i]->dispatch_platform;

                        auto resolutor_val_arg                  = ResolutorValueArgument{};
                        resolutor_val_arg.dst                   = event_arr[i].dst;
                        resolutor_val_arg.src                   = dispatch_radix_arg_arr[i]->src;
                        resolutor_val_arg.expected_ops_id       = event_arr[i].operatable_id;

                        dg::network_memops_uma::delvrsrv_regionkv_deliver(vectorized_delivery_handle.get(), resolutor_key_arg, resolutor_val_arg);
                    }
                }
            }

        private:

            struct DispatchRadixArgument{
                uma_ptr_t src;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;
            };

            struct RadixFetcherArgument{
                uma_ptr_t root;
                operatable_id_t expected_ops_id;
                std::optional<DispatchRadixArgument> * fetching_addr;
            };

            struct InternalDispatchRadixFetcher: dg::network_producer_consumer::KVCosnumerInterface<uma_ptr_t, RadixFetcherArgument>{

                void push(uma_ptr_t rcu_addr, RadixFetcherArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(rcu_addr);

                    for (size_t i = 0u; i < sz; ++i){
                        init_status_t init_status       = dg::network_tile_member_getsetter::get_msgrbwd_init_status_nothrow(data_arr[i].root);
                        operatable_id_t current_ops_id  = dg::network_tile_member_getsetter::get_msgrbwd_operatable_memevent_id_nothrow(data_arr[i].root);

                        switch (init_status){
                            case TILE_INIT_STATUS_EMPTY: [[fallthrough]]
                            case TILE_INIT_STATUS_ORPHANED: [[fallthrough]]
                            case TILE_INIT_STATUS_ADOPTED: [[fallthrough]]
                            case TILE_INIT_STATUS_DECAYED:
                            {   
                                break;
                            }
                            case TILE_INIT_STATUS_INITIALIZED:
                            {
                                if (current_ops_id == data_arr[i].expected_ops_id){
                                    auto dispatch_radix                 = DispatchRadixArgument{};
                                    auto dispatch_control               = dg::network_tile_member_getsetter::get_msgrbwd_backward_dispatch_control_nothrow(data_arr[i].root);
                                    dispatch_radix.src                  = dg::network_tile_member_getsetter::get_msgrbwd_descendant_nothrow(data_arr[i].root);
                                    auto dispatch_info                  = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_msgrbwd_backward_dispatch(dispatch_control)); 
                                    dispatch_radix.src_grad_vd_id       = dispatch_info.src_grad_vd_id;
                                    dispatch_radix.src_logit_vd_id      = dispatch_info.src_logit_vd_id;
                                    dispatch_radix.dst_grad_vd_id       = dispatch_info.dst_grad_vd_id;
                                    dispatch_radix.dispatch_platform    = dispatch_info.dispatch_platform;

                                    *data_arr[i].fetching_addr          = dispatch_radix;
                                }

                                break;
                            }
                            default:
                                if constexpr(DEBUG_MODE_FLAG){
                                    dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                    std::abort();
                                } else{
                                    std::unreachable();
                                }
                        }
                    }
                }
            };

            struct CudaResolutorArgument{
                cuda_ptr_t src_grad_ptr;
                cuda_ptr_t src_logit_ptr;
                cuda_ptr_t dst_grad_ptr;
                grad_status_t src_grad_status;
                cuda_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalCudaResolutor: dg::network_producer_consumer::ConsumerInterface<CudaResolutorArgument>{

                dg::network_cuda_controller::AsynchronousDeviceInterface * async_device;
                dg::network_cuda_controller::Synchronizer * synchronizer;
                dg::network_cuda_controller::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(CudaResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t cuda_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<cuda_ptr_t[]> cuda_ptr_arr(cuda_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        cuda_ptr_arr[i * 3]     = data_arr[i].src_grad_ptr;
                        cuda_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_ptr;
                        cuda_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]](){
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_cuda_poly::backward_mono(e.src_grad_ptr, e.src_logit_ptr, e.dst_grad_ptr, 
                                                                                                                    e.dispatch_control, convert_grad_status_to_cuda_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_cuda_controller::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(cuda_ptr_arr.get(), std::next(cuda_ptr_arr.get(), cuda_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            struct HostResolutorArgument{
                host_ptr_t src_grad_ptr;
                host_ptr_t src_logit_ptr;
                host_ptr_t dst_grad_ptr;
                grad_status_t src_grad_status;
                host_tileops_dispatch_control_t dispatch_control;
            };

            struct InternalHostResolutor: dg::network_producer_consumer::ConsumerInterface<HostResolutorArgument>{

                dg::network_host_asynchronous::AsynchronousDeviceInterface * async_device;
                dg::network_host_asynchronous::Synchronizer * synchronizer;
                dg::network_host_asynchronous::RestrictPointerSynchronizer * restrict_synchronizer;

                void push(HostResolutorArgument * data_arr, size_t sz) noexcept{

                    size_t host_ptr_arr_sz      = sz * 3;
                    dg::network_stack_allocation::NoExceptAllocation<host_ptr_t[]> host_ptr_arr(host_ptr_arr_sz);
                    size_t total_complexity     = {};
                    auto virtual_wo_vec         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_workorder_sequential_container(sz));

                    for (size_t i = 0u; i < sz; ++i){
                        host_ptr_arr[i * 3]     = data_arr[i].src_grad_ptr;
                        host_ptr_arr[i * 3 + 1] = data_arr[i].src_logit_ptr;
                        host_ptr_arr[i * 3 + 2] = data_arr[i].dst_grad_ptr;
                        total_complexity        += dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::decode_mono_backward_dispatch_control(data_arr[i].dispatch_control)).runtime_complexity;
                        auto work_order         = [e = data_arr[i]]() noexcept{
                            dg::network_exception_handler::nothrow_log(dg::network_tileops_host_poly::backward_mono(e.src_grad_ptr, e.src_logit_ptr, e.dst_grad_ptr, 
                                                                                                                    e.dispatch_control, convert_grad_status_to_host_write_option(e.src_grad_status)));
                        };

                        auto virtual_wo         = dg::network_exception_handler::nothrow_log(dg::network_host_asynchronous::make_virtual_async_task(work_order));
                        dg::network_exception_handler::nothrow_log(virtual_wo_vec->add(std::move(virtual_wo)));
                    }

                    dg::network_exception_handler::nothrow_log(this->restrict_synchronizer->add(host_ptr_arr.get(), std::next(host_ptr_arr.get(), host_ptr_arr_sz)));
                    auto synchronizable = dg::network_exception_handler::nothrow_log(this->async_device->exec(std::move(virtual_wo_vec), total_complexity)); //TODOs: except
                    dg::network_exception_handler::nothrow_log(this->synchronizer->add(std::move(synchronizable)));
                }
            };

            //TODOs: word_size cmp + has_unique_object_representations_v
            struct ResolutorKeyArgument{
                uma_ptr_t dst_region_rcu_addr;
                uma_ptr_t src_region_rcu_addr;
                device_id_t src_grad_vd_id;
                device_id_t src_logit_vd_id;
                device_id_t dst_grad_vd_id;
                platform_t dispatch_platform;

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void dg_reflect(const Reflector& reflector) noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr, src_grad_vd_id, src_logit_vd_id, dst_grad_vd_id, dispatch_platform);
                }

                template <class Reflector>
                constexpr void region_reflect(const Reflector& reflector) const noexcept{
                    reflector(dst_region_rcu_addr, src_region_rcu_addr);
                }
            };

            struct ResolutorValueArgument{
                uma_ptr_t dst;
                uma_ptr_t src;
                operatable_id_t expected_ops_id;
            };

            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<ResolutorKeyArgument, ResolutorValueArgument>{

                dg::network_producer_consumer::DeliveryHandle<virtual_memory_event_t> * request_delivery_handle;
                dg::network_producer_consumer::DeliveryHandle<EndUserPacket> * eu_packet_delivery_handle;
                dg::network_host_asynchronous::AsynchronousDeviceInterface * host_async_device;
                dg::network_cuda_controller::AsynchronousDeviceInterface * cuda_async_device;
                size_t vectorization_sz;

                void push(ResolutorKeyArgument key, ResolutorValueArgument * data_arr, size_t sz) noexcept{

                    dg::network_memops_uma::memlock_guard mem_grd(key.dst_region_rcu_addr, key.src_region_rcu_addr);

                    auto umamap_reacquirer                          = dg::network_exception_handler::nothrow_log(dg::network_uma::region_reacquirer_fixedsize_raii_initialize(std::integral_constant<size_t, 3u>{}));
                    auto dst_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_grad_vmamap_reacquirer                 = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());
                    auto src_logit_vmamap_reacquirer                = dg::network_exception_handler::nothrow_log(dg::network_vmamap::region_remapper_raii_initialize());

                    auto cuda_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_intiialize<dg::network_cuda_controller::Synchronizer>());
                    auto cuda_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_cuda_controller::RestrictPointerSynchronizer>(&cuda_synchronizer));
                    auto cuda_internal_resolutor                    = CudaInternalResolutor{};
                    cuda_internal_resolutor.async_device            = this->cuda_async_device;
                    cuda_internal_resolutor.synchronizer            = &cuda_synchronizer;
                    cuda_internal_resolutor.restrict_synchronizer   = &cuda_restrict_synchronizer;

                    auto host_synchronizer                          = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::Synchronizer>());
                    auto host_restrict_synchronizer                 = dg::network_exception_handler::nothrow_log(dg::network_exception::cstyle_initialize<dg::network_host_asynchronous::RestrictPointerSynchronizer>(&host_synchronizer));
                    auto host_internal_resolutor                    = HostInternalResolutor{};
                    host_internal_resolutor.async_device            = this->host_async_device; 
                    host_internal_resolutor.synchronizer            = &host_synchronizer;
                    host_internal_resolutor.restrict_synchronizer   = &host_restrict_synchronizer;

                    size_t trimmed_cuda_vectorizer_sz               = std::min(this->vectorization_sz, sz);
                    size_t cv_allocation_cost                       = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&cuda_internal_resolutor, trimmed_cuda_vectorizer_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> cv_mem(cv_allocation_cost);
                    auto cuda_vectorizer                            = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&cuda_internal_resolutor, trimmed_cuda_vectorizer_sz, cv_mem.get()));

                    size_t trimmed_host_vectorizer_sz               = std::min(this->vectorization_sz, sz);
                    size_t hv_allocation_cost                       = dg::network_producer_consumer::delvrsrv_keyhint_allocation_cost(&host_internal_resolutor, trimmed_host_vectorizer_sz);
                    dg::network_stack_allocation::NoExceptRawAllocation<char[]> hv_mem(hv_allocation_cost);
                    auto host_vectorizer                            = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_keyhint_preallocated_raiihandle(&host_internal_resolutor, trimmed_host_vectorizer_sz, hv_mem.get()));

                    for (size_t i = 0u; i < sz; ++i){
                        auto [dst, src, expected_ops_id]            = std::make_tuple(data_arr[i].dst, data_arr[i].src, data_arr[i].expected_ops_id);
                        uma_ptr_t dst_src                           = dg::network_tile_member_getsetter::get_msgrbwd_descendant_nothrow(dst);
                        operatable_id_t dst_operatable_id           = dg::network_tile_member_getsetter::get_msgrbwd_operatable_memevent_id_nothrow(dst);
                        operatable_id_t dst_bwd_operatable_id       = dg::network_tile_member_getsetter::get_msgrbwd_operatable_backward_id_nothrow(dst);
                        init_status_t dst_init_status               = dg::network_tile_member_getsetter::get_msgrbwd_init_status_nothrow(dst);
                        grad_status_t dst_grad_status               = dg::network_tile_member_getsetter::get_msgrbwd_grad_status_nothrow(dst);
                        uma_ptr_t dst_grad_umaptr                   = dg::network_tile_member_getsetter::get_msgrbwd_grad_addr_nothrow(dst);
                        dispatch_control_t dispatch_control         = dg::network_tile_member_getsetter::get_msgrbwd_backward_dispatch_control_nothrow(dst);
                        std::optional<uma_ptr_t> signal_smph_addr   = dg::network_tile_member_getsetter::get_msgrbwd_signal_smph_addr_nothrow(dst);

                        std::expected<operatable_id_t, exception_t> src_bwd_operatable_id   = dg::network_tile_member_getsetter::get_tile_operatable_backward_id(src);
                        std::expected<init_status_t, exception_t> src_init_status           = dg::network_tile_member_getsetter::get_tile_init_status(src);
                        std::expected<grad_status_t, exception_t> src_grad_status           = dg::network_tile_member_getsetter::get_tile_grad_status(src);
                        std::expected<uma_ptr_t, exception_t> src_grad_umaptr               = dg::network_tile_member_getsetter::get_tile_grad_addr(src);
                        std::expected<uma_ptr_t, exception_t> src_logit_umaptr              = dg::network_tile_member_getsetter::get_tile_logit_addr(src);
                        
                        if (!src_bwd_operatable_id.has_value() || !src_init_status.has_value() || !src_grad_status.has_value() 
                            || !src_grad_umaptr.has_value() || !src_logit_umaptr.has_value()){

                            continue;
                        }

                        if (dst_init_status != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (src_init_status.value() != TILE_INIT_STATUS_INITIALIZED){
                            continue;
                        }

                        if (dst_src != src){
                            continue;
                        }

                        if (dst_operatable_id != expected_ops_id){
                            continue;
                        }

                        if (dst_bwd_operatable_id != src_bwd_operatable_id.value()){
                            continue;
                        }

                        if (dst_grad_status != TILE_GRAD_STATUS_HAS_VALUE){
                            continue;
                        }

                        auto dispatch_info = dg::network_exception_handler::nothrow_log(dg::network_dispatch_control::decode_msgrbwd_backward_dispatch(dispatch_control)); 

                        if (dispatch_info.src_grad_vd_id != key.src_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.src_logit_vd_id != key.src_logit_vd_id){
                            continue;
                        }

                        if (dispatch_info.dst_grad_vd_id != key.dst_grad_vd_id){
                            continue;
                        }

                        if (dispatch_info.dispatch_platform != key.dispatch_platform){
                            continue;
                        }

                        dg::network_uma::region_reacquirer_fixedsize_reacquire_nothrow(umamap_reacquirer, {{src_grad_umaptr.value(), dispatch_info.src_grad_vd_id}, 
                                                                                                           {src_logit_umaptr.value(), dispatch_info.src_logit_vd_id}, 
                                                                                                           {dst_grad_umaptr, dispatch_info.dst_grad_vd_id}});

                        vma_ptr_t src_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 0u>{});
                        vma_ptr_t src_logit_vmaptr  = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 1u>{}); 
                        vma_ptr_t dst_grad_vmaptr   = dg::network_uma::get_vma_ptr(umamap_reacquirer, std::integral_constant<size_t, 2u>{});

                        dg::network_vmamap::region_remapper_remap_nothrow(src_grad_vmamap_reacquirer, src_grad_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(src_logit_vmamap_reacquirer, src_logit_vmaptr);
                        dg::network_vmamap::region_remapper_remap_nothrow(dst_grad_vmamap_reacquirer, dst_grad_vmaptr);

                        if (dg::network_dispatch_control::is_cuda_dispatch(dispatch_info.dispatch_platform)){
                            auto cuda_resolutor_arg             = CudaResolutorArgument{};
                            cuda_resolutor_arg.src_grad_ptr     = dg::network_vmamap::get_cuda_ptr(src_grad_vmamap_reacquirer);
                            cuda_resolutor_arg.src_logit_ptr    = dg::network_vmamap::get_cuda_ptr(src_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_cuda_ptr(dst_logit_vmamap_reacquirer);
                            cuda_resolutor_arg.src_grad_status  = src_grad_status.value();
                            cuda_resolutor_arg.dispatch_control = dispatch_info.tileops_cuda_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(cuda_vectorizer.get(), cuda_resolutor_arg.src_logit_ptr, cuda_resolutor_arg);
                        } else if (dg::network_dispatch_control::is_host_dispatch(dispatch_info.dispatch_platform)){
                            auto host_resolutor_arg             = HostResolutorArgument{};
                            host_resolutor_arg.src_grad_ptr     = dg::network_vmamap::get_host_ptr(src_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_logit_ptr    = dg::network_vmamap::get_host_ptr(src_logit_vmamap_reacquirer);
                            host_resolutor_arg.dst_grad_ptr     = dg::network_vmamap::get_host_ptr(dst_grad_vmamap_reacquirer);
                            host_resolutor_arg.src_grad_status  = src_grad_status.value();
                            host_resolutor_arg.dispatch_control = dispatch_info.tileops_host_dispatch_control;

                            dg::network_producer_consumer::delvrsrv_deliver(host_vectorizer.get(), host_resolutor_arg.src_logit_ptr, host_resolutor_arg);
                        } else{
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }

                        dg::network_tile_member_getsetter::set_msgrbwd_grad_status_nothrow(dst, TILE_GRAD_STATUS_ZEROED);
                        exception_t descendant_set_err = dg::network_tile_member_getsetter::set_tile_grad_status(src, TILE_GRAD_STATUS_HAS_VALUE);

                        if (dg::network_exception::is_failed(descendant_set_err)){
                            (void) descendant_set_err; //
                        }

                        if (!signal_smph_addr.has_value()){
                            auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(dg::network_memcommit_factory::make_event_backward_do_signal(src, expected_ops_id));
                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        } else{
                            auto sigagg             = dg::network_memcommit_factory::virtualize_sigagg(dg::network_memcommit_factory::make_sigagg_backward_do_signal(signal_smph_addr.value(), src, expected_ops_id));
                            auto decay_signal_event = dg::network_memcommit_factory::virtualize_event(std::move(sigagg));

                            dg::network_producer_consumer::delvrsrv_deliver(this->request_delivery_handle, std::move(decay_signal_event));
                        }
                    }

                    dg::network_producer_consumer::delvrsrv_clear(cuda_vectorizer.get());
                    dg::network_producer_consumer::delvrsrv_clear(host_vectorizer.get());
                    host_synchronizer.sync();
                    cuda_synchronizer.sync();

                    for (size_t i = 0u; i < sz; ++i){
                        if (!msgrbwd_outbound_vec[i].has_value()){
                            continue;
                        }

                        EndUserPacket eu_packet = {};
                        eu_packet_kind          = EUPACKET_MSGRBWD;
                        eu_packet.content       = dg::network_compact_serializer::serialize<dg::string>(GradValue{msgrbwd_outbound_vec[i]->tile_id, 
                                                                                                                  msgrbwd_outbound_vec[i]->timestamp, 
                                                                                                                  msgrbwd_outbound_vec[i]->grad_accum_sz}); //I dont know what this is for, except for system calibrations - we'll place frequencies on memgions - group those memregions - process them serially to guarantee the advertised frequencies - we'll do our best on the system part - but the true benchmarks must be from the msgrbwds + msgrfwds
                        eu_packet.dst           = msgrbwd_outbound_vec[i]->dst;
                        eu_packet.retry_count   = msgrbwd_outbound_vec[i]->retry_count;
                        eu_packet.urgency       = msgrbwd_outbound_vec[i]->urgency;
                        eu_packet.comm          = msgrbwd_outbound_vec[i]->comm;

                        dg::network_producer_consumer::delvrsrv_deliver(this->eu_packet_delivery_handle, std::move(eu_packet));
                    }
                }
            };
    };

    //clear
    class BackwardDoSignalResolutor: public virtual dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent>{

        private:

            const std::unique_ptr<BackwardDoLeafSignalResolutor> leaf_resolutor;
            const std::unique_ptr<BackwardDoBlkrSignalResolutor> blkr_resolutor;
            const std::unique_ptr<BackwardDoRstrSignalResolutor> rstr_resolutor;
            const std::unique_ptr<BackwardDoMonoSignalResolutor> mono_resolutor;
            const std::unique_ptr<BackwardDoPairSignalResolutor> pair_resolutor;
            const std::unique_ptr<BackwardDoUACMSignalResolutor> uacm_resolutor;
            const std::unique_ptr<BackwardDoPACMSignalResolutor> pacm_resolutor;
            const std::unique_ptr<BackwardDoCritSignalResolutor> crit_resolutor;
            const std::unique_ptr<BackwardDoImmuSignalResolutor> immu_resolutor;
            const std::unique_ptr<BackwardDoPolySignalResolutor> poly_resolutor;
            const std::unique_ptr<BackwardDoExtnSrcSignalResolutor> extnsrc_resolutor;
            const std::unique_ptr<BackwardDoExtnSrxSignalResolutor> extnsrx_resolutor;
            const std::unique_ptr<BackwardDoExtnDstSignalResolutor> extndst_resolutor;
            const std::unique_ptr<BackwardDoExtnDsxSignalResolutor> extndsx_resolutor;
            const std::unique_ptr<BackwardDoMsgrFwdSignalResolutor> msgrfwd_resolutor;
            const std::unique_ptr<BackwardDoMsgrBwdSignalResolutor> msgrbwd_resolutor;
            const size_t kvfeed_vectorization_sz;

        public:

            BackwardDoSignalResolutor(std::unique_ptr<BackwardDoLeafSignalResolutor> leaf_resolutor,
                                      std::unique_ptr<BackwardDoBlkrSignalResolutor> blkr_resolutor,
                                      std::unique_ptr<BackwardDoRstrSignalResolutor> rstr_resolutor,
                                      std::unique_ptr<BackwardDoMonoSignalResolutor> mono_resolutor,
                                      std::unique_ptr<BackwardDoPairSignalResolutor> pair_resolutor,
                                      std::unique_ptr<BackwardDoUACMSignalResolutor> uacm_resolutor,
                                      std::unique_ptr<BackwardDoPACMSignalResolutor> pacm_resolutor,
                                      std::unique_ptr<BackwardDoCritSignalResolutor> crit_resolutor,
                                      std::unique_ptr<BackwardDoImmuSignalResolutor> immu_resolutor,
                                      std::unique_ptr<BackwardDoPolySignalResolutor> poly_resolutor,
                                      std::unique_ptr<BackwardDoExtnSrcSignalResolutor> extnsrc_resolutor,
                                      std::unique_ptr<BackwardDoExtnSrxSignalResolutor> extnsrx_resolutor,
                                      std::unique_ptr<BackwardDoExtnDstSignalResolutor> extndst_resolutor,
                                      std::unique_ptr<BackwardDoExtnDsxSignalResolutor> extndsx_resolutor,
                                      std::unique_ptr<BackwardDoMsgrFwdSignalResolutor> msgrfwd_resolutor,
                                      std::unique_ptr<BackwardDoMsgrBwdSignalResolutor> msgrbwd_resolutor,
                                      size_t kvfeed_vectorization_sz) noexcept: leaf_resolutor(std::move(leaf_resolutor)),
                                                                                blkr_resolutor(std::move(blkr_resolutor)),
                                                                                rstr_resolutor(std::move(rstr_resolutor)),
                                                                                mono_resolutor(std;:move(mono_resolutor)),
                                                                                pair_resolutor(std::move(pair_resolutor)),
                                                                                uacm_resolutor(std::move(uacm_resolutor)),
                                                                                pacm_resolutor(std::move(pacm_resolutor)),
                                                                                crit_resolutor(std::move(crit_resolutor)),
                                                                                immu_resolutor(std::move(immu_resolutor)),
                                                                                poly_resolutor(std::move(poly_resolutor)),
                                                                                extnsrc_resolutor(std::move(extnsrc_resolutor)),
                                                                                extnsrx_resolutor(std::move(extnsrx_resolutor)),
                                                                                extndst_resolutor(std::move(extndst_resolutor)),
                                                                                extndsx_resolutor(std::move(extndsx_resolutor)),
                                                                                msgrfwd_resolutor(std::move(msgrfwd_resolutor)),
                                                                                msgrbwd_resolutor(std::move(msgrbwd_resolutor)),
                                                                                kvfeed_vectorization_sz(kvfeed_vectorization_sz){}

            auto is_met_dispatch_requirements(const BackwardDoSignalEvent& event) const noexcept -> exception_t{

                std::expected<tile_kind_t, exception_t> tile_kind = dg::network_tile_member_getsetter::get_tile_kind(event.dst);

                if (!tile_kind.has_value()){
                    return tile_kind.error();
                }

                switch (tile_kind.value()){
                    case TILE_KIND_LEAF: [[fallthrough]]
                    case TILE_KIND_BLKR: [[fallthrough]]
                    case TILE_KIND_RSTR: [[fallthrough]]
                    case TILE_KIND_MONO: [[fallthrough]]
                    case TILE_KIND_PAIR: [[fallthrough]]
                    case TILE_KIND_UACM: [[fallthrough]]
                    case TILE_KIND_PACM: [[fallthrough]]
                    case TILE_KIND_CRIT: [[fallthrough]]
                    case TILE_KIND_IMMU: [[fallthrough]]
                    case TILE_KIND_POLY: [[fallthrough]]
                    case TILE_KIND_EXTNSRC: [[fallthrough]]
                    case TILE_KIND_EXTNSRX: [[fallthrough]]
                    case TILE_KIND_EXTNDST: [[fallthrough]]
                    case TILE_KIND_EXTNDSX: [[fallthrough]]
                    case TILE_KIND_MSGRFWD: [[fallthrough]]
                    case TILE_KIND_MSGRBWD:
                    {
                        return dg::network_exception::SUCCESS;
                    }
                    default:
                    {
                        return dg::network_exception::BAD_TILE_ACCESS;
                    }
                }
            }

            void push(BackwardDoSignalEvent * event_arr, size_t sz) noexcept{

                auto internal_resolutor                 = InternalResolutor{};

                internal_resolutor.leaf_resolutor       = this->leaf_resolutor.get();
                internal_resolutor.blkr_resolutor       = this->blkr_resolutor.get();
                internal_resolutor.rstr_resolutor       = this->rstr_resolutor.get();
                internal_resolutor.mono_resolutor       = this->mono_resolutor.get();
                internal_resolutor.pair_resolutor       = this->pair_resolutor.get();
                internal_resolutor.uacm_resolutor       = this->uacm_resolutor.get();
                internal_resolutor.pacm_resolutor       = this->pacm_resolutor.get();
                internal_resolutor.crit_resolutor       = this->crit_resolutor.get();
                internal_resolutor.immu_resolutor       = this->immu_resolutor.get();
                internal_resolutor.poly_resolutor       = this->poly_resolutor.get();
                internal_resolutor.extnsrc_resolutor    = this->extnsrc_resolutor.get();
                internal_resolutor.extnsrx_resolutor    = this->extnsrx_resolutor.get();
                internal_resolutor.extndst_resolutor    = this->extndst_resolutor.get();
                internal_resolutor.extndsx_resolutor    = this->extndsx_resolutor.get();
                internal_resolutor.msgrfwd_resolutor    = this->msgrfwd_resolutor.get();
                internal_resolutor.msgrbwd_resolutor    = this->msgrbwd_resolutor.get();

                size_t trimmed_kvfeed_vectorization_sz  = std::min(this->kvfeed_vectorization_sz, sz);
                size_t kvfeed_allocation_cost           = dg::network_producer_consumer::delvrsrv_kv_allocation_cost(&internal_resolutor, trimmed_kvfeed_vectorization_sz);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> kvfeed_mem(kvfeed_allocation_cost);
                auto feeder                             = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_kv_open_preallocated_raiihandle(&internal_resolutor, trimmed_kvfeed_vectorization_sz, kvfeed_mem.get()));

                for (size_t i = 0u; i < sz; ++i){
                    if constexpr(DEBUG_MODE_FLAG){
                        if (exception_t err = this->is_met_dispatch_requirements(event_arr[i]); dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::critical(dg::network_exception::verbose(err));
                            std::abort();
                        }
                    }

                    tile_kind_t tile_kind = dg::network_tile_member_getsetter::get_tile_kind_nothrow(event_arr[i].dst);
                    dg::network_producer_consumer::delvrsrv_kv_deliver(feeder.get(), tile_kind, event_arr[i]);
                }
            }
        
        private:
            
            struct InternalResolutor: dg::network_producer_consumer::KVConsumerInterface<tile_kind_t, BackwardDoSignalEvent>{

                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * leaf_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * blkr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * rstr_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * mono_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * pair_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * uacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * pacm_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * crit_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * immu_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * poly_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * extnsrc_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * extnsrx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * extndst_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * extndsx_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * msgrfwd_resolutor;
                dg::network_producer_consumer::ConsumerInterface<BackwardDoSignalEvent> * msgrbwd_resolutor;

                void push(const tile_kind_t& tile_kind, std::move_iterator<BackwardDoSignalEvent *> event_arr, size_t sz){

                    switch (tile_kind){
                        case TILE_KIND_LEAF:
                        {
                            this->leaf_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_BLKR:
                        {
                            this->blkr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_RSTR:
                        {
                            this->rstr_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MONO:
                        {
                            this->mono_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PAIR:
                        {
                            this->pair_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_UACM:
                        {
                            this->uacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_PACM:
                        {
                            this->pacm_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_CRIT:
                        {
                            this->crit_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_IMMU:
                        {
                            this->immu_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_POLY:
                        {
                            this->poly_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRC:
                        {
                            this->extnsrc_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNSRX:
                        {
                            this->extnsrx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDST:
                        {
                            this->extndst_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_EXTNDSX:
                        {
                            this->extndsx_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRFWD:
                        {
                            this->msgrfwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        case TILE_KIND_MSGRBWD:
                        {
                            this->msgrbwd_resolutor->push(event_arr, sz);
                            break;
                        }
                        default:
                        {
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                            } else{
                                std::unreachable();
                            }
                        }
                    }
                }
            };
    };

    //clear
    class MemCommitResolutor: public virtual dg::network_concurrency::WorkerInterface{

        private:

            const std::shared_ptr<dg::network_mempress_dispatch_warehouse::WareHouseInterface> producer;
            const std::unique_ptr<ForwardPingSignalResolutor> fwd_ping_signal_resolutor;
            const size_t fwd_ping_signal_delivery_capacity; 
            const std::unique_ptr<ForwardPongRequestResolutor> fwd_pong_request_resolutor;
            const size_t fwd_pong_request_delivery_capacity;
            const std::unique_ptr<ForwardPingPongRequestResolutor> fwd_pingpong_request_resolutor;
            const size_t fwd_pingpong_request_delivery_capacity;
            const std::unique_ptr<ForwardDoSignalResolutor> fwd_do_resolutor;
            const size_t fwd_do_delivery_capacity;
            const std::unique_ptr<BackwardDoSignalResolutor> bwd_do_resolutor;
            const size_t bwd_do_delivery_capacity;
            const std::unique_ptr<SignalAggregationSignalResolutor> sigagg_signal_resolutor;
            const size_t sigagg_signal_delivery_capacity; 

        public:

            MemCommitResolutor(std::shared_ptr<dg::network_mempress_dispatch_warehouse::WareHouseInterface> producer,
                               std::unique_ptr<ForwardPingSignalResolutor> fwd_ping_signal_resolutor,
                               size_t fwd_ping_signal_delivery_capacity,
                               std::unique_ptr<ForwardPongRequestResolutor> fwd_pong_request_resolutor,
                               size_t fwd_pong_request_delivery_capacity,
                               std::unique_ptr<ForwardPingPongRequestResolutor> fwd_pingpong_request_resolutor,
                               size_t fwd_pingpong_request_delivery_capacity,
                               std::unique_ptr<ForwardDoSignalResolutor> fwd_do_resolutor,
                               size_t fwd_do_delivery_capacity,
                               std::unique_ptr<BackwardDoSignalResolutor> bwd_do_resolutor,
                               size_t bwd_do_delivery_capacity,
                               std::unique_ptr<SignalAggregationSignalResolutor> sigagg_signal_resolutor,
                               size_t sigagg_signal_delivery_capacity) noexcept: producer(std::move(producer)),
                                                                                 fwd_ping_signal_resolutor(std::move(fwd_ping_signal_resolutor)),
                                                                                 fwd_ping_signal_delivery_capacity(fwd_ping_signal_delivery_capacity),
                                                                                 fwd_pong_request_resolutor(std::move(fwd_pong_request_resolutor)),
                                                                                 fwd_pong_request_delivery_capacity(fwd_pong_request_delivery_capacity),
                                                                                 fwd_pingpong_request_resolutor(std::move(fwd_pingpong_request_resolutor)),
                                                                                 fwd_pingpong_request_delivery_capacity(fwd_pingpong_request_delivery_capacity),
                                                                                 fwd_do_resolutor(std::move(fwd_do_resolutor)),
                                                                                 fwd_do_delivery_capacity(fwd_do_delivery_capacity),
                                                                                 bwd_do_resolutor(std::move(bwd_do_resolutor)),
                                                                                 bwd_do_delivery_capacity(bwd_do_delivery_capacity),
                                                                                 sigagg_signal_resolutor(std::move(sigagg_signal_resolutor)),
                                                                                 sigagg_signal_delivery_capacity(sigagg_signal_delivery_capacity){}

            bool run_one_epoch() noexcept{

                dg::vector<virtual_memory_event_t> memevent_vec = this->producer->pop();

                auto fwd_ping_signal_lambda_consumer = [this](std::move_iterator<virtual_memory_event_t *> event_arr, size_t arr_sz) noexcept{
                    dg::network_stack_allocation::NoExceptRawIfPossibleAllocation<ForwardPingSignalEvent[]> tmp_arr(arr_sz);
                    size_t tmp_arr_dispatch_sz = 0u; 

                    for (size_t i = 0u; i < arr_sz; ++i){
                        ForwardPingSignalEvent fwd_ping_signal  = dg::network_memcommit_factory::devirtualize_forward_ping_signal_event(event_arr[i]);
                        exception_t err                         = this->fwd_ping_signal_resolutor->is_met_dispatch_requirements(fwd_ping_signal);

                        if (dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::error_fast(dg::network_exception::verbose(err)); //we cant unwind the stacks, so it's our responsibility to log, the other guys can unwind the stack, so it's not their responsibility to log
                            continue;
                        }

                        tmp_arr[tmp_arr_dispatch_sz++] = std::move(fwd_ping_signal);
                    }

                    this->fwd_ping_signal_resolutor->push(tmp_arr.get(), tmp_arr_dispatch_sz);
                };

                auto fwd_pong_request_lambda_consumer = [this](std::move_iterator<virtual_memory_event_t *> event_arr, size_t arr_sz) noexcept{
                    dg::network_stack_allocation::NoExceptRawIfPossibleAllocation<ForwardPongRequestEvent[]> tmp_arr(arr_sz);
                    size_t tmp_arr_dispatch_sz = 0u; 

                    for (size_t i = 0u; i < arr_sz; ++i){
                        ForwardPongRequestEvent fwd_pong_request    = dg::network_memcommit_factory::devirtualize_forward_pong_request_event(event_arr[i]);
                        exception_t err                             = this->fwd_pong_request_resolutor->is_met_dispatch_requirements(fwd_pong_request); 

                        if (dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::error_fast(dg::network_exception::verbose(err));
                            continue;
                        }

                        tmp_arr[tmp_arr_dispatch_sz++] = std::move(fwd_pong_request);
                    }

                    this->fwd_pong_request_resolutor->push(tmp_arr.get(), tmp_arr_dispatch_sz);
                };

                auto fwd_pingpong_request_lambda_consumer = [this](std::move_iterator<virtual_memory_event_t *> event_arr, size_t arr_sz) noexcept{
                    dg::network_stack_allocation::NoExceptRawIfPossibleAllocation<ForwardPingPongRequestEvent[]> tmp_arr(arr_sz);
                    size_t tmp_arr_dispatch_sz = 0u;

                    for (size_t i = 0u; i < arr_sz; ++i){
                        ForwardPingPongRequestEvent fwd_pingpong_request    = dg::network_memcommit_factory::devirtualize_forward_pingpong_request_event(event_arr[i]);
                        exception_t err                                     = this->fwd_pingpong_request_resolutor->is_met_dispatch_requirements(fwd_pingpong_request);

                        if (dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::error_fast(dg::network_exception::verbose(err));
                            continue;
                        }

                        tmp_arr[tmp_arr_dispatch_sz++] = std::move(fwd_pingpong_request);
                    }

                    this->fwd_pingpong_request_resolutor->push(tmp_arr.get(), tmp_arr_dispatch_sz);
                };

                auto fwd_do_lambda_consumer = [this](std::move_iterator<virtual_memory_event_t *> event_arr, size_t arr_sz) noexcept{
                    dg::network_stack_allocation::NoExceptRawIfPossibleAllocation<ForwardDoSignalEvent[]> tmp_arr(arr_sz);
                    size_t tmp_arr_dispatch_sz = 0u; 

                    for (size_t i = 0u; i < arr_sz; ++i){
                        ForwardDoSignalEvent fwd_do_signal  = dg::network_memcommit_factory::devirtualize_forward_do_signal_event(event_arr[i]);
                        exception_t err                     = this->fwd_do_resolutor->is_met_dispatch_requirements(fwd_do_signal);

                        if (dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::error_fast(dg::network_exception::verbose(err));
                            continue;
                        }

                        tmp_arr[tmp_arr_dispatch_sz++]      = std::move(fwd_do_signal);
                    }

                    this->fwd_do_resolutor->push(tmp_arr.get(), tmp_arr_dispatch_sz);
                };

                auto bwd_do_lambda_consumer = [this](std::move_iterator<virtual_memory_event_t *> event_arr, size_t arr_sz) noexcept{
                    dg::network_stack_allocation::NoExceptRawIfPossibleAllocation<BackwardDoSignalEvent[]> tmp_arr(arr_sz);
                    size_t tmp_arr_dispatch_sz = 0u; 

                    for (size_t i = 0u; i < arr_sz; ++i){
                        BackwardDoSignalEvent bwd_do_signal = dg::network_memcommit_factory::devirtualize_backward_do_signal_event(event_arr[i]);
                        exception_t err                     = this->bwd_do_resolutor->is_met_dispatch_requirements(bwd_do_signal);

                        if (dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::error_fast(dg::network_exception::verbose(err));
                            continue;
                        }

                        tmp_arr[tmp_arr_dispatch_sz++]      = std::move(bwd_do_signal);
                    }

                    this->bwd_do_resolutor->push(tmp_arr.get(), tmp_arr_dispatch_sz);
                };

                auto sigagg_signal_lambda_consumer = [this](std::move_iterator<virtual_memory_event_t *> event_arr, size_t arr_sz) noexcept{
                    dg::network_stack_allocation::NoExceptRawIfPossibleAllocation<VirtualSignalAggregationEvent[]> tmp_arr(arr_sz);
                    size_t tmp_arr_dispatch_sz = 0u;

                    for (size_t i = 0u; i < arr_sz; ++i){
                        VirtualSignalAggregationEvent sigagg_signal = dg::network_memcommit_factory::devirtualize_sigagg_event(event_arr[i]);
                        exception_t err                             = this->sigagg_signal_resolutor->is_met_dispatch_requirements(sigagg_signal);

                        if (dg::network_exception::is_failed(err)){
                            dg::network_log_stackdump::error_fast(dg::network_exception::verbose(err));
                            continue;
                        }

                        tmp_arr[tmp_arr_dispatch_sz++]      = std::move(sigagg_signal);
                    }

                    this->sigagg_signal_resolutor->push(tmp_arr.get(), tmp_arr_dispatch_sz);
                };

                auto fwd_ping_signal_virtual_consumer               = dg::network_producer_consumer::LambdaWrappedConsumer<virtual_memory_event_t, decltype(fwd_ping_signal_lambda_consumer)>(fwd_ping_signal_lambda_consumer);
                size_t trimmed_fwd_ping_signal_delivery_capacity    = std::min(this->fwd_ping_signal_delivery_capacity, sz);
                size_t fpsdh_allocation_cost                        = dg::network_producer_consumer::delvrsrv_allocation_cost(&fwd_ping_signal_virtual_consumer, trimmed_fwd_ping_signal_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> fpsdh_mem(fpsdh_allocation_cost);
                auto fwd_ping_signal_delivery_handle                = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&fwd_ping_signal_virtual_consumer, trimmed_fwd_ping_signal_delivery_capacity, fpsdh_mem.get()));

                auto fwd_pong_request_virtual_consumer              = dg::network_producer_consumer::LambdaWrappedConsumer<virtual_memory_event_t, decltype(fwd_pong_request_lambda_consumer)>(fwd_pong_request_lambda_consumer);
                size_t trimmed_fwd_pong_request_delivery_capacity   = std::min(this->fwd_pong_request_delivery_capacity, sz);
                size_t fpqdh_allocation_cost                        = dg::network_producer_consumer::delvrsrv_allocation_cost(&fwd_pong_request_virtual_consumer, trimmed_fwd_pong_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> fpqdh_mem(fpqdh_allocation_cost);
                auto fwd_pong_request_delivery_handle               = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&fwd_pong_request_virtual_consumer, trimmed_fwd_pong_request_delivery_capacity, fpqdh_mem.get()));

                auto fwd_pingpong_request_virtual_consumer          = dg::network_producer_consumer::LambdaWrappedConsumer<virtual_memory_event_t, decltype(fwd_pingpong_request_lambda_consumer)>(fwd_pingpong_request_lambda_consumer);
                size_t trimmed_fwd_pgpg_request_delivery_capacity   = std::min(this->fwd_pingpong_request_delivery_capacity, sz);
                size_t fpprdh_allocation_cost                       = dg::network_producer_consumer::delvrsrv_allocation_cost(&fwd_pingpong_request_virtual_consumer, trimmed_fwd_pgpg_request_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> fpprdh_mem(fpprdh_allocation_cost);
                auto fwd_pingpong_request_delivery_handle           = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&fwd_pingpong_request_virtual_consumer, trimmed_fwd_pgpg_request_delivery_capacity, fpprdh_mem.get()));

                auto fwd_do_virtual_consumer                        = dg::network_producer_consumer::LambdaWrappedConsumer<virtual_memory_event_t, decltype(fwd_do_lambda_consumer)>(fwd_do_lambda_consumer);
                size_t trimmed_fwd_do_delivery_capacity             = std::min(this->fwd_do_delivery_capacity, sz);
                size_t fddh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_allocation_cost(&fwd_do_virtual_consumer, trimmed_fwd_do_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> fddh_mem(fddh_allocation_cost)
                auto fwd_do_delivery_handle                         = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&fwd_do_virtual_consumer, trimmed_fwd_do_delivery_capacity, fddh_mem.get()));

                auto bwd_do_virtual_consumer                        = dg::network_producer_consumer::LambdaWrappedConsumer<virtual_memory_event_t, decltype(bwd_do_lambda_consumer)>(bwd_do_lambda_consumer);
                size_t trimmed_bwd_do_delivery_capacity             = std::min(this->bwd_do_delivery_capacity, sz);
                size_t bddh_allocation_cost                         = dg::network_producer_consumer::delvrsrv_allocation_cost(&bwd_do_virtual_consumer, trimmed_bwd_do_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> bddh_mem(bddh_allocation_cost); 
                auto bwd_do_delivery_handle                         = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&bwd_do_virtual_consumer, trimmed_bwd_do_delivery_capacity, bddh_mem.get()));

                auto sigagg_signal_virtual_consumer                 = dg::network_producer_consumer::LambdaWrappedConsumer<virtual_memory_event_t, decltype(sigagg_signal_lambda_consumer)>(sigagg_signal_lambda_consumer);
                size_t trimmed_sigagg_signal_delivery_capacity      = std::min(this->sigagg_signal_delivery_capacity, sz);
                size_t ssdh_allocaiton_cost                         = dg::network_producer_consumer::delvrsrv_allocation_cost(&sigagg_signal_virtual_consumer, trimmed_sigagg_signal_delivery_capacity);
                dg::network_stack_allocation::NoExceptRawAllocation<char[]> ssdh_mem(ssdh_allocaiton_cost);
                auto sigagg_signal_delivery_handle                  = dg::network_exception_handler::nothrow_log(dg::network_producer_consumer::delvrsrv_open_preallocated_raiihandle(&sigagg_signal_virtual_consumer, trimmed_sigagg_signal_delivery_capacity, ssdh_mem.get()));

                for (virtual_memory_event_t& memevent: memevent_vec){
                    memory_event_kind_t event_kind = dg::network_memcommit_factory::read_event_kind(memevent);

                    switch (event_kind){
                        case dg::network_memcommit_factory::event_kind_forward_ping_signal:
                        {
                            dg::network_producer_consumer::delvrsrv_deliver(fwd_ping_signal_delivery_handle.get(), std::move(memevent));
                            break;
                        }
                        case dg::network_memcommit_factory::event_kind_forward_pong_request:
                        {
                            dg::network_producer_consumer::delvrsrv_deliver(fwd_pong_request_delivery_handle.get(), std::move(memevent));
                            break;
                        }
                        case dg::network_memcommit_factory::event_kind_forward_pingpong_request:
                        {
                            dg::network_producer_consumer::delvrsrv_deliver(fwd_pingpong_request_delivery_handle.get(), std::move(memevent));
                            break;
                        }
                        case dg::network_memcommit_factory::event_kind_forward_do_signal:
                        {
                            dg::network_producer_consumer::delvrsrv_deliver(fwd_do_delivery_handle.get(), std::move(memevent));
                            break;
                        }
                        case dg::network_memcommit_factory::event_kind_backward_do_signal:
                        {
                            dg::network_producer_consumer::delvrsrv_deliver(bwd_do_delivery_handle.get(), std::move(memevent));
                            break;
                        }
                        case dg::network_memcommit_factory::event_kind_signal_aggregation_signal:
                        {
                            dg::network_producer_consumer::delvrsrv_deliver(sigagg_signal_delivery_handle.get(), std::move(memevent));
                            break;
                        }
                        default:
                        {
                            if constexpr(DEBUG_MODE_FLAG){
                                dg::network_log_stackdump::critical(dg::network_exception::verbose(dg::network_exception::INTERNAL_CORRUPTION));
                                std::abort();
                            } else{
                                std::unreachable();
                            }
                        }
                    }
                }

                return true;
            }
    };
}

#endif